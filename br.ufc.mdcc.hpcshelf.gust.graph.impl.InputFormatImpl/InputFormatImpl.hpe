<?xml version="1.0" encoding="ASCII"?>
<component:component xmlns:component="http://www.example.org/HashComponent">
  <header hash_component_UID="0024000004800000940000000602000000240000525341310004000011000000e5ad503fe49452db0cf7ef67c4ae8bf873a2d82c2f918e161cf1f186f5384a9d0453e9728cda7fa2b9638f4d664d59976996f2d81e92b3818fb4d46c42720068eb81337311cb26a70030b1736d4d357fddef5df169edb21bb941db9274160fe376fe6522273836815afc7ea583a486a863e0295a0d13304c71dcd30831d94ea2" isAbstract="false" kind="Data" name="InputFormatImpl" packagePath="br.ufc.mdcc.hpcshelf.gust.graph.impl">
    <baseType>
      <extensionType>
        <implements>true</implements>
      </extensionType>
      <component hash_component_UID="0024000004800000940000000602000000240000525341310004000011000000b7272ab10dc4406403ac334e596bfa9ef91b5783ec9454692f41dc77650e1746f491ff1a1fb327518d246e5c7feab17f0deae9fb7ab73e3fe40d011c844f5dca926309683e05da210e1dca3a5a85237309a3d19881fb3e26cd0d21d8214f43bdf2a9f8d904248411ecf7f9f5431c4060fe6398db24188ed17a6d9b2f94dbd8b1" localRef="base" location="br.ufc.mdcc.hpcshelf.gust.graph.InputFormat/InputFormat.hpe" name="InputFormat" package="br.ufc.mdcc.hpcshelf.gust.graph" version="1.0.0.0">
        <visualDescription h="60" w="100" x="269" y="540">
          <color b="255" g="255" r="255"/>
        </visualDescription>
        <unitBounds facet="0" facet_instance="0" facet_instance_enclosing="0" parallel="false" uRef="data">
          <visualDescription h="20" w="20" x="5" y="2"/>
        </unitBounds>
      </component>
    </baseType>
    <versions field1="1" field2="0" field3="0" field4="0"/>
    <visualAttributes>
      <color b="255" g="255" r="255"/>
    </visualAttributes>
    <facet_configuration facet="0" multiple="false"/>
  </header>
  <componentInfo>
    <interface iRef="IInputFormatImpl" nArgs="0">
      <sources sourceType="C# Language" versionId="1.0.0.0">
        <file contents="/* Automatically Generated Code */&#xA;&#xA;using System;&#xA;using br.ufc.pargo.hpe.backend.DGAC;&#xA;using br.ufc.pargo.hpe.basic;&#xA;using br.ufc.pargo.hpe.kinds;&#xA;using br.ufc.mdcc.hpcshelf.gust.graph.InputFormat;&#xA;using br.ufc.mdcc.common.Data;&#xA;&#xA;namespace br.ufc.mdcc.hpcshelf.gust.graph.impl.InputFormatImpl &#xA;{&#xA;&#x9;public abstract class BaseIInputFormatImpl: DataStructure, BaseIInputFormat&#xA;&#x9;{&#xA;&#x9;}&#xA;}" name="BaseIInputFormatImpl.cs" srcType="base" uri="br.ufc.mdcc.hpcshelf.gust.graph.impl.InputFormatImpl/bin/1.0.0.0/BaseIInputFormatImpl.dll" versionId="1.0.0.0">
          <dependency>br.ufc.mdcc.hpcshelf.gust.graph.InputFormat/bin/1.0.0.0/BaseIData.dll</dependency>
        </file>
        <file contents="using System;&#xA;using System.Collections;&#xA;using System.Collections.Generic;&#xA;using br.ufc.pargo.hpe.backend.DGAC;&#xA;using br.ufc.pargo.hpe.basic;&#xA;using br.ufc.pargo.hpe.kinds;&#xA;using br.ufc.mdcc.hpcshelf.gust.graph.InputFormat;&#xA;using br.ufc.mdcc.common.Data;&#xA;&#xA;namespace br.ufc.mdcc.hpcshelf.gust.graph.impl.InputFormatImpl {&#xA;&#x9;public class IInputFormatImpl : BaseIInputFormatImpl, IInputFormat {&#xA;&#x9;&#x9;public IInputFormatImpl () {&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;override public void after_initialize () {&#xA;&#x9;&#x9;&#x9;newInstance (); &#xA;&#x9;&#x9;}&#xA;&#xA;&#xA;&#x9;&#x9;public IInputFormatInstance newInstanceIF () {&#xA;&#x9;&#x9;&#x9;IInputFormatInstance instance = (IInputFormatInstance)newInstance ();&#xA;&#x9;&#x9;&#x9;return instance;&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;public object newInstance () {&#xA;&#x9;&#x9;&#x9;this.instance = new IInputFormatInstanceImpl ();&#xA;&#x9;&#x9;&#x9;return this.Instance;&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;private IInputFormatInstance instance;&#xA;&#xA;&#x9;&#x9;public object Instance {&#xA;&#x9;&#x9;&#x9;get { return instance; }&#xA;&#x9;&#x9;&#x9;set { this.instance = (IInputFormatInstance)value; }&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#xA;&#xA;&#x9;[Serializable]&#xA;&#x9;public class IInputFormatInstanceImpl: IInputFormatInstance {&#xA;&#x9;&#x9;public IInputFormatInstanceImpl () {&#xA;&#x9;&#x9;&#x9;source = new int[1];&#xA;&#x9;&#x9;&#x9;target = new int[1];&#xA;&#x9;&#x9;&#x9;weight = new float[1];&#xA;&#x9;&#x9;&#x9;partition_table = new int[1];&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;#region IInputFormatInstance implementation&#xA;&#x9;&#x9;public static int DEFAULT_PARTITION_SIZE = 8;&#xA;&#x9;&#x9;private int[] source;&#xA;&#x9;&#x9;private int[] target;&#xA;&#x9;&#x9;private float[] weight;&#xA;&#x9;&#x9;private int[] partition_table;&#xA;&#x9;&#x9;private int esize = 0;&#xA;&#x9;&#x9;private int vsize = 0;&#xA;&#x9;&#x9;private int partition_size = DEFAULT_PARTITION_SIZE;&#xA;&#x9;&#x9;private int partid = -1;&#xA;&#x9;&#x9;private int count = 0;&#xA;&#xA;&#x9;&#x9;public int[] Source { get{ return source; } }&#xA;&#x9;&#x9;public int[] Target { get{ return target; } }&#xA;&#x9;&#x9;public int[] PartitionTABLE { get{ return partition_table; } set { partition_table = (int[]) value; } }&#xA;&#x9;&#x9;public float[] Weight { get{ return weight; } }&#xA;&#xA;&#x9;&#x9;public int ESIZE { get{ return esize; } }&#xA;&#x9;&#x9;public int VSIZE { get{ return vsize; } }&#xA;&#x9;&#x9;public int PARTITION_SIZE { get{ return partition_size; } set { partition_size = (int) value; } }&#xA;&#x9;&#x9;public int PARTID { get{ return partid; } set { partid = (int) value; } }&#xA;&#xA;&#x9;&#x9;private int[] getInts() { int[] INTS = {esize,vsize,partition_size,partid,count}; return INTS; }&#xA;&#x9;&#x9;public object ObjValue {&#xA;&#x9;&#x9;&#x9;get { return new Tuple&lt;int[],int[],float[],int[],int[]>(source,target,weight,partition_table,getInts()); }&#xA;&#x9;&#x9;&#x9;set { &#xA;&#x9;&#x9;&#x9;&#x9;this.source =          ((Tuple&lt;int[],int[],float[],int[],int[]>)value).Item1;&#xA;&#x9;&#x9;&#x9;&#x9;this.target =          ((Tuple&lt;int[],int[],float[],int[],int[]>)value).Item2;&#xA;&#x9;&#x9;&#x9;&#x9;this.weight =          ((Tuple&lt;int[],int[],float[],int[],int[]>)value).Item3;&#xA;&#x9;&#x9;&#x9;&#x9;this.partition_table = ((Tuple&lt;int[],int[],float[],int[],int[]>)value).Item4;&#xA;&#x9;&#x9;&#x9;&#x9;int[] INTS = ((Tuple&lt;int[],int[],float[],int[],int[]>)value).Item5;&#xA;&#x9;&#x9;&#x9;&#x9;esize = INTS[0]; vsize = INTS[1]; partition_size = INTS[2]; partid = INTS[3]; count = INTS[4];&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;public override int GetHashCode () {&#xA;&#x9;&#x9;&#x9;return this.PARTID;&#x9;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;public override bool Equals (object obj) {&#xA;&#x9;&#x9;&#x9;if (typeof(IInputFormatInstance).IsAssignableFrom (obj.GetType ()))&#xA;&#x9;&#x9;&#x9;&#x9;return this.PARTID == ((IInputFormatInstance)obj).PARTID;&#xA;&#x9;&#x9;&#x9;return false;&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;public IDictionary&lt;int, IInputFormatInstance> extractBins(string fileName)&#xA;        {&#xA;&#x9;&#x9;&#x9;//fileName = System.Environment.GetEnvironmentVariable (&quot;PATH_GRAPH_FILE&quot;);&#xA;&#x9;&#x9;&#x9;this.extractFile(fileName);&#xA;&#x9;&#x9;&#x9;IDictionary&lt;int, IInputFormatInstance> dic = new Dictionary&lt;int, IInputFormatInstance> (this.PARTITION_SIZE);&#xA;&#x9;&#x9;&#x9;bool weighted = this.Weight.Length > 1;&#xA;&#xA;&#x9;&#x9;&#x9;for (int i = 0; i &lt; this.PARTITION_SIZE; i++) &#xA;            {&#xA;&#x9;&#x9;&#x9;&#x9;dic [i] = new IInputFormatInstanceImpl ();&#xA;&#x9;&#x9;&#x9;&#x9;dic [i].PARTID = i;&#xA;&#x9;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;&#x9;for (int i = 0; i &lt; this.ESIZE; i++) &#xA;            {&#xA;&#x9;&#x9;&#x9;&#x9;int s = this.Source [i];&#xA;&#x9;&#x9;&#x9;&#x9;int t = this.Target [i];&#xA;&#x9;&#x9;&#x9;&#x9;int spart = this.PartitionTABLE [s - 1];&#xA;&#x9;&#x9;&#x9;&#x9;int tpart = this.PartitionTABLE [t - 1];&#xA;&#x9;&#x9;&#x9;&#x9;if (!weighted) &#xA;                {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;dic [spart].Add (s, t);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if(spart!=tpart)&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;dic [tpart].Add (s, t);&#xA;&#x9;&#x9;&#x9;&#x9;} else &#xA;                {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;float f = this.Weight[i];&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;dic [spart].Add (s, t, f);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if(spart!=tpart)&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;dic [tpart].Add (s, t, f);&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#xA;            for (int i = 0; i &lt; this.PARTITION_SIZE; i++) &#xA;            {&#xA;&#x9;&#x9;&#x9;&#x9;IInputFormatInstance tmp = dic [i]; &#xA;&#x9;&#x9;&#x9;&#x9;tmp.Trim ();&#xA;&#x9;&#x9;&#x9;&#x9;tmp.PartitionTABLE = this.PartitionTABLE;&#xA;&#x9;&#x9;&#x9;&#x9;tmp.PARTITION_SIZE = this.PARTITION_SIZE;&#xA;&#x9;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;&#x9;source = new int[1];&#xA;&#x9;&#x9;&#x9;target = new int[1];&#xA;&#x9;&#x9;&#x9;weight = new float[1];&#xA;&#x9;&#x9;&#x9;esize = 0;&#xA;&#x9;&#x9;&#x9;vsize = 0;&#xA;&#x9;&#x9;&#x9;partid = -1;&#xA;&#x9;&#x9;&#x9;count = 0;&#xA;&#x9;&#x9;&#x9;return dic;&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;public void Trim(){&#xA;&#x9;&#x9;&#x9;Array.Resize (ref source, count);&#xA;&#x9;&#x9;&#x9;Array.Resize (ref target, count);&#xA;&#x9;&#x9;&#x9;if(weight.Length>1) Array.Resize (ref weight, count);&#xA;&#x9;&#x9;&#x9;esize = count;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;public int firstVertex(int partID){&#xA;&#x9;&#x9;&#x9;for (int i = 0; i &lt; partition_table.Length; i++) {&#xA;&#x9;&#x9;&#x9;&#x9;if (partition_table [i] == partID) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;return i + 1;&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;return -1;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;public void Add(int i, int j){&#xA;&#x9;&#x9;&#x9;if (count == source.Length) {&#xA;&#x9;&#x9;&#x9;&#x9;Array.Resize (ref source, source.Length * 2);&#xA;&#x9;&#x9;&#x9;&#x9;Array.Resize (ref target, target.Length * 2);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;source [count] = i;&#xA;&#x9;&#x9;&#x9;target [count++] = j;&#xA;&#x9;&#x9;&#x9;int tmp = max (i, j);&#xA;&#x9;&#x9;&#x9;if (vsize &lt; tmp)&#xA;&#x9;&#x9;&#x9;&#x9;vsize = tmp;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;private int max(int i, int j){ return i > j ? i : j; }&#xA;&#x9;&#x9;public void Add(int i, int j, float f){&#xA;&#x9;&#x9;&#x9;this.Add (i, j);&#xA;&#x9;&#x9;&#x9;if ((count-1) == weight.Length) {&#xA;&#x9;&#x9;&#x9;&#x9;Array.Resize (ref weight, weight.Length * 2);&#xA;&#x9;&#x9;&#x9;} &#xA;&#x9;&#x9;&#x9;weight [count-1] = f;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;public void Clear (){&#xA;&#x9;&#x9;&#x9;source = new int[1];&#xA;&#x9;&#x9;&#x9;target = new int[1];&#xA;&#x9;&#x9;&#x9;weight = new float[1];&#xA;&#x9;&#x9;&#x9;partition_table = new int[1];&#xA;&#x9;&#x9;&#x9;esize = 0;&#xA;&#x9;&#x9;&#x9;vsize = 0;&#xA;&#x9;&#x9;&#x9;partition_size = DEFAULT_PARTITION_SIZE;&#xA;&#x9;&#x9;&#x9;partid = -1;&#xA;&#x9;&#x9;&#x9;count = 0;&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;public void extractFile(string fileName)&#xA;        {&#xA;&#x9;&#x9;&#x9;byte[] b = {9, 13, 32};&#xA;&#x9;&#x9;&#x9;System.IO.StreamReader file = null;&#xA;&#x9;&#x9;&#x9;checkFiles (fileName, b, file);&#xA;&#x9;&#x9;&#x9;try&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;string line; bool weighted = false;&#xA;&#x9;&#x9;&#x9;&#x9;file = new System.IO.StreamReader(fileName);&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;if((line = file.ReadLine()) != null) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if (!(line.Trim().Equals (&quot;&quot;))) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;string[] ij = line.Split ((char)b[0],(char)b[1],(char)b[2]);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;int i = int.Parse(ij[0]);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;int j = int.Parse(ij[1]);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if(ij.Length==2)&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;this.Add(i,j);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;else &#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if(ij.Length==3){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;weighted = true;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;weight = new float[esize];&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;this.Add(i,j,float.Parse(ij[2]));&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;while((line = file.ReadLine()) != null) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if (!(line.Trim().Equals (&quot;&quot;))) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;string[] ij = line.Split ((char)b[0],(char)b[1],(char)b[2]);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;int i = int.Parse(ij[0]);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;int j = int.Parse(ij[1]);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if(!weighted) this.Add(i,j);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;else this.Add(i,j,float.Parse(ij[2]));&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;catch (System.IO.IOException e) {&#xA;&#x9;&#x9;&#x9;&#x9;Console.WriteLine(&quot;Error reading from {0}. Message = {1}&quot;, fileName, e.Message);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;finally {&#xA;&#x9;&#x9;&#x9;&#x9;if (file != null) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;file.Close();&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;private void checkFiles(string fileName, byte[] b, System.IO.StreamReader file){&#xA;&#x9;&#x9;&#x9;bool graph = System.IO.File.Exists (fileName);&#xA;&#x9;&#x9;&#x9;bool headExists = System.IO.File.Exists (fileName+&quot;.head&quot;);&#xA;&#x9;&#x9;&#x9;if (!graph)&#xA;&#x9;&#x9;&#x9;&#x9;throw new EntryPointNotFoundException (&quot;** PATH_GRAPH_FILE **: File Name NOT FOUND EXCEPTION&quot;);&#xA;&#x9;&#x9;&#x9;try&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;string line;&#xA;&#x9;&#x9;&#x9;&#x9;if(headExists){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;file = new System.IO.StreamReader(fileName+&quot;.head&quot;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;while((line = file.ReadLine()) != null) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if ( !(line.Trim().Equals (&quot;&quot;)) &amp;&amp; !(line.Trim()[0].Equals ('#'))) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;string[] ij = line.Split ((char)b[0],(char)b[1],(char)b[2]);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;vsize = int.Parse(ij[0]);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;esize = int.Parse(ij[1]);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if(ij.Length>2) partition_size =  int.Parse(ij[2]);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;break;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;try&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;file = new System.IO.StreamReader(fileName);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;while((line = file.ReadLine()) != null) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (!(line.Trim().Equals (&quot;&quot;))) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;string[] ij = line.Split ((char)b[0],(char)b[1],(char)b[2]);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;int i = int.Parse(ij[0]);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;int j = int.Parse(ij[1]);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;esize++;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;int tmp = max (i, j);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (vsize &lt; tmp)&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;vsize = tmp;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;catch (System.IO.IOException e) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;Console.WriteLine(&quot;Error reading from {0}. Message = {1}&quot;, fileName, e.Message);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;finally {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (file != null) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;file.Close();&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;System.IO.StreamWriter wfile =  new System.IO.StreamWriter(fileName+&quot;.head&quot;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;try{&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;wfile.WriteLine(vsize+&quot; &quot;+esize);//+&quot; &quot;+partition_size);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;catch (System.IO.IOException e) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;Console.WriteLine(&quot;Error writing from {0}. Message = {1}&quot;, fileName+&quot;.head&quot;, e.Message);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;finally {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;wfile.Close();&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (wfile != null) &#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;wfile.Dispose();&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;catch (System.IO.IOException e) {&#xA;&#x9;&#x9;&#x9;&#x9;Console.WriteLine(&quot;Error reading from {0}. Message = {1}&quot;, fileName+&quot;.head&quot;, e.Message);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;finally {&#xA;&#x9;&#x9;&#x9;&#x9;if (file != null) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;file.Close();&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;source = new int[esize];&#xA;&#x9;&#x9;&#x9;target = new int[esize]; //weight = new float[esize];&#xA;&#x9;&#x9;&#x9;partition_table = new int[vsize];&#xA;&#x9;&#x9;&#x9;bool metisPart = System.IO.File.Exists (fileName+&quot;.metis.part.&quot;+partition_size);&#xA;&#x9;&#x9;&#x9;int idx = 0;&#xA;&#x9;&#x9;&#x9;try&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;string line;&#xA;&#x9;&#x9;&#x9;&#x9;if(metisPart){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;file = new System.IO.StreamReader(fileName+&quot;.metis.part.&quot;+partition_size);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;while((line = file.ReadLine()) != null) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (!(line.Trim().Equals (&quot;&quot;))) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;string[] p = line.Split ((char)b[0],(char)b[1],(char)b[2]);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;int i = int.Parse(p[0]);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;PartitionTABLE[idx++] = i;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;else {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;int tmp = 0; //System.IO.StreamWriter wfile =  new System.IO.StreamWriter(fileName+&quot;.metis.part.&quot;+part);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;for(int i=0;i&lt;vsize;i++){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;partition_table[i] = tmp; //wfile.Write(&quot;&quot;+tmp+Environment.NewLine);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if((i%partition_size)==partition_size-1) tmp = ++tmp==partition_size?0:tmp;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;} //wfile.Close();&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;catch (System.IO.IOException e) {&#xA;&#x9;&#x9;&#x9;&#x9;Console.WriteLine(&quot;Error reading from {0}. Message = {1}&quot;, fileName+&quot;.metis.part.&quot;+partition_size, e.Message);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;finally {&#xA;&#x9;&#x9;&#x9;&#x9;if (file != null) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;file.Close();&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;#endregion&#xA;&#xA;&#x9;&#x9;#region ICloneable implementation&#xA;&#xA;&#x9;&#x9;public object Clone () {&#xA;&#x9;&#x9;&#x9;IInputFormatInstanceImpl clone = new IInputFormatInstanceImpl ();&#xA;&#x9;&#x9;&#x9;clone.source = (int[])this.source.Clone ();&#xA;&#x9;&#x9;&#x9;clone.target = (int[])this.target.Clone ();&#xA;&#x9;&#x9;&#x9;clone.weight = (float[])this.weight.Clone ();&#xA;&#x9;&#x9;&#x9;clone.partition_table = (int[])this.partition_table.Clone ();&#xA;&#x9;&#x9;&#x9;clone.esize = this.esize;&#xA;&#x9;&#x9;&#x9;clone.vsize = this.vsize;&#xA;&#x9;&#x9;&#x9;clone.partition_size = this.partition_size;&#xA;&#x9;&#x9;&#x9;clone.PARTID = this.PARTID;&#xA;&#x9;&#x9;&#x9;clone.count = this.count;&#xA;&#x9;&#x9;&#x9;return clone;&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;#endregion&#xA;&#xA;&#x9;}&#xA;&#xA;&#xA;}&#xA;" name="IInputFormatImpl.cs" srcType="user" uri="br.ufc.mdcc.hpcshelf.gust.graph.impl.InputFormatImpl/bin/1.0.0.0/IInputFormatImpl.dll" versionId="1.0.0.0">
          <dependency>%WORKSPACE/br.ufc.mdcc.hpcshelf.gust.graph.impl.InputFormatImpl/bin/1.0.0.0/BaseIInputFormatImpl.dll</dependency>
          <dependency>br.ufc.mdcc.hpcshelf.gust.graph.InputFormat/bin/1.0.0.0/IData.dll</dependency>
        </file>
      </sources>
      <visualDescription h="40" w="168" x="165" y="370">
        <color b="83" g="87" r="85"/>
      </visualDescription>
    </interface>
    <unit facet="0" iRef="IInputFormatImpl" multiple="false" private="false" replica="0" uRef="data" visibleInterface="true">
      <super cRef="base" uRef="data"/>
      <visualDescription h="40" w="80" x="205" y="473"/>
    </unit>
  </componentInfo>
</component:component>