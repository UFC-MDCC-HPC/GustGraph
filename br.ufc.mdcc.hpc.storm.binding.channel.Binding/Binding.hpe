<?xml version="1.0" encoding="ASCII"?>
<component:component xmlns:component="http://www.example.org/HashComponent">
  <header hash_component_UID="0024000004800000940000000602000000240000525341310004000011000000953c3d80f5d59ffc2a8a4c47f0ce50d22579b6961754fc10609dc7dfb4efa2c7ec5fc52b0fcc74d39c106d99c94fc84dbecc34d23b6c9b3e3cdb8f5121fb47820269827ef64060ad4ae187d45e7ab7af2b6d4c31afcc4e9af770b3740a8db4dabd47b199c225786a99200ea3cbb6a9c868cb6e7bded423350bb0c7262b09ea95" isAbstract="true" kind="Binding" name="Binding" packagePath="br.ufc.mdcc.hpc.storm.binding.channel">
    <baseType>
      <extensionType>
        <extends>true</extends>
      </extensionType>
      <component hash_component_UID="00240000048000009400000006020000002400005253413100040000110000000910f641a04b6b75043f8be9ef4d49cbce8404c01d91f299dc297ee13fc7f940c457a620d6918207cad94ccdc1550f5b5789aafab51da2f334242a3b20b3fec791952f51803db542cc5346473117ace774a2f41abe8c7766ca5dfd6fb3b46ff2afc51b517579f3871d0bffa91251dd609ebbedb5221fd1c73add74ca88a668f4" localRef="base" location="br.ufc.mdcc.hpc.storm.kind.Binding/Binding.hpe" name="Binding" package="br.ufc.mdcc.hpc.storm.kind" version="1.0.0.0">
        <visualDescription h="95" w="95" x="254" y="228">
          <color b="255" g="255" r="255"/>
        </visualDescription>
        <unitBounds facet="0" facet_instance="0" facet_instance_enclosing="0" parallel="false" uRef="root">
          <visualDescription h="20" w="20" x="5" y="2"/>
        </unitBounds>
        <unitBounds facet="0" facet_instance="0" facet_instance_enclosing="0" parallel="true" uRef="peer">
          <visualDescription h="20" w="20" x="28" y="2"/>
        </unitBounds>
      </component>
    </baseType>
    <versions field1="1" field2="0" field3="0" field4="0"/>
    <visualAttributes>
      <color b="255" g="255" r="255"/>
    </visualAttributes>
    <facet_configuration facet="0" multiple="false"/>
  </header>
  <componentInfo>
    <interface iRef="IChannelRoot" nArgs="0">
      <sources sourceType="C# Language" versionId="1.0.0.0">
        <file contents="/* AUTOMATICALLY GENERATE CODE */&#xA;&#xA;using br.ufc.pargo.hpe.kinds;&#xA;using br.ufc.mdcc.hpc.storm.kind.Binding;&#xA;&#xA;namespace br.ufc.mdcc.hpc.storm.binding.channel.Binding&#xA;{&#xA;&#x9;public interface BaseIChannelRoot : BaseIRoot, IBindingKind &#xA;&#x9;{&#xA;&#x9;}&#xA;}" name="BaseIChannelRoot.cs" srcType="base" uri="br.ufc.mdcc.hpc.storm.binding.channel.Binding/bin/1.0.0.0/BaseIChannelRoot.dll" versionId="1.0.0.0">
          <dependency>br.ufc.mdcc.hpc.storm.kind.Binding/bin/1.0.0.0/BaseIRoot.dll</dependency>
        </file>
        <file contents="using br.ufc.pargo.hpe.kinds;&#xA;using br.ufc.mdcc.hpc.storm.kind.Binding;&#xA;&#xA;namespace br.ufc.mdcc.hpc.storm.binding.channel.Binding&#xA;{&#xA;&#x9;public interface IChannelRoot : BaseIChannelRoot, IRoot&#xA;&#x9;{&#xA;&#x9;}&#xA;}" name="IChannelRoot.cs" srcType="user" uri="br.ufc.mdcc.hpc.storm.binding.channel.Binding/bin/1.0.0.0/IChannelRoot.dll" versionId="1.0.0.0">
          <dependency>%WORKSPACE/br.ufc.mdcc.hpc.storm.binding.channel.Binding/bin/1.0.0.0/BaseIChannelRoot.dll</dependency>
          <dependency>br.ufc.mdcc.hpc.storm.kind.Binding/bin/1.0.0.0/IRoot.dll</dependency>
        </file>
        <file contents="using System;&#xA;using MPI;&#xA;using System.Runtime.Serialization.Formatters.Binary;&#xA;using System.IO;&#xA;using System.Collections.Generic;&#xA;using System.Threading;&#xA;&#xA;namespace br.ufc.mdcc.hpc.storm.binding.channel.Binding&#xA;{&#xA;&#x9;/*&#xA;    public enum AliencommunicatorOperation {&#xA;        SEND, &#xA;        RECEIVE, &#xA;        SEND_ARRAY,&#xA;        RECEIVE_ARRAY,&#xA;        PROBE,&#xA;        ALL_GATHER,&#xA;        ALL_GATHER_FLATTENED,&#xA;        ALL_REDUCE,&#xA;        ALL_REDUCE_ARRAY,&#xA;        ALL_TO_ALL,&#xA;        ALL_TO_ALL_FLATTENED,&#xA;        REDUCE_SCATTER,&#xA;        BROADCAST,&#xA;        BROADCAST_ARRAY,&#xA;        SCATTER,&#xA;        SCATTER_FROM_FLATTENED,&#xA;        GATHER,&#xA;        GATHER_FLATTENED,&#xA;        REDUCE,&#xA;        REDUCE_ARRAY&#xA;    };&#xA;    */&#xA;&#xA;&#x9;public class AliencommunicatorOperation&#xA;&#x9;{&#xA;&#x9;&#x9;public const int SEND = 0;&#xA;&#x9;&#x9;public const int RECEIVE = 1;&#xA;&#x9;&#x9;public const int SEND_ARRAY = 2;&#xA;&#x9;&#x9;public const int RECEIVE_ARRAY = 3;&#xA;&#x9;&#x9;public const int PROBE = 4;&#xA;&#x9;&#x9;public const int ALL_GATHER = 5;&#xA;&#x9;&#x9;public const int ALL_GATHER_FLATTENED = 6;&#xA;&#x9;&#x9;public const int ALL_REDUCE = 7;&#xA;&#x9;&#x9;public const int ALL_REDUCE_ARRAY = 8;&#xA;&#x9;&#x9;public const int ALL_TO_ALL = 9;&#xA;&#x9;&#x9;public const int ALL_TO_ALL_FLATTENED = 10;&#xA;&#x9;&#x9;public const int REDUCE_SCATTER = 11;&#xA;&#x9;&#x9;public const int BROADCAST = 12;&#xA;&#x9;&#x9;public const int BROADCAST_ARRAY = 13;&#xA;&#x9;&#x9;public const int SCATTER = 14;&#xA;&#x9;&#x9;public const int SCATTER_FROM_FLATTENED = 15;&#xA;&#x9;&#x9;public const int GATHER = 16;&#xA;&#x9;&#x9;public const int GATHER_FLATTENED = 17;&#xA;&#x9;&#x9;public const int REDUCE = 18;&#xA;&#x9;&#x9;public const int REDUCE_ARRAY = 19;&#xA;&#x9;&#x9;public const int SYNC_SEND = 20;&#xA;&#x9;};&#xA;&#xA;&#x9;public interface Aliencommunicator&#xA;&#x9;{&#xA;&#x9;&#x9;#region point-to-point operations&#xA;&#xA;&#x9;&#x9;// Value versions ...&#xA;&#xA;&#x9;&#x9;void Send&lt;T>(T value, Tuple&lt;int, int> dest, int tag);&#xA;&#xA;&#x9;&#x9;//      void SendReceive&lt;T> (T inValue, int dest, int tag, out T outValue); /* ok */&#xA;&#x9;&#x9;//      void SendReceive&lt;T> (T inValue, int dest, int sendTag, int source, int recvTag, out T outValue); /* ok */&#xA;&#x9;&#x9;//      void SendReceive&lt;T> (T inValue, int dest, int sendTag, int source, int recvTag, out T outValue, out CompletedStatus status);&#xA;&#xA;&#x9;&#x9;T Receive&lt;T>(Tuple&lt;int, int> source, int tag); /* ok */&#xA;&#x9;&#x9;void Receive&lt;T>(Tuple&lt;int, int> source, int tag, out T value); /* ok */&#xA;&#x9;&#x9;void Receive&lt;T>(Tuple&lt;int, int> source, int tag, out T value, out CompletedStatus status);&#xA;&#xA;&#x9;&#x9;IRequest ImmediateSend&lt;T>(T value, Tuple&lt;int, int> dest, int tag);&#xA;&#x9;&#x9;IReceiveRequest ImmediateReceive&lt;T>(Tuple&lt;int, int> source, int tag);&#xA;&#xA;&#x9;&#x9;// Array versions ... &#xA;&#x9;&#x9;void Send&lt;T>(T[] values, Tuple&lt;int, int> dest, int tag);&#xA;&#xA;&#x9;&#x9;void Receive&lt;T>(Tuple&lt;int, int> source, int tag, ref T[] values); /* ok */&#xA;&#x9;&#x9;void Receive&lt;T>(Tuple&lt;int, int> source, int tag, ref T[] values, out CompletedStatus status);&#xA;&#xA;&#x9;&#x9;IRequest ImmediateSend&lt;T>(T[] values, Tuple&lt;int, int> dest, int tag);&#xA;&#x9;&#x9;IReceiveRequest ImmediateReceive&lt;T>(Tuple&lt;int, int> source, int tag, T[] values);&#xA;&#xA;&#x9;&#x9;// Probe.&#xA;&#xA;&#x9;&#x9;//TODO      Status Probe (Tuple&lt;int,int> source, int tag);&#xA;&#x9;&#x9;//TODO      Status ImmediateProbe (Tuple&lt;int,int> source, int tag);&#xA;&#xA;&#x9;&#x9;//      void SendReceive&lt;T>(T[] inValues, int dest, int tag, ref T[] outValues); /* ok */&#xA;&#x9;&#x9;//      void SendReceive&lt;T>(T[] inValues, int dest, int sendTag, int source, int recvTag, ref T[] outValues); /* ok */&#xA;&#x9;&#x9;//      void SendReceive&lt;T> (T[] inValues, int dest, int sendTag, int source, int recvTag, ref T[] outValues, out CompletedStatus status);&#xA;&#xA;&#x9;&#x9;#endregion point-to-point operations&#xA;&#xA;&#x9;&#x9;#region collective operations&#xA;&#xA;&#x9;&#x9;#region AllToAll&#xA;&#xA;&#x9;&#x9;//TODO      T[] Allgather&lt;T> (int facet, T value);&#xA;&#x9;&#x9;//TODO      void Allgather&lt;T> (int facet, T inValue, ref T[] outValues);&#xA;&#xA;&#x9;&#x9;//TODO      void AllgatherFlattened&lt;T> (int facet, T[] inValues, int count, ref T[] outValues);&#xA;&#x9;&#x9;//TODO      void AllgatherFlattened&lt;T> (int facet, T[] inValues, int[] counts, ref T[] outValues);&#xA;&#xA;&#x9;&#x9;//TODO      T Allreduce&lt;T>(int facet, T value, ReductionOperation&lt;T> op);&#xA;&#x9;&#x9;//TODO      T[] Allreduce&lt;T> (int facet, T[] values, ReductionOperation&lt;T> op);&#xA;&#x9;&#x9;//TODO      void Allreduce&lt;T> (int facet, T[] inValues, ReductionOperation&lt;T> op, ref T[] outValues);&#xA;&#xA;&#x9;&#x9;//TODO      T[] Alltoall&lt;T> (int facet, T[] values);&#xA;&#x9;&#x9;//TODO      void Alltoall&lt;T> (int facet, T[] inValues, ref T[] outValues);&#xA;&#xA;&#x9;&#x9;//TODO void AlltoallFlattened&lt;T> (int facet, T[] inValues, int[] sendCounts, int[] recvCounts, ref T[] outValues);&#xA;&#xA;&#x9;&#x9;//TODO      T[] ReduceScatter&lt;T> (int facet, T[] values, ReductionOperation&lt;T> op, int[] counts);&#xA;&#x9;&#x9;//TODO      void ReduceScatter&lt;T> (int facet, T[] inValues, ReductionOperation&lt;T> op, int[] counts, ref T[] outValues);&#xA;&#xA;&#x9;&#x9;#endregion AllToAll&#xA;&#xA;&#xA;&#x9;&#x9;#region OneToAll&#xA;&#xA;&#x9;&#x9;//TODO      void Broadcast&lt;T> (int facet, ref T value, int root);&#xA;&#x9;&#x9;//TODO      void Broadcast&lt;T> (int facet, ref T[] values, int root);&#xA;&#xA;&#x9;&#x9;//TODO      void Scatter&lt;T> (int facet, T[] values);&#xA;&#x9;&#x9;//TODO      T Scatter&lt;T>(int facet, int root);&#xA;&#x9;&#x9;//TODO      void Scatter&lt;T>(int facet);&#xA;&#xA;&#x9;&#x9;//TODO      void ScatterFromFlattened&lt;T> (int facet, T[] inValues, int count);&#xA;&#x9;&#x9;//TODO      void ScatterFromFlattened&lt;T> (int facet, T[] inValues, int[] counts);&#xA;&#x9;&#x9;//TODO      void ScatterFromFlattened&lt;T> (int facet, int count, int root, ref T[] outValues);&#xA;&#x9;&#x9;//TODO      void ScatterFromFlattened&lt;T> (int facet, int[] counts, int root, ref T[] outValues);&#xA;&#x9;&#x9;//TODO      void ScatterFromFlattened&lt;T> (int facet);&#xA;&#x9;&#x9;//TODO      void ScatterFromFlattened&lt;T> (int facet, T[] inValues, int count, int root, ref T[] outValues);&#xA;&#x9;&#x9;//TODO      void ScatterFromFlattened&lt;T> (int facet, T[] inValues, int[] counts, int root, ref T[] outValues);&#xA;&#xA;&#x9;&#x9;#endregion OneToAll&#xA;&#xA;&#xA;&#x9;&#x9;#region AllToOne&#xA;&#xA;&#x9;&#x9;//TODO      T[] Gather&lt;T> (int facet, T value, int root);&#xA;&#x9;&#x9;//TODO      T[] Gather&lt;T> (int facet, int root);&#xA;&#x9;&#x9;//TODO      void Gather&lt;T>(int facet);&#xA;&#x9;&#x9;//TODO      void Gather&lt;T>(int facet, T inValue, int root, ref T[] outValues);&#xA;&#xA;&#x9;&#x9;//TODO      void GatherFlattened&lt;T>(int facet, int count, ref T[] outValues);&#xA;&#x9;&#x9;//TODO      T[] GatherFlattened&lt;T>(int facet, int count);&#xA;&#x9;&#x9;//TODO      void GatherFlattened&lt;T> (int facet, T[] inValues, int root);&#xA;&#x9;&#x9;//TODO      void GatherFlattened&lt;T>(int facet);&#xA;&#x9;&#x9;//TODO      void GatherFlattened&lt;T> (int facet, int[] counts, ref T[] outValues);&#xA;&#x9;&#x9;//TODO      T[] GatherFlattened&lt;T>(int facet, int[] counts);&#xA;&#xA;&#x9;&#x9;//TODO      T Reduce&lt;T> (int facet, T value, ReductionOperation&lt;T> op, int root);&#xA;&#x9;&#x9;//TODO      T[] Reduce&lt;T>(int facet, T[] values, ReductionOperation&lt;T> op, int root);&#xA;&#x9;&#x9;//TODO      void Reduce&lt;T>(int facet, T[] inValues, ReductionOperation&lt;T> op, int root, ref T[] outValues);&#xA;&#xA;&#x9;&#x9;#endregion AllToOne&#xA;&#xA;&#xA;&#x9;&#x9;#endregion collective operations&#xA;&#xA;&#x9;}&#xA;&#xA;&#xA;&#x9;public interface Status&#xA;&#x9;{&#xA;&#x9;&#x9;Tuple&lt;int, int> Source { get; }&#xA;&#x9;&#x9;int Tag { get; }&#xA;&#x9;&#x9;int? Count(Type type);&#xA;&#x9;&#x9;bool Cancelled { get; }&#xA;&#x9;}&#xA;&#xA;&#x9;public interface CompletedStatus : Status&#xA;&#x9;{&#xA;&#x9;&#x9;int? Count { get; }&#xA;&#x9;}&#xA;&#xA;&#x9;public class SAFeStatus : Status&#xA;&#x9;{&#xA;&#xA;&#x9;&#x9;/// &lt;summary>&#xA;&#x9;&#x9;///   Constructs a &lt;code>Status&lt;/code> object from a low-level &lt;see cref=&quot;Unsafe.MPI_Status&quot;/> structure.&#xA;&#x9;&#x9;/// &lt;/summary>&#xA;&#x9;&#x9;internal SAFeStatus(Tuple&lt;int, int> source, int tag)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;this.source = source;&#xA;&#x9;&#x9;&#x9;this.tag = tag;&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;Tuple&lt;int, int> source;&#xA;&#xA;&#x9;&#x9;/// &lt;summary>&#xA;&#x9;&#x9;/// The rank of the process that sent the message.&#xA;&#x9;&#x9;/// &lt;/summary>&#xA;&#x9;&#x9;public Tuple&lt;int, int> Source&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;get&#xA;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;return source;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;int tag;&#xA;&#xA;&#x9;&#x9;/// &lt;summary>&#xA;&#x9;&#x9;/// The tag used to send the message.&#xA;&#x9;&#x9;/// &lt;/summary>&#xA;&#x9;&#x9;public int Tag&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;get&#xA;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;return tag;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;/// &lt;summary>&#xA;&#x9;&#x9;/// Determine the number of elements transmitted by the communication&#xA;&#x9;&#x9;/// operation associated with this object.&#xA;&#x9;&#x9;/// &lt;/summary>&#xA;&#x9;&#x9;/// &lt;param name=&quot;type&quot;>&#xA;&#x9;&#x9;///   The type of data that will be stored in the message.&#xA;&#x9;&#x9;/// &lt;/param>&#xA;&#x9;&#x9;/// &lt;returns>&#xA;&#x9;&#x9;///   If the type of the data is a value type, returns the number&#xA;&#x9;&#x9;///   of elements in the message. Otherwise, returns &lt;c>null&lt;/c>,&#xA;&#x9;&#x9;///   because the number of elements stored in the message won't&#xA;&#x9;&#x9;///   be known until the message is received.&#xA;&#x9;&#x9;/// &lt;/returns>&#xA;&#x9;&#x9;public int? Count(Type type)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;// TODO:&#xA;&#x9;&#x9;&#x9;return null;&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;/// &lt;summary>&#xA;&#x9;&#x9;/// Whether the communication was cancelled before it completed.&#xA;&#x9;&#x9;/// &lt;/summary>&#xA;&#x9;&#x9;public bool Cancelled&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;get&#xA;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;// TODO: cancel functionality not implemented ...&#xA;&#x9;&#x9;&#x9;&#x9;return false;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#xA;&#x9;/// &lt;summary>&#xA;&#x9;/// Information about a specific message that has already been&#xA;&#x9;/// transferred via MPI.&#xA;&#x9;/// &lt;/summary>&#xA;&#x9;public class SAFeCompletedStatus : SAFeStatus, CompletedStatus&#xA;&#x9;{&#xA;&#x9;&#x9;/// &lt;summary>&#xA;&#x9;&#x9;///   Constructs a &lt;code>Status&lt;/code> object from a low-level &lt;see cref=&quot;Unsafe.MPI_Status&quot;/> structure&#xA;&#x9;&#x9;///   and a count of the number of elements received.&#xA;&#x9;&#x9;/// &lt;/summary>&#xA;&#x9;&#x9;internal SAFeCompletedStatus(Tuple&lt;int, int> source, int tag, int count) : base(source, tag)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;this.count = count;&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;internal SAFeCompletedStatus(Tuple&lt;int, int> source, int tag) : base(source, tag)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;public static CompletedStatus createStatus(Tuple&lt;int, int> source, int tag, int count)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;return new SAFeCompletedStatus(source, tag, count);&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;public static CompletedStatus createStatus(Tuple&lt;int, int> source, int tag)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;return new SAFeCompletedStatus(source, tag);&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;private int? count = null;&#xA;&#xA;&#x9;&#x9;/// &lt;summary>&#xA;&#x9;&#x9;/// Determines the number of elements in the transmitted message.&#xA;&#x9;&#x9;/// &lt;/summary>&#xA;&#x9;&#x9;public int? Count&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;get { return count; }&#xA;&#x9;&#x9;&#x9;set { count = value; }&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;}&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#x9;public class MPIStatus : Status&#xA;&#x9;{&#xA;&#x9;&#x9;private MPI.Status internal_status;&#xA;&#xA;&#x9;&#x9;/// &lt;summary>&#xA;&#x9;&#x9;///   Constructs a &lt;code>Status&lt;/code> object from a low-level &lt;see cref=&quot;Unsafe.MPI_Status&quot;/> structure.&#xA;&#x9;&#x9;/// &lt;/summary>&#xA;&#x9;&#x9;internal MPIStatus(MPI.Status internal_status, Tuple&lt;int, int> source)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;this.source = source;&#xA;&#x9;&#x9;&#x9;this.internal_status = internal_status;&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;Tuple&lt;int, int> source;&#xA;&#xA;&#x9;&#x9;/// &lt;summary>&#xA;&#x9;&#x9;/// The rank of the process that sent the message.&#xA;&#x9;&#x9;/// &lt;/summary>&#xA;&#x9;&#x9;public Tuple&lt;int, int> Source&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;get&#xA;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;return source;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;/// &lt;summary>&#xA;&#x9;&#x9;/// The tag used to send the message.&#xA;&#x9;&#x9;/// &lt;/summary>&#xA;&#x9;&#x9;public int Tag&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;get&#xA;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;return internal_status.Tag;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;/// &lt;summary>&#xA;&#x9;&#x9;/// Determine the number of elements transmitted by the communication&#xA;&#x9;&#x9;/// operation associated with this object.&#xA;&#x9;&#x9;/// &lt;/summary>&#xA;&#x9;&#x9;/// &lt;param name=&quot;type&quot;>&#xA;&#x9;&#x9;///   The type of data that will be stored in the message.&#xA;&#x9;&#x9;/// &lt;/param>&#xA;&#x9;&#x9;/// &lt;returns>&#xA;&#x9;&#x9;///   If the type of the data is a value type, returns the number&#xA;&#x9;&#x9;///   of elements in the message. Otherwise, returns &lt;c>null&lt;/c>,&#xA;&#x9;&#x9;///   because the number of elements stored in the message won't&#xA;&#x9;&#x9;///   be known until the message is received.&#xA;&#x9;&#x9;/// &lt;/returns>&#xA;&#x9;&#x9;public int? Count(Type type)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;return internal_status.Count(type);&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;/// &lt;summary>&#xA;&#x9;&#x9;/// Whether the communication was cancelled before it completed.&#xA;&#x9;&#x9;/// &lt;/summary>&#xA;&#x9;&#x9;public bool Cancelled&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;get&#xA;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;return internal_status.Cancelled;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;}&#xA;&#xA;&#x9;/// &lt;summary>&#xA;&#x9;/// Information about a specific message that has already been&#xA;&#x9;/// transferred via MPI.&#xA;&#x9;/// &lt;/summary>&#xA;&#x9;public class MPICompletedStatus : MPIStatus, CompletedStatus&#xA;&#x9;{&#xA;&#x9;&#x9;private MPI.CompletedStatus internal_status;&#xA;&#xA;&#x9;&#x9;/// &lt;summary>&#xA;&#x9;&#x9;///   Constructs a &lt;code>Status&lt;/code> object from a low-level &lt;see cref=&quot;Unsafe.MPI_Status&quot;/> structure&#xA;&#x9;&#x9;///   and a count of the number of elements received.&#xA;&#x9;&#x9;/// &lt;/summary>&#xA;&#x9;&#x9;internal MPICompletedStatus(MPI.CompletedStatus internal_status, Tuple&lt;int, int> source) : base(internal_status, source)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;this.internal_status = internal_status;&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;public static CompletedStatus createStatus(MPI.CompletedStatus internal_status, Tuple&lt;int, int> source)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;return new MPICompletedStatus(internal_status, source);&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;/// &lt;summary>&#xA;&#x9;&#x9;/// Determines the number of elements in the transmitted message.&#xA;&#x9;&#x9;/// &lt;/summary>&#xA;&#x9;&#x9;public int? Count&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;get { return internal_status.Count(); }&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;}&#xA;&#xA;&#x9;public interface IRequest&#xA;&#x9;{&#xA;&#x9;&#x9;void registerWaitingSet(AutoResetEvent waiting_set);&#xA;&#x9;&#x9;void unregisterWaitingSet(AutoResetEvent waiting_set);&#xA;&#x9;&#x9;CompletedStatus Wait();&#xA;&#x9;&#x9;CompletedStatus Test();&#xA;&#x9;&#x9;void Cancel();&#xA;&#x9;}&#xA;&#xA;&#x9;public class Request : IRequest // Without MPI&#xA;&#x9;{&#xA;&#x9;&#x9;private Tuple&lt;int, int> source;&#xA;&#x9;&#x9;int tag;&#xA;&#xA;&#x9;&#x9;private ManualResetEvent e;&#xA;&#x9;&#x9;private Thread waiting_request = null;&#xA;&#x9;&#x9;protected ManualResetEvent initial_signal = new ManualResetEvent(false);&#xA;&#x9;&#x9;private bool completed = false;&#xA;&#xA;&#x9;&#x9;bool completed_request = false;&#xA;&#xA;&#xA;&#x9;&#x9;internal Request(ManualResetEvent e, Tuple&lt;int, int> source, int tag)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;this.e = e;&#xA;&#x9;&#x9;&#x9;this.source = source;&#xA;&#x9;&#x9;&#x9;this.tag = tag;&#xA;&#x9;&#x9;&#x9;new Thread(new ThreadStart(delegate ()&#xA;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;e.WaitOne();&#xA;&#x9;&#x9;&#x9;&#x9;completed_request = true;&#xA;&#x9;&#x9;&#x9;})).Start();&#xA;&#xA;&#x9;&#x9;}&#xA;&#xA;&#xA;&#x9;&#x9;private object wait_lock = new object();&#xA;&#xA;&#x9;&#x9;private IList&lt;AutoResetEvent> waiting_sets = new List&lt;AutoResetEvent>();&#xA;&#xA;&#x9;&#x9;public void registerWaitingSet(AutoResetEvent waiting_set)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;waiting_request = new Thread(new ThreadStart(delegate&#xA;&#x9;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;while (true)&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;initial_signal.WaitOne();&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;e.WaitOne();&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;lock (wait_lock)&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;completed = true;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;foreach (AutoResetEvent ws in waiting_sets)&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;ws.Set();&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;}));&#xA;&#xA;&#x9;&#x9;&#x9;waiting_request.Start();&#xA;&#xA;&#x9;&#x9;&#x9;lock (wait_lock)&#xA;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;if (completed)&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;waiting_set.Set();&#xA;&#x9;&#x9;&#x9;&#x9;else&#xA;&#x9;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;waiting_sets.Add(waiting_set);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;initial_signal.Set();&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;public void unregisterWaitingSet(AutoResetEvent waiting_set)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;waiting_sets.Remove(waiting_set);&#xA;&#x9;&#x9;&#x9;initial_signal.Reset();&#xA;&#x9;&#x9;&#x9;waiting_request.Abort();&#xA;&#x9;&#x9;&#x9;waiting_request = null;&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;/// &lt;summary>&#xA;&#x9;&#x9;/// Wait until this non-blocking operation has completed.&#xA;&#x9;&#x9;/// &lt;/summary>&#xA;&#x9;&#x9;/// &lt;returns>&#xA;&#x9;&#x9;///   Information about the completed communication operation.&#xA;&#x9;&#x9;/// &lt;/returns>&#xA;&#x9;&#x9;public CompletedStatus Wait()&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;e.WaitOne();&#xA;&#x9;&#x9;&#x9;return SAFeCompletedStatus.createStatus(source, tag);&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;/// &lt;summary>&#xA;&#x9;&#x9;/// Determine whether this non-blocking operation has completed.&#xA;&#x9;&#x9;/// &lt;/summary>&#xA;&#x9;&#x9;/// &lt;returns>&#xA;&#x9;&#x9;/// If the non-blocking operation has completed, returns information&#xA;&#x9;&#x9;/// about the completed communication operation. Otherwise, returns&#xA;&#x9;&#x9;/// &lt;c>null&lt;/c> to indicate that the operation has not completed.&#xA;&#x9;&#x9;/// &lt;/returns>&#xA;&#x9;&#x9;public CompletedStatus Test()&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;return completed_request ? SAFeCompletedStatus.createStatus(source, tag) : null;&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;/// &lt;summary>&#xA;&#x9;&#x9;/// Cancel this communication request.&#xA;&#x9;&#x9;/// &lt;/summary>&#xA;&#x9;&#x9;public void Cancel()&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;// TODO: cancel functionality not implemented ...&#xA;&#x9;&#x9;&#x9;//internal_request.Cancel ();&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;public static IRequest createRequest(ManualResetEvent e, Tuple&lt;int, int> source, int tag)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;return new Request(e, source, tag);&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;// Convert an object to a byte array&#xA;&#x9;&#x9;protected static byte[] ObjectToByteArray(Object obj)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;if (obj == null)&#xA;&#x9;&#x9;&#x9;&#x9;return null;&#xA;&#x9;&#x9;&#x9;BinaryFormatter bf = new BinaryFormatter();&#xA;&#x9;&#x9;&#x9;MemoryStream ms = new MemoryStream();&#xA;&#x9;&#x9;&#x9;bf.Serialize(ms, obj);&#xA;&#x9;&#x9;&#x9;return ms.ToArray();&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;protected static Object ByteArrayToObject(byte[] arrBytes)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;MemoryStream memStream = new MemoryStream();&#xA;&#x9;&#x9;&#x9;BinaryFormatter binForm = new BinaryFormatter();&#xA;&#x9;&#x9;&#x9;memStream.Write(arrBytes, 0, arrBytes.Length);&#xA;&#x9;&#x9;&#x9;memStream.Seek(0, SeekOrigin.Begin);&#xA;&#x9;&#x9;&#x9;Object obj = (Object)binForm.Deserialize(memStream);&#xA;&#x9;&#x9;&#x9;return obj;&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;}&#xA;&#xA;&#xA;&#xA;&#xA;&#x9;/// &lt;summary>&#xA;&#x9;/// A non-blocking communication request.&#xA;&#x9;/// &lt;/summary>&#xA;&#x9;/// &lt;remarks>&#xA;&#x9;/// Each request object refers to a single&#xA;&#x9;/// communication operation, such as non-blocking send &#xA;&#x9;/// (see &lt;see cref=&quot;Communicator.ImmediateSend&amp;lt;T&amp;gt;(T, int, int)&quot;/>)&#xA;&#x9;/// or receive. Non-blocking operations may progress in the background, and can complete&#xA;&#x9;/// without any user intervention. However, it is crucial that outstanding communication&#xA;&#x9;/// requests be completed with a successful call to &lt;see cref=&quot;Wait&quot;/> or &lt;see cref=&quot;Test&quot;/>&#xA;&#x9;/// before the request object is lost.&#xA;&#x9;/// &lt;/remarks>&#xA;&#x9;public class MPIRequest : IRequest&#xA;&#x9;{&#xA;&#x9;&#x9;private MPI.Request internal_request;&#xA;&#x9;&#x9;private Tuple&lt;int, int> source;&#xA;&#xA;&#x9;&#x9;private Thread waiting_request = null;&#xA;&#x9;&#x9;protected ManualResetEvent initial_signal = new ManualResetEvent(false);&#xA;&#x9;&#x9;private bool completed = false;&#xA;&#xA;&#x9;&#x9;internal MPIRequest(MPI.Request internal_request, Tuple&lt;int, int> source)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;this.internal_request = internal_request;&#xA;&#x9;&#x9;&#x9;this.source = source;&#xA;&#x9;&#x9;}&#xA;&#xA;&#xA;&#x9;&#x9;private object wait_lock = new object();&#xA;&#xA;&#x9;&#x9;private IList&lt;AutoResetEvent> waiting_sets = new List&lt;AutoResetEvent>();&#xA;&#xA;&#x9;&#x9;public void registerWaitingSet(AutoResetEvent waiting_set)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;waiting_request = new Thread(new ThreadStart(delegate&#xA;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;while (true)&#xA;&#x9;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;initial_signal.WaitOne();&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;internal_request.Wait();&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;lock (wait_lock)&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;completed = true;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;foreach (AutoResetEvent ws in waiting_sets)&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;ws.Set();&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;}));&#xA;&#xA;&#x9;&#x9;&#x9;waiting_request.Start();&#xA;&#xA;&#x9;&#x9;&#x9;lock (wait_lock)&#xA;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;if (completed)&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;waiting_set.Set();&#xA;&#x9;&#x9;&#x9;&#x9;else&#xA;&#x9;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;waiting_sets.Add(waiting_set);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;initial_signal.Set();&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;public void unregisterWaitingSet(AutoResetEvent waiting_set)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;waiting_sets.Remove(waiting_set);&#xA;&#x9;&#x9;&#x9;initial_signal.Reset();&#xA;&#x9;&#x9;&#x9;waiting_request.Abort();&#xA;&#x9;&#x9;&#x9;waiting_request = null;&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;/// &lt;summary>&#xA;&#x9;&#x9;/// Wait until this non-blocking operation has completed.&#xA;&#x9;&#x9;/// &lt;/summary>&#xA;&#x9;&#x9;/// &lt;returns>&#xA;&#x9;&#x9;///   Information about the completed communication operation.&#xA;&#x9;&#x9;/// &lt;/returns>&#xA;&#x9;&#x9;public CompletedStatus Wait()&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;MPI.CompletedStatus internal_status = internal_request.Wait();&#xA;&#x9;&#x9;&#x9;return MPICompletedStatus.createStatus(internal_status, source);&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;/// &lt;summary>&#xA;&#x9;&#x9;/// Determine whether this non-blocking operation has completed.&#xA;&#x9;&#x9;/// &lt;/summary>&#xA;&#x9;&#x9;/// &lt;returns>&#xA;&#x9;&#x9;/// If the non-blocking operation has completed, returns information&#xA;&#x9;&#x9;/// about the completed communication operation. Otherwise, returns&#xA;&#x9;&#x9;/// &lt;c>null&lt;/c> to indicate that the operation has not completed.&#xA;&#x9;&#x9;/// &lt;/returns>&#xA;&#x9;&#x9;public CompletedStatus Test()&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;MPI.CompletedStatus internal_status = internal_request.Test();&#xA;&#x9;&#x9;&#x9;return internal_status != null ? MPICompletedStatus.createStatus(internal_status, source) : null;&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;/// &lt;summary>&#xA;&#x9;&#x9;/// Cancel this communication request.&#xA;&#x9;&#x9;/// &lt;/summary>&#xA;&#x9;&#x9;public void Cancel()&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;internal_request.Cancel();&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;public static IRequest createRequest(MPI.Request internal_status, Tuple&lt;int, int> source)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;return new MPIRequest(internal_status, source);&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;// Convert an object to a byte array&#xA;&#x9;&#x9;protected static byte[] ObjectToByteArray(Object obj)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;if (obj == null)&#xA;&#x9;&#x9;&#x9;&#x9;return null;&#xA;&#x9;&#x9;&#x9;BinaryFormatter bf = new BinaryFormatter();&#xA;&#x9;&#x9;&#x9;MemoryStream ms = new MemoryStream();&#xA;&#x9;&#x9;&#x9;bf.Serialize(ms, obj);&#xA;&#x9;&#x9;&#x9;return ms.ToArray();&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;protected static Object ByteArrayToObject(byte[] arrBytes)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;MemoryStream memStream = new MemoryStream();&#xA;&#x9;&#x9;&#x9;BinaryFormatter binForm = new BinaryFormatter();&#xA;&#x9;&#x9;&#x9;memStream.Write(arrBytes, 0, arrBytes.Length);&#xA;&#x9;&#x9;&#x9;memStream.Seek(0, SeekOrigin.Begin);&#xA;&#x9;&#x9;&#x9;Object obj = (Object)binForm.Deserialize(memStream);&#xA;&#x9;&#x9;&#x9;return obj;&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;}&#xA;&#xA;&#x9;public interface IReceiveRequest : IRequest&#xA;&#x9;{&#xA;&#x9;&#x9;object GetValue();&#xA;&#x9;}&#xA;&#xA;&#x9;public abstract class ReceiveRequest : Request, IReceiveRequest&#xA;&#x9;{&#xA;&#x9;&#x9;internal ReceiveRequest(ManualResetEvent e, Tuple&lt;int, int> source, int tag) : base(e, source, tag)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;/// &lt;summary>&#xA;&#x9;&#x9;/// Retrieve the value received via this communication. The value&#xA;&#x9;&#x9;/// will only be available when the communication has completed.&#xA;&#x9;&#x9;/// &lt;/summary>&#xA;&#x9;&#x9;/// &lt;returns>The value received by this communication.&lt;/returns>&#xA;&#x9;&#x9;public abstract object GetValue();&#xA;&#x9;}&#xA;&#x9;/// &lt;summary>&#xA;&#x9;/// A non-blocking receive request. &#xA;&#x9;/// &lt;/summary>&#xA;&#x9;/// &lt;remarks>&#xA;&#x9;/// This class allows one to test a receive&#xA;&#x9;/// request for completion, wait for completion of a request, cancel a request,&#xA;&#x9;/// or extract the value received by this communication request.&#xA;&#x9;/// &lt;/remarks>&#xA;&#x9;public abstract class MPIReceiveRequest : MPIRequest, IReceiveRequest&#xA;&#x9;{&#xA;&#xA;&#x9;&#x9;internal MPIReceiveRequest(MPI.ReceiveRequest internal_request, Tuple&lt;int, int> source) : base(internal_request, source)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;/// &lt;summary>&#xA;&#x9;&#x9;/// Retrieve the value received via this communication. The value&#xA;&#x9;&#x9;/// will only be available when the communication has completed.&#xA;&#x9;&#x9;/// &lt;/summary>&#xA;&#x9;&#x9;/// &lt;returns>The value received by this communication.&lt;/returns>&#xA;&#x9;&#x9;public abstract object GetValue();&#xA;&#x9;}&#xA;&#xA;&#x9;/// &lt;summary>&#xA;&#x9;/// A non-blocking receive request. &#xA;&#x9;/// &lt;/summary>&#xA;&#x9;/// &lt;remarks>&#xA;&#x9;/// This class allows one to test a receive&#xA;&#x9;/// request for completion, wait for completion of a request, cancel a request,&#xA;&#x9;/// or extract the value received by this communication request.&#xA;&#x9;/// &lt;/remarks>&#xA;&#x9;public class ValueReceiveRequest&lt;T> : ReceiveRequest&#xA;&#x9;{&#xA;&#x9;&#x9;Tuple&lt;int, int> source = null;&#xA;&#x9;&#x9;int? tag = null;&#xA;&#xA;&#x9;&#x9;internal ValueReceiveRequest(ManualResetEvent e, Tuple&lt;int, int> source, int tag) : base(e, source, tag)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;this.source = source;&#xA;&#x9;&#x9;&#x9;this.tag = tag;&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;private object value = null;&#xA;&#xA;&#x9;&#x9;/// &lt;summary>&#xA;&#x9;&#x9;/// Retrieve the value received via this communication. The value&#xA;&#x9;&#x9;/// will only be available when the communication has completed.&#xA;&#x9;&#x9;/// &lt;/summary>&#xA;&#x9;&#x9;/// &lt;returns>The value received by this communication.&lt;/returns>&#xA;&#x9;&#x9;public override object GetValue()&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;return value;&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;public void SetValue(byte[] v)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;value = (T)ByteArrayToObject(v);&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;public static new ValueReceiveRequest&lt;T> createRequest(ManualResetEvent e, Tuple&lt;int, int> source, int tag)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;return new ValueReceiveRequest&lt;T>(e, source, tag);&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;public new CompletedStatus Wait()&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;SAFeCompletedStatus status = (SAFeCompletedStatus)base.Wait();&#xA;&#x9;&#x9;&#x9;status.Count = 1;&#xA;&#x9;&#x9;&#x9;return status;&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;public new CompletedStatus Test()&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;SAFeCompletedStatus status = (SAFeCompletedStatus)base.Test();&#xA;&#xA;&#x9;&#x9;&#x9;if (status != null)&#xA;&#x9;&#x9;&#x9;&#x9;status.Count = 1;&#xA;&#xA;&#x9;&#x9;&#x9;return status;&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#xA;&#xA;&#x9;/// &lt;summary>&#xA;&#x9;/// A non-blocking receive request. &#xA;&#x9;/// &lt;/summary>&#xA;&#x9;/// &lt;remarks>&#xA;&#x9;/// This class allows one to test a receive&#xA;&#x9;/// request for completion, wait for completion of a request, cancel a request,&#xA;&#x9;/// or extract the value received by this communication request.&#xA;&#x9;/// &lt;/remarks>&#xA;&#x9;public class MPIValueReceiveRequest&lt;T> : MPIReceiveRequest&#xA;&#x9;{&#xA;&#x9;&#x9;private MPI.ReceiveRequest internal_request;&#xA;&#xA;&#x9;&#x9;internal MPIValueReceiveRequest(MPI.ReceiveRequest internal_request, Tuple&lt;int, int> source) : base(internal_request, source)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;this.internal_request = internal_request;&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;/// &lt;summary>&#xA;&#x9;&#x9;/// Retrieve the value received via this communication. The value&#xA;&#x9;&#x9;/// will only be available when the communication has completed.&#xA;&#x9;&#x9;/// &lt;/summary>&#xA;&#x9;&#x9;/// &lt;returns>The value received by this communication.&lt;/returns>&#xA;&#x9;&#x9;public override object GetValue()&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;byte[] v = (byte[])this.internal_request.GetValue();&#xA;&#x9;&#x9;&#x9;return (T)ByteArrayToObject(v);&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;public static MPIValueReceiveRequest&lt;T> createRequest(MPI.ReceiveRequest internal_status, Tuple&lt;int, int> source)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;return new MPIValueReceiveRequest&lt;T>(internal_status, source);&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;}&#xA;&#xA;&#x9;/// &lt;summary>&#xA;&#x9;/// A non-blocking receive request. &#xA;&#x9;/// &lt;/summary>&#xA;&#x9;/// &lt;remarks>&#xA;&#x9;/// This class allows one to test a receive&#xA;&#x9;/// request for completion, wait for completion of a request, cancel a request,&#xA;&#x9;/// or extract the value received by this communication request.&#xA;&#x9;/// &lt;/remarks>&#xA;&#x9;public class ArrayReceiveRequest&lt;T> : ReceiveRequest&#xA;&#x9;{&#xA;&#x9;&#x9;private T[] values = null;&#xA;&#x9;&#x9;private byte[] v = null;&#xA;&#x9;&#x9;Tuple&lt;int, int> source = null;&#xA;&#x9;&#x9;int? tag = null;&#xA;&#xA;&#x9;&#x9;internal ArrayReceiveRequest(ManualResetEvent e, Tuple&lt;int, int> source, int tag, T[] values) : base(e, source, tag)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;this.values = values;&#xA;&#x9;&#x9;&#x9;this.source = source;&#xA;&#x9;&#x9;&#x9;this.tag = null;&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;/// &lt;summary>&#xA;&#x9;&#x9;/// Retrieve the value received via this communication. The value&#xA;&#x9;&#x9;/// will only be available when the communication has completed.&#xA;&#x9;&#x9;/// &lt;/summary>&#xA;&#x9;&#x9;/// &lt;returns>The value received by this communication.&lt;/returns>&#xA;&#x9;&#x9;public override object GetValue()&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;if (v == null)&#xA;&#x9;&#x9;&#x9;&#x9;return null;&#xA;&#xA;&#x9;&#x9;&#x9;T[] values_ = (T[])ByteArrayToObject(v);&#xA;&#xA;&#x9;&#x9;&#x9;// Copy the received values to the destination array (forcing original MPI semantics)&#xA;&#x9;&#x9;&#x9;int size = values.Length &lt;= values_.Length ? values.Length : values_.Length;&#xA;&#x9;&#x9;&#x9;for (int i = 0; i &lt; size; i++)&#xA;&#x9;&#x9;&#x9;&#x9;values[i] = values_[i];&#xA;&#xA;&#x9;&#x9;&#x9;return values;&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;public void SetValue(byte[] v)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;values = (T[])ByteArrayToObject(v);&#xA;&#x9;&#x9;}&#xA;&#xA;&#xA;&#x9;&#x9;public static ArrayReceiveRequest&lt;T> createRequest(ManualResetEvent e, Tuple&lt;int, int> source, int tag, T[] values)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;return new ArrayReceiveRequest&lt;T>(e, source, tag, values);&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;public new CompletedStatus Wait()&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;SAFeCompletedStatus status = (SAFeCompletedStatus)base.Wait();&#xA;&#x9;&#x9;&#x9;status.Count = values.Length;&#xA;&#x9;&#x9;&#x9;return status;&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;public new CompletedStatus Test()&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;SAFeCompletedStatus status = (SAFeCompletedStatus)base.Test();&#xA;&#xA;&#x9;&#x9;&#x9;if (status != null)&#xA;&#x9;&#x9;&#x9;&#x9;status.Count = values.Length;&#xA;&#xA;&#x9;&#x9;&#x9;return status;&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;}&#xA;&#xA;&#xA;&#x9;/// &lt;summary>&#xA;&#x9;/// A non-blocking receive request. &#xA;&#x9;/// &lt;/summary>&#xA;&#x9;/// &lt;remarks>&#xA;&#x9;/// This class allows one to test a receive&#xA;&#x9;/// request for completion, wait for completion of a request, cancel a request,&#xA;&#x9;/// or extract the value received by this communication request.&#xA;&#x9;/// &lt;/remarks>&#xA;&#x9;public class MPIArrayReceiveRequest&lt;T> : MPIReceiveRequest&#xA;&#x9;{&#xA;&#x9;&#x9;private MPI.ReceiveRequest internal_request;&#xA;&#x9;&#x9;private T[] values = null;&#xA;&#xA;&#x9;&#x9;internal MPIArrayReceiveRequest(MPI.ReceiveRequest internal_request, Tuple&lt;int, int> source, T[] values) : base(internal_request, source)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;this.internal_request = internal_request;&#xA;&#x9;&#x9;&#x9;this.values = values;&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;/// &lt;summary>&#xA;&#x9;&#x9;/// Retrieve the value received via this communication. The value&#xA;&#x9;&#x9;/// will only be available when the communication has completed.&#xA;&#x9;&#x9;/// &lt;/summary>&#xA;&#x9;&#x9;/// &lt;returns>The value received by this communication.&lt;/returns>&#xA;&#x9;&#x9;public override object GetValue()&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;byte[] v = (byte[])this.internal_request.GetValue();&#xA;&#x9;&#x9;&#x9;T[] values_ = (T[])ByteArrayToObject(v);&#xA;&#xA;&#x9;&#x9;&#x9;// Copy the received values to the destination array (forcing original MPI semantics)&#xA;&#x9;&#x9;&#x9;int size = values.Length &lt;= values_.Length ? values.Length : values_.Length;&#xA;&#x9;&#x9;&#x9;for (int i = 0; i &lt; size; i++)&#xA;&#x9;&#x9;&#x9;&#x9;values[i] = values_[i];&#xA;&#xA;&#x9;&#x9;&#x9;return values;&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;public static MPIArrayReceiveRequest&lt;T> createRequest(MPI.ReceiveRequest internal_status, Tuple&lt;int, int> source, T[] values)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;return new MPIArrayReceiveRequest&lt;T>(internal_status, source, values);&#xA;&#x9;&#x9;}&#xA;&#xA;&#xA;&#x9;}&#xA;&#xA;&#xA;&#x9;/// &lt;summary>&#xA;&#x9;/// A request list contains a list of outstanding MPI requests. &#xA;&#x9;/// &lt;/summary>&#xA;&#x9;/// &#xA;&#x9;/// &lt;remarks>&#xA;&#x9;/// The requests in a &lt;c>RequestList&lt;/c>&#xA;&#x9;/// are typically non-blocking send or receive operations (e.g.,&#xA;&#x9;/// &lt;see cref=&quot;Communicator.ImmediateSend&amp;lt;T&amp;gt;(T, int, int)&quot;/>,&#xA;&#x9;/// &lt;see cref=&quot;Communicator.ImmediateReceive&amp;lt;T&amp;gt;(int, int)&quot;/>). The&#xA;&#x9;/// request list provides the ability to operate on the set of MPI requests&#xA;&#x9;/// as a whole, for example by waiting until all requests complete before&#xA;&#x9;/// returning or testing whether any of the requests have completed.&#xA;&#x9;/// &lt;/remarks>&#xA;&#x9;public class RequestList&#xA;&#x9;{&#xA;&#x9;&#x9;/// &lt;summary>&#xA;&#x9;&#x9;/// Create a new, empty request list.&#xA;&#x9;&#x9;/// &lt;/summary>&#xA;&#x9;&#x9;public RequestList()&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;this.requests = new List&lt;IRequest>();&#xA;&#x9;&#x9;}&#xA;&#xA;&#xA;&#xA;&#x9;&#x9;/// &lt;summary>&#xA;&#x9;&#x9;/// Add a new request to the request list.&#xA;&#x9;&#x9;/// &lt;/summary>&#xA;&#x9;&#x9;/// &lt;param name=&quot;request&quot;>The request to add.&lt;/param>&#xA;&#x9;&#x9;public void Add(IRequest request)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;requests.Add(request);&#xA;&#xA;&#x9;&#x9;&#x9;if (sync_request != null)&#xA;&#x9;&#x9;&#x9;&#x9;request.registerWaitingSet(sync_request);&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;/// &lt;summary>&#xA;&#x9;&#x9;/// Remove a request from the request list.&#xA;&#x9;&#x9;/// &lt;/summary>&#xA;&#x9;&#x9;/// &lt;param name=&quot;request&quot;>Request to remove.&lt;/param>&#xA;&#x9;&#x9;public void Remove(IRequest request)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;requests.Remove(request);&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;/// &lt;summary>&#xA;&#x9;&#x9;/// Retrieves the number of elements in this list of requests.&#xA;&#x9;&#x9;/// &lt;/summary>&#xA;&#x9;&#x9;public int Count&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;get&#xA;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;return this.requests.Count;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;AutoResetEvent sync_request = null;&#xA;&#xA;&#x9;&#x9;/// &lt;summary>&#xA;&#x9;&#x9;/// Waits until any request has completed. That request will then be removed &#xA;&#x9;&#x9;/// from the request list and returned.&#xA;&#x9;&#x9;/// &lt;/summary>&#xA;&#x9;&#x9;/// &lt;returns>The completed request, which has been removed from the request list.&lt;/returns>&#xA;&#x9;&#x9;public IRequest WaitAny()&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;if (requests.Count == 0)&#xA;&#x9;&#x9;&#x9;&#x9;throw new ArgumentException(&quot;Cannot call MPI.RequestList.WaitAny with an empty request list&quot;);&#xA;&#xA;&#x9;&#x9;&#x9;sync_request = new AutoResetEvent(false);&#xA;&#xA;&#x9;&#x9;&#x9;foreach (IRequest req_item in requests)&#xA;&#x9;&#x9;&#x9;&#x9;req_item.registerWaitingSet(sync_request);&#xA;&#xA;&#x9;&#x9;&#x9;sync_request.WaitOne();&#xA;&#x9;&#x9;&#x9;sync_request = null;&#xA;&#xA;&#x9;&#x9;&#x9;IRequest req = this.TestAny();&#xA;&#xA;&#x9;&#x9;&#x9;foreach (IRequest req_item in requests)&#xA;&#x9;&#x9;&#x9;&#x9;req_item.unregisterWaitingSet(sync_request);&#xA;&#xA;&#x9;&#x9;&#x9;return req;&#xA;&#xA;&#xA;&#x9;&#x9;&#x9;/*          while (true)&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;Thread.Sleep (200);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;Request req = TestAny();&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (req != null)&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;return req;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}*/&#xA;&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;/// &lt;summary>&#xA;&#x9;&#x9;/// Determines whether any request has completed. If so, that request will be removed&#xA;&#x9;&#x9;/// from the request list and returned. &#xA;&#x9;&#x9;/// &lt;/summary>&#xA;&#x9;&#x9;/// &lt;returns>&#xA;&#x9;&#x9;///   The first request that has completed, if any. Otherwise, returns &lt;c>null&lt;/c> to&#xA;&#x9;&#x9;///   indicate that no request has completed.&#xA;&#x9;&#x9;/// &lt;/returns>&#xA;&#x9;&#x9;public IRequest TestAny()&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;int n = requests.Count;&#xA;&#x9;&#x9;&#x9;for (int i = 0; i &lt; n; ++i)&#xA;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;IRequest req = requests[i];&#xA;&#x9;&#x9;&#x9;&#x9;if (req.Test() != null)&#xA;&#x9;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;requests.RemoveAt(i);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;return req;&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;&#x9;return null;&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;/// &lt;summary>&#xA;&#x9;&#x9;/// Wait until all of the requests has completed before returning.&#xA;&#x9;&#x9;/// &lt;/summary>&#xA;&#x9;&#x9;/// &lt;returns>A list containing all of the completed requests.&lt;/returns>&#xA;&#x9;&#x9;public List&lt;IRequest> WaitAll()&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;List&lt;IRequest> result = new List&lt;IRequest>();&#xA;&#x9;&#x9;&#x9;foreach (IRequest req in requests)&#xA;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;req.Wait();&#xA;&#x9;&#x9;&#x9;&#x9;result.Add(req);&#xA;&#x9;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;&#x9;/*&#xA;            List&lt;Request> result = new List&lt;Request>();&#xA;            while (requests.Count > 0)&#xA;            {&#xA;                Request req = WaitAny();&#xA;                result.Add(req);&#xA;            }*/&#xA;&#xA;&#x9;&#x9;&#x9;return result;&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;/// &lt;summary>&#xA;&#x9;&#x9;/// Test whether all of the requests have completed. If all of the&#xA;&#x9;&#x9;/// requests have completed, the result is the list of requests. &#xA;&#x9;&#x9;/// Otherwise, the result is &lt;c>null&lt;/c>.&#xA;&#x9;&#x9;/// &lt;/summary>&#xA;&#x9;&#x9;/// &lt;returns>Either the list of all completed requests, or null.&lt;/returns>&#xA;&#x9;&#x9;public List&lt;IRequest> TestAll()&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;int n = requests.Count;&#xA;&#x9;&#x9;&#x9;for (int i = 0; i &lt; n; ++i)&#xA;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;if (requests[i].Test() == null)&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;return null;&#xA;&#x9;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;&#x9;List&lt;IRequest> result = requests;&#xA;&#x9;&#x9;&#x9;requests = new List&lt;IRequest>();&#xA;&#x9;&#x9;&#x9;return result;&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;/// &lt;summary>&#xA;&#x9;&#x9;/// Wait for at least one request to complete, then return a list of&#xA;&#x9;&#x9;/// all of the requests that have completed at this point.&#xA;&#x9;&#x9;/// &lt;/summary>&#xA;&#x9;&#x9;/// &lt;returns>&#xA;&#x9;&#x9;///   A list of all of the requests that have completed, which&#xA;&#x9;&#x9;///   will contain at least one element.&#xA;&#x9;&#x9;/// &lt;/returns>&#xA;&#x9;&#x9;public List&lt;IRequest> WaitSome()&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;if (requests.Count == 0)&#xA;&#x9;&#x9;&#x9;&#x9;throw new ArgumentException(&quot;Cannot call MPI.RequestList.WaitAny with an empty request list&quot;);&#xA;&#xA;&#x9;&#x9;&#x9;List&lt;IRequest> result = new List&lt;IRequest>();&#xA;&#x9;&#x9;&#x9;while (result.Count == 0)&#xA;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;int n = requests.Count;&#xA;&#x9;&#x9;&#x9;&#x9;for (int i = 0; i &lt; n; ++i)&#xA;&#x9;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;IRequest req = requests[i];&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if (req.Test() != null)&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;requests.RemoveAt(i);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;--i;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;--n;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;result.Add(req);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;return result;&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;/// &lt;summary>&#xA;&#x9;&#x9;/// Return a list of all requests that have completed.&#xA;&#x9;&#x9;/// &lt;/summary>&#xA;&#x9;&#x9;/// &lt;returns>&#xA;&#x9;&#x9;///   A list of all of the requests that have completed. If&#xA;&#x9;&#x9;///   no requests have completed, returns &lt;c>null&lt;/c>.&#xA;&#x9;&#x9;/// &lt;/returns>&#xA;&#x9;&#x9;public List&lt;IRequest> TestSome()&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;List&lt;IRequest> result = null;&#xA;&#x9;&#x9;&#x9;int n = requests.Count;&#xA;&#x9;&#x9;&#x9;for (int i = 0; i &lt; n; ++i)&#xA;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;IRequest req = requests[i];&#xA;&#x9;&#x9;&#x9;&#x9;if (req.Test() != null)&#xA;&#x9;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;requests.RemoveAt(i);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;--i;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;--n;&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if (result == null)&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;result = new List&lt;IRequest>();&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;result.Add(req);&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;return result;&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;/// &lt;summary>&#xA;&#x9;&#x9;/// The actual list of requests.&#xA;&#x9;&#x9;/// &lt;/summary>&#xA;&#x9;&#x9;protected List&lt;IRequest> requests;&#xA;&#x9;}&#xA;&#xA;&#xA;&#xA;}&#xA;&#xA;" name="Aliencommunicator.cs" uri="br.ufc.mdcc.hpc.storm.binding.channel.Binding/bin/1.0.0.0/Aliencommunicator.dll" versionId="1.0.0.0">
          <externalDependency>MPI</externalDependency>
        </file>
      </sources>
      <visualDescription h="40" w="172" x="183" y="58">
        <color b="0" g="165" r="255"/>
      </visualDescription>
    </interface>
    <interface iRef="IChannel" nArgs="0">
      <sources sourceType="C# Language" versionId="1.0.0.0">
        <file contents="/* AUTOMATICALLY GENERATE CODE */&#xA;&#xA;using br.ufc.pargo.hpe.kinds;&#xA;using br.ufc.mdcc.hpc.storm.kind.Binding;&#xA;&#xA;namespace br.ufc.mdcc.hpc.storm.binding.channel.Binding&#xA;{&#xA;&#x9;public interface BaseIChannel : BaseIPeer, IBindingKind &#xA;&#x9;{&#xA;&#x9;}&#xA;}" name="BaseIChannel.cs" srcType="base" uri="br.ufc.mdcc.hpc.storm.binding.channel.Binding/bin/1.0.0.0/BaseIChannel.dll" versionId="1.0.0.0">
          <dependency>br.ufc.mdcc.hpc.storm.kind.Binding/bin/1.0.0.0/BaseIPeer.dll</dependency>
          <externalDependency>MPI</externalDependency>
        </file>
        <file contents="using br.ufc.pargo.hpe.kinds;&#xA;using br.ufc.mdcc.hpc.storm.kind.Binding;&#xA;using System;&#xA;using MPI;&#xA;&#xA;namespace br.ufc.mdcc.hpc.storm.binding.channel.Binding&#xA;{&#xA;&#xA;&#x9;public interface IChannel : BaseIChannel, IPeer, Aliencommunicator&#xA;&#x9;{&#xA;&#xA;&#xA;&#x9;}&#xA;&#xA;}" name="IChannel.cs" srcType="user" uri="br.ufc.mdcc.hpc.storm.binding.channel.Binding/bin/1.0.0.0/IChannel.dll" versionId="1.0.0.0">
          <dependency>%WORKSPACE/br.ufc.mdcc.hpc.storm.binding.channel.Binding/bin/1.0.0.0/BaseIChannel.dll</dependency>
          <dependency>br.ufc.mdcc.hpc.storm.kind.Binding/bin/1.0.0.0/IPeer.dll</dependency>
          <externalDependency>MPI</externalDependency>
        </file>
        <file contents="using System;&#xA;using MPI;&#xA;using System.Runtime.Serialization.Formatters.Binary;&#xA;using System.IO;&#xA;using System.Collections.Generic;&#xA;using System.Threading;&#xA;&#xA;namespace br.ufc.mdcc.hpc.storm.binding.channel.Binding&#xA;{&#xA;&#x9;/*&#xA;    public enum AliencommunicatorOperation {&#xA;        SEND, &#xA;        RECEIVE, &#xA;        SEND_ARRAY,&#xA;        RECEIVE_ARRAY,&#xA;        PROBE,&#xA;        ALL_GATHER,&#xA;        ALL_GATHER_FLATTENED,&#xA;        ALL_REDUCE,&#xA;        ALL_REDUCE_ARRAY,&#xA;        ALL_TO_ALL,&#xA;        ALL_TO_ALL_FLATTENED,&#xA;        REDUCE_SCATTER,&#xA;        BROADCAST,&#xA;        BROADCAST_ARRAY,&#xA;        SCATTER,&#xA;        SCATTER_FROM_FLATTENED,&#xA;        GATHER,&#xA;        GATHER_FLATTENED,&#xA;        REDUCE,&#xA;        REDUCE_ARRAY&#xA;    };&#xA;    */&#xA;&#xA;&#x9;public class AliencommunicatorOperation&#xA;&#x9;{&#xA;&#x9;&#x9;public const int SEND = 0;&#xA;&#x9;&#x9;public const int RECEIVE = 1;&#xA;&#x9;&#x9;public const int SEND_ARRAY = 2;&#xA;&#x9;&#x9;public const int RECEIVE_ARRAY = 3;&#xA;&#x9;&#x9;public const int PROBE = 4;&#xA;&#x9;&#x9;public const int ALL_GATHER = 5;&#xA;&#x9;&#x9;public const int ALL_GATHER_FLATTENED = 6;&#xA;&#x9;&#x9;public const int ALL_REDUCE = 7;&#xA;&#x9;&#x9;public const int ALL_REDUCE_ARRAY = 8;&#xA;&#x9;&#x9;public const int ALL_TO_ALL = 9;&#xA;&#x9;&#x9;public const int ALL_TO_ALL_FLATTENED = 10;&#xA;&#x9;&#x9;public const int REDUCE_SCATTER = 11;&#xA;&#x9;&#x9;public const int BROADCAST = 12;&#xA;&#x9;&#x9;public const int BROADCAST_ARRAY = 13;&#xA;&#x9;&#x9;public const int SCATTER = 14;&#xA;&#x9;&#x9;public const int SCATTER_FROM_FLATTENED = 15;&#xA;&#x9;&#x9;public const int GATHER = 16;&#xA;&#x9;&#x9;public const int GATHER_FLATTENED = 17;&#xA;&#x9;&#x9;public const int REDUCE = 18;&#xA;&#x9;&#x9;public const int REDUCE_ARRAY = 19;&#xA;&#x9;&#x9;public const int SYNC_SEND = 20;&#xA;&#x9;};&#xA;&#xA;&#x9;public interface Aliencommunicator&#xA;&#x9;{&#xA;&#x9;&#x9;#region point-to-point operations&#xA;&#xA;&#x9;&#x9;// Value versions ...&#xA;&#xA;&#x9;&#x9;void Send&lt;T>(T value, Tuple&lt;int, int> dest, int tag);&#xA;&#xA;&#x9;&#x9;//      void SendReceive&lt;T> (T inValue, int dest, int tag, out T outValue); /* ok */&#xA;&#x9;&#x9;//      void SendReceive&lt;T> (T inValue, int dest, int sendTag, int source, int recvTag, out T outValue); /* ok */&#xA;&#x9;&#x9;//      void SendReceive&lt;T> (T inValue, int dest, int sendTag, int source, int recvTag, out T outValue, out CompletedStatus status);&#xA;&#xA;&#x9;&#x9;T Receive&lt;T>(Tuple&lt;int, int> source, int tag); /* ok */&#xA;&#x9;&#x9;void Receive&lt;T>(Tuple&lt;int, int> source, int tag, out T value); /* ok */&#xA;&#x9;&#x9;void Receive&lt;T>(Tuple&lt;int, int> source, int tag, out T value, out CompletedStatus status);&#xA;&#xA;&#x9;&#x9;IRequest ImmediateSend&lt;T>(T value, Tuple&lt;int, int> dest, int tag);&#xA;&#x9;&#x9;IReceiveRequest ImmediateReceive&lt;T>(Tuple&lt;int, int> source, int tag);&#xA;&#xA;&#x9;&#x9;// Array versions ... &#xA;&#x9;&#x9;void Send&lt;T>(T[] values, Tuple&lt;int, int> dest, int tag);&#xA;&#xA;&#x9;&#x9;void Receive&lt;T>(Tuple&lt;int, int> source, int tag, ref T[] values); /* ok */&#xA;&#x9;&#x9;void Receive&lt;T>(Tuple&lt;int, int> source, int tag, ref T[] values, out CompletedStatus status);&#xA;&#xA;&#x9;&#x9;IRequest ImmediateSend&lt;T>(T[] values, Tuple&lt;int, int> dest, int tag);&#xA;&#x9;&#x9;IReceiveRequest ImmediateReceive&lt;T>(Tuple&lt;int, int> source, int tag, T[] values);&#xA;&#xA;&#x9;&#x9;// Probe.&#xA;&#xA;&#x9;&#x9;//TODO      Status Probe (Tuple&lt;int,int> source, int tag);&#xA;&#x9;&#x9;//TODO      Status ImmediateProbe (Tuple&lt;int,int> source, int tag);&#xA;&#xA;&#x9;&#x9;//      void SendReceive&lt;T>(T[] inValues, int dest, int tag, ref T[] outValues); /* ok */&#xA;&#x9;&#x9;//      void SendReceive&lt;T>(T[] inValues, int dest, int sendTag, int source, int recvTag, ref T[] outValues); /* ok */&#xA;&#x9;&#x9;//      void SendReceive&lt;T> (T[] inValues, int dest, int sendTag, int source, int recvTag, ref T[] outValues, out CompletedStatus status);&#xA;&#xA;&#x9;&#x9;#endregion point-to-point operations&#xA;&#xA;&#x9;&#x9;#region collective operations&#xA;&#xA;&#x9;&#x9;#region AllToAll&#xA;&#xA;&#x9;&#x9;//TODO      T[] Allgather&lt;T> (int facet, T value);&#xA;&#x9;&#x9;//TODO      void Allgather&lt;T> (int facet, T inValue, ref T[] outValues);&#xA;&#xA;&#x9;&#x9;//TODO      void AllgatherFlattened&lt;T> (int facet, T[] inValues, int count, ref T[] outValues);&#xA;&#x9;&#x9;//TODO      void AllgatherFlattened&lt;T> (int facet, T[] inValues, int[] counts, ref T[] outValues);&#xA;&#xA;&#x9;&#x9;//TODO      T Allreduce&lt;T>(int facet, T value, ReductionOperation&lt;T> op);&#xA;&#x9;&#x9;//TODO      T[] Allreduce&lt;T> (int facet, T[] values, ReductionOperation&lt;T> op);&#xA;&#x9;&#x9;//TODO      void Allreduce&lt;T> (int facet, T[] inValues, ReductionOperation&lt;T> op, ref T[] outValues);&#xA;&#xA;&#x9;&#x9;//TODO      T[] Alltoall&lt;T> (int facet, T[] values);&#xA;&#x9;&#x9;//TODO      void Alltoall&lt;T> (int facet, T[] inValues, ref T[] outValues);&#xA;&#xA;&#x9;&#x9;//TODO void AlltoallFlattened&lt;T> (int facet, T[] inValues, int[] sendCounts, int[] recvCounts, ref T[] outValues);&#xA;&#xA;&#x9;&#x9;//TODO      T[] ReduceScatter&lt;T> (int facet, T[] values, ReductionOperation&lt;T> op, int[] counts);&#xA;&#x9;&#x9;//TODO      void ReduceScatter&lt;T> (int facet, T[] inValues, ReductionOperation&lt;T> op, int[] counts, ref T[] outValues);&#xA;&#xA;&#x9;&#x9;#endregion AllToAll&#xA;&#xA;&#xA;&#x9;&#x9;#region OneToAll&#xA;&#xA;&#x9;&#x9;//TODO      void Broadcast&lt;T> (int facet, ref T value, int root);&#xA;&#x9;&#x9;//TODO      void Broadcast&lt;T> (int facet, ref T[] values, int root);&#xA;&#xA;&#x9;&#x9;//TODO      void Scatter&lt;T> (int facet, T[] values);&#xA;&#x9;&#x9;//TODO      T Scatter&lt;T>(int facet, int root);&#xA;&#x9;&#x9;//TODO      void Scatter&lt;T>(int facet);&#xA;&#xA;&#x9;&#x9;//TODO      void ScatterFromFlattened&lt;T> (int facet, T[] inValues, int count);&#xA;&#x9;&#x9;//TODO      void ScatterFromFlattened&lt;T> (int facet, T[] inValues, int[] counts);&#xA;&#x9;&#x9;//TODO      void ScatterFromFlattened&lt;T> (int facet, int count, int root, ref T[] outValues);&#xA;&#x9;&#x9;//TODO      void ScatterFromFlattened&lt;T> (int facet, int[] counts, int root, ref T[] outValues);&#xA;&#x9;&#x9;//TODO      void ScatterFromFlattened&lt;T> (int facet);&#xA;&#x9;&#x9;//TODO      void ScatterFromFlattened&lt;T> (int facet, T[] inValues, int count, int root, ref T[] outValues);&#xA;&#x9;&#x9;//TODO      void ScatterFromFlattened&lt;T> (int facet, T[] inValues, int[] counts, int root, ref T[] outValues);&#xA;&#xA;&#x9;&#x9;#endregion OneToAll&#xA;&#xA;&#xA;&#x9;&#x9;#region AllToOne&#xA;&#xA;&#x9;&#x9;//TODO      T[] Gather&lt;T> (int facet, T value, int root);&#xA;&#x9;&#x9;//TODO      T[] Gather&lt;T> (int facet, int root);&#xA;&#x9;&#x9;//TODO      void Gather&lt;T>(int facet);&#xA;&#x9;&#x9;//TODO      void Gather&lt;T>(int facet, T inValue, int root, ref T[] outValues);&#xA;&#xA;&#x9;&#x9;//TODO      void GatherFlattened&lt;T>(int facet, int count, ref T[] outValues);&#xA;&#x9;&#x9;//TODO      T[] GatherFlattened&lt;T>(int facet, int count);&#xA;&#x9;&#x9;//TODO      void GatherFlattened&lt;T> (int facet, T[] inValues, int root);&#xA;&#x9;&#x9;//TODO      void GatherFlattened&lt;T>(int facet);&#xA;&#x9;&#x9;//TODO      void GatherFlattened&lt;T> (int facet, int[] counts, ref T[] outValues);&#xA;&#x9;&#x9;//TODO      T[] GatherFlattened&lt;T>(int facet, int[] counts);&#xA;&#xA;&#x9;&#x9;//TODO      T Reduce&lt;T> (int facet, T value, ReductionOperation&lt;T> op, int root);&#xA;&#x9;&#x9;//TODO      T[] Reduce&lt;T>(int facet, T[] values, ReductionOperation&lt;T> op, int root);&#xA;&#x9;&#x9;//TODO      void Reduce&lt;T>(int facet, T[] inValues, ReductionOperation&lt;T> op, int root, ref T[] outValues);&#xA;&#xA;&#x9;&#x9;#endregion AllToOne&#xA;&#xA;&#xA;&#x9;&#x9;#endregion collective operations&#xA;&#xA;&#x9;}&#xA;&#xA;&#xA;&#x9;public interface Status&#xA;&#x9;{&#xA;&#x9;&#x9;Tuple&lt;int, int> Source { get; }&#xA;&#x9;&#x9;int Tag { get; }&#xA;&#x9;&#x9;int? Count(Type type);&#xA;&#x9;&#x9;bool Cancelled { get; }&#xA;&#x9;}&#xA;&#xA;&#x9;public interface CompletedStatus : Status&#xA;&#x9;{&#xA;&#x9;&#x9;int? Count { get; }&#xA;&#x9;}&#xA;&#xA;&#x9;public class SAFeStatus : Status&#xA;&#x9;{&#xA;&#xA;&#x9;&#x9;/// &lt;summary>&#xA;&#x9;&#x9;///   Constructs a &lt;code>Status&lt;/code> object from a low-level &lt;see cref=&quot;Unsafe.MPI_Status&quot;/> structure.&#xA;&#x9;&#x9;/// &lt;/summary>&#xA;&#x9;&#x9;internal SAFeStatus(Tuple&lt;int, int> source, int tag)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;this.source = source;&#xA;&#x9;&#x9;&#x9;this.tag = tag;&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;Tuple&lt;int, int> source;&#xA;&#xA;&#x9;&#x9;/// &lt;summary>&#xA;&#x9;&#x9;/// The rank of the process that sent the message.&#xA;&#x9;&#x9;/// &lt;/summary>&#xA;&#x9;&#x9;public Tuple&lt;int, int> Source&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;get&#xA;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;return source;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;int tag;&#xA;&#xA;&#x9;&#x9;/// &lt;summary>&#xA;&#x9;&#x9;/// The tag used to send the message.&#xA;&#x9;&#x9;/// &lt;/summary>&#xA;&#x9;&#x9;public int Tag&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;get&#xA;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;return tag;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;/// &lt;summary>&#xA;&#x9;&#x9;/// Determine the number of elements transmitted by the communication&#xA;&#x9;&#x9;/// operation associated with this object.&#xA;&#x9;&#x9;/// &lt;/summary>&#xA;&#x9;&#x9;/// &lt;param name=&quot;type&quot;>&#xA;&#x9;&#x9;///   The type of data that will be stored in the message.&#xA;&#x9;&#x9;/// &lt;/param>&#xA;&#x9;&#x9;/// &lt;returns>&#xA;&#x9;&#x9;///   If the type of the data is a value type, returns the number&#xA;&#x9;&#x9;///   of elements in the message. Otherwise, returns &lt;c>null&lt;/c>,&#xA;&#x9;&#x9;///   because the number of elements stored in the message won't&#xA;&#x9;&#x9;///   be known until the message is received.&#xA;&#x9;&#x9;/// &lt;/returns>&#xA;&#x9;&#x9;public int? Count(Type type)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;// TODO:&#xA;&#x9;&#x9;&#x9;return null;&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;/// &lt;summary>&#xA;&#x9;&#x9;/// Whether the communication was cancelled before it completed.&#xA;&#x9;&#x9;/// &lt;/summary>&#xA;&#x9;&#x9;public bool Cancelled&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;get&#xA;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;// TODO: cancel functionality not implemented ...&#xA;&#x9;&#x9;&#x9;&#x9;return false;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#xA;&#x9;/// &lt;summary>&#xA;&#x9;/// Information about a specific message that has already been&#xA;&#x9;/// transferred via MPI.&#xA;&#x9;/// &lt;/summary>&#xA;&#x9;public class SAFeCompletedStatus : SAFeStatus, CompletedStatus&#xA;&#x9;{&#xA;&#x9;&#x9;/// &lt;summary>&#xA;&#x9;&#x9;///   Constructs a &lt;code>Status&lt;/code> object from a low-level &lt;see cref=&quot;Unsafe.MPI_Status&quot;/> structure&#xA;&#x9;&#x9;///   and a count of the number of elements received.&#xA;&#x9;&#x9;/// &lt;/summary>&#xA;&#x9;&#x9;internal SAFeCompletedStatus(Tuple&lt;int, int> source, int tag, int count) : base(source, tag)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;this.count = count;&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;internal SAFeCompletedStatus(Tuple&lt;int, int> source, int tag) : base(source, tag)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;public static CompletedStatus createStatus(Tuple&lt;int, int> source, int tag, int count)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;return new SAFeCompletedStatus(source, tag, count);&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;public static CompletedStatus createStatus(Tuple&lt;int, int> source, int tag)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;return new SAFeCompletedStatus(source, tag);&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;private int? count = null;&#xA;&#xA;&#x9;&#x9;/// &lt;summary>&#xA;&#x9;&#x9;/// Determines the number of elements in the transmitted message.&#xA;&#x9;&#x9;/// &lt;/summary>&#xA;&#x9;&#x9;public int? Count&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;get { return count; }&#xA;&#x9;&#x9;&#x9;set { count = value; }&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;}&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#x9;public class MPIStatus : Status&#xA;&#x9;{&#xA;&#x9;&#x9;private MPI.Status internal_status;&#xA;&#xA;&#x9;&#x9;/// &lt;summary>&#xA;&#x9;&#x9;///   Constructs a &lt;code>Status&lt;/code> object from a low-level &lt;see cref=&quot;Unsafe.MPI_Status&quot;/> structure.&#xA;&#x9;&#x9;/// &lt;/summary>&#xA;&#x9;&#x9;internal MPIStatus(MPI.Status internal_status, Tuple&lt;int, int> source)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;this.source = source;&#xA;&#x9;&#x9;&#x9;this.internal_status = internal_status;&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;Tuple&lt;int, int> source;&#xA;&#xA;&#x9;&#x9;/// &lt;summary>&#xA;&#x9;&#x9;/// The rank of the process that sent the message.&#xA;&#x9;&#x9;/// &lt;/summary>&#xA;&#x9;&#x9;public Tuple&lt;int, int> Source&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;get&#xA;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;return source;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;/// &lt;summary>&#xA;&#x9;&#x9;/// The tag used to send the message.&#xA;&#x9;&#x9;/// &lt;/summary>&#xA;&#x9;&#x9;public int Tag&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;get&#xA;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;return internal_status.Tag;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;/// &lt;summary>&#xA;&#x9;&#x9;/// Determine the number of elements transmitted by the communication&#xA;&#x9;&#x9;/// operation associated with this object.&#xA;&#x9;&#x9;/// &lt;/summary>&#xA;&#x9;&#x9;/// &lt;param name=&quot;type&quot;>&#xA;&#x9;&#x9;///   The type of data that will be stored in the message.&#xA;&#x9;&#x9;/// &lt;/param>&#xA;&#x9;&#x9;/// &lt;returns>&#xA;&#x9;&#x9;///   If the type of the data is a value type, returns the number&#xA;&#x9;&#x9;///   of elements in the message. Otherwise, returns &lt;c>null&lt;/c>,&#xA;&#x9;&#x9;///   because the number of elements stored in the message won't&#xA;&#x9;&#x9;///   be known until the message is received.&#xA;&#x9;&#x9;/// &lt;/returns>&#xA;&#x9;&#x9;public int? Count(Type type)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;return internal_status.Count(type);&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;/// &lt;summary>&#xA;&#x9;&#x9;/// Whether the communication was cancelled before it completed.&#xA;&#x9;&#x9;/// &lt;/summary>&#xA;&#x9;&#x9;public bool Cancelled&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;get&#xA;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;return internal_status.Cancelled;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;}&#xA;&#xA;&#x9;/// &lt;summary>&#xA;&#x9;/// Information about a specific message that has already been&#xA;&#x9;/// transferred via MPI.&#xA;&#x9;/// &lt;/summary>&#xA;&#x9;public class MPICompletedStatus : MPIStatus, CompletedStatus&#xA;&#x9;{&#xA;&#x9;&#x9;private MPI.CompletedStatus internal_status;&#xA;&#xA;&#x9;&#x9;/// &lt;summary>&#xA;&#x9;&#x9;///   Constructs a &lt;code>Status&lt;/code> object from a low-level &lt;see cref=&quot;Unsafe.MPI_Status&quot;/> structure&#xA;&#x9;&#x9;///   and a count of the number of elements received.&#xA;&#x9;&#x9;/// &lt;/summary>&#xA;&#x9;&#x9;internal MPICompletedStatus(MPI.CompletedStatus internal_status, Tuple&lt;int, int> source) : base(internal_status, source)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;this.internal_status = internal_status;&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;public static CompletedStatus createStatus(MPI.CompletedStatus internal_status, Tuple&lt;int, int> source)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;return new MPICompletedStatus(internal_status, source);&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;/// &lt;summary>&#xA;&#x9;&#x9;/// Determines the number of elements in the transmitted message.&#xA;&#x9;&#x9;/// &lt;/summary>&#xA;&#x9;&#x9;public int? Count&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;get { return internal_status.Count(); }&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;}&#xA;&#xA;&#x9;public interface IRequest&#xA;&#x9;{&#xA;&#x9;&#x9;void registerWaitingSet(AutoResetEvent waiting_set);&#xA;&#x9;&#x9;void unregisterWaitingSet(AutoResetEvent waiting_set);&#xA;&#x9;&#x9;CompletedStatus Wait();&#xA;&#x9;&#x9;CompletedStatus Test();&#xA;&#x9;&#x9;void Cancel();&#xA;&#x9;}&#xA;&#xA;&#x9;public class Request : IRequest // Without MPI&#xA;&#x9;{&#xA;&#x9;&#x9;private Tuple&lt;int, int> source;&#xA;&#x9;&#x9;int tag;&#xA;&#xA;&#x9;&#x9;private ManualResetEvent e;&#xA;&#x9;&#x9;private Thread waiting_request = null;&#xA;&#x9;&#x9;protected ManualResetEvent initial_signal = new ManualResetEvent(false);&#xA;&#x9;&#x9;private bool completed = false;&#xA;&#xA;&#x9;&#x9;bool completed_request = false;&#xA;&#xA;&#xA;&#x9;&#x9;internal Request(ManualResetEvent e, Tuple&lt;int, int> source, int tag)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;this.e = e;&#xA;&#x9;&#x9;&#x9;this.source = source;&#xA;&#x9;&#x9;&#x9;this.tag = tag;&#xA;&#x9;&#x9;&#x9;new Thread(new ThreadStart(delegate ()&#xA;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;e.WaitOne();&#xA;&#x9;&#x9;&#x9;&#x9;completed_request = true;&#xA;&#x9;&#x9;&#x9;})).Start();&#xA;&#xA;&#x9;&#x9;}&#xA;&#xA;&#xA;&#x9;&#x9;private object wait_lock = new object();&#xA;&#xA;&#x9;&#x9;private IList&lt;AutoResetEvent> waiting_sets = new List&lt;AutoResetEvent>();&#xA;&#xA;&#x9;&#x9;public void registerWaitingSet(AutoResetEvent waiting_set)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;waiting_request = new Thread(new ThreadStart(delegate&#xA;&#x9;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;while (true)&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;initial_signal.WaitOne();&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;e.WaitOne();&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;lock (wait_lock)&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;completed = true;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;foreach (AutoResetEvent ws in waiting_sets)&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;ws.Set();&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;}));&#xA;&#xA;&#x9;&#x9;&#x9;waiting_request.Start();&#xA;&#xA;&#x9;&#x9;&#x9;lock (wait_lock)&#xA;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;if (completed)&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;waiting_set.Set();&#xA;&#x9;&#x9;&#x9;&#x9;else&#xA;&#x9;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;waiting_sets.Add(waiting_set);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;initial_signal.Set();&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;public void unregisterWaitingSet(AutoResetEvent waiting_set)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;waiting_sets.Remove(waiting_set);&#xA;&#x9;&#x9;&#x9;initial_signal.Reset();&#xA;&#x9;&#x9;&#x9;waiting_request.Abort();&#xA;&#x9;&#x9;&#x9;waiting_request = null;&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;/// &lt;summary>&#xA;&#x9;&#x9;/// Wait until this non-blocking operation has completed.&#xA;&#x9;&#x9;/// &lt;/summary>&#xA;&#x9;&#x9;/// &lt;returns>&#xA;&#x9;&#x9;///   Information about the completed communication operation.&#xA;&#x9;&#x9;/// &lt;/returns>&#xA;&#x9;&#x9;public CompletedStatus Wait()&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;e.WaitOne();&#xA;&#x9;&#x9;&#x9;return SAFeCompletedStatus.createStatus(source, tag);&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;/// &lt;summary>&#xA;&#x9;&#x9;/// Determine whether this non-blocking operation has completed.&#xA;&#x9;&#x9;/// &lt;/summary>&#xA;&#x9;&#x9;/// &lt;returns>&#xA;&#x9;&#x9;/// If the non-blocking operation has completed, returns information&#xA;&#x9;&#x9;/// about the completed communication operation. Otherwise, returns&#xA;&#x9;&#x9;/// &lt;c>null&lt;/c> to indicate that the operation has not completed.&#xA;&#x9;&#x9;/// &lt;/returns>&#xA;&#x9;&#x9;public CompletedStatus Test()&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;return completed_request ? SAFeCompletedStatus.createStatus(source, tag) : null;&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;/// &lt;summary>&#xA;&#x9;&#x9;/// Cancel this communication request.&#xA;&#x9;&#x9;/// &lt;/summary>&#xA;&#x9;&#x9;public void Cancel()&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;// TODO: cancel functionality not implemented ...&#xA;&#x9;&#x9;&#x9;//internal_request.Cancel ();&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;public static IRequest createRequest(ManualResetEvent e, Tuple&lt;int, int> source, int tag)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;return new Request(e, source, tag);&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;// Convert an object to a byte array&#xA;&#x9;&#x9;protected static byte[] ObjectToByteArray(Object obj)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;if (obj == null)&#xA;&#x9;&#x9;&#x9;&#x9;return null;&#xA;&#x9;&#x9;&#x9;BinaryFormatter bf = new BinaryFormatter();&#xA;&#x9;&#x9;&#x9;MemoryStream ms = new MemoryStream();&#xA;&#x9;&#x9;&#x9;bf.Serialize(ms, obj);&#xA;&#x9;&#x9;&#x9;return ms.ToArray();&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;protected static Object ByteArrayToObject(byte[] arrBytes)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;MemoryStream memStream = new MemoryStream();&#xA;&#x9;&#x9;&#x9;BinaryFormatter binForm = new BinaryFormatter();&#xA;&#x9;&#x9;&#x9;memStream.Write(arrBytes, 0, arrBytes.Length);&#xA;&#x9;&#x9;&#x9;memStream.Seek(0, SeekOrigin.Begin);&#xA;&#x9;&#x9;&#x9;Object obj = (Object)binForm.Deserialize(memStream);&#xA;&#x9;&#x9;&#x9;return obj;&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;}&#xA;&#xA;&#xA;&#xA;&#xA;&#x9;/// &lt;summary>&#xA;&#x9;/// A non-blocking communication request.&#xA;&#x9;/// &lt;/summary>&#xA;&#x9;/// &lt;remarks>&#xA;&#x9;/// Each request object refers to a single&#xA;&#x9;/// communication operation, such as non-blocking send &#xA;&#x9;/// (see &lt;see cref=&quot;Communicator.ImmediateSend&amp;lt;T&amp;gt;(T, int, int)&quot;/>)&#xA;&#x9;/// or receive. Non-blocking operations may progress in the background, and can complete&#xA;&#x9;/// without any user intervention. However, it is crucial that outstanding communication&#xA;&#x9;/// requests be completed with a successful call to &lt;see cref=&quot;Wait&quot;/> or &lt;see cref=&quot;Test&quot;/>&#xA;&#x9;/// before the request object is lost.&#xA;&#x9;/// &lt;/remarks>&#xA;&#x9;public class MPIRequest : IRequest&#xA;&#x9;{&#xA;&#x9;&#x9;private MPI.Request internal_request;&#xA;&#x9;&#x9;private Tuple&lt;int, int> source;&#xA;&#xA;&#x9;&#x9;private Thread waiting_request = null;&#xA;&#x9;&#x9;protected ManualResetEvent initial_signal = new ManualResetEvent(false);&#xA;&#x9;&#x9;private bool completed = false;&#xA;&#xA;&#x9;&#x9;internal MPIRequest(MPI.Request internal_request, Tuple&lt;int, int> source)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;this.internal_request = internal_request;&#xA;&#x9;&#x9;&#x9;this.source = source;&#xA;&#x9;&#x9;}&#xA;&#xA;&#xA;&#x9;&#x9;private object wait_lock = new object();&#xA;&#xA;&#x9;&#x9;private IList&lt;AutoResetEvent> waiting_sets = new List&lt;AutoResetEvent>();&#xA;&#xA;&#x9;&#x9;public void registerWaitingSet(AutoResetEvent waiting_set)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;waiting_request = new Thread(new ThreadStart(delegate&#xA;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;while (true)&#xA;&#x9;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;initial_signal.WaitOne();&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;internal_request.Wait();&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;lock (wait_lock)&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;completed = true;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;foreach (AutoResetEvent ws in waiting_sets)&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;ws.Set();&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;}));&#xA;&#xA;&#x9;&#x9;&#x9;waiting_request.Start();&#xA;&#xA;&#x9;&#x9;&#x9;lock (wait_lock)&#xA;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;if (completed)&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;waiting_set.Set();&#xA;&#x9;&#x9;&#x9;&#x9;else&#xA;&#x9;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;waiting_sets.Add(waiting_set);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;initial_signal.Set();&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;public void unregisterWaitingSet(AutoResetEvent waiting_set)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;waiting_sets.Remove(waiting_set);&#xA;&#x9;&#x9;&#x9;initial_signal.Reset();&#xA;&#x9;&#x9;&#x9;waiting_request.Abort();&#xA;&#x9;&#x9;&#x9;waiting_request = null;&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;/// &lt;summary>&#xA;&#x9;&#x9;/// Wait until this non-blocking operation has completed.&#xA;&#x9;&#x9;/// &lt;/summary>&#xA;&#x9;&#x9;/// &lt;returns>&#xA;&#x9;&#x9;///   Information about the completed communication operation.&#xA;&#x9;&#x9;/// &lt;/returns>&#xA;&#x9;&#x9;public CompletedStatus Wait()&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;MPI.CompletedStatus internal_status = internal_request.Wait();&#xA;&#x9;&#x9;&#x9;return MPICompletedStatus.createStatus(internal_status, source);&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;/// &lt;summary>&#xA;&#x9;&#x9;/// Determine whether this non-blocking operation has completed.&#xA;&#x9;&#x9;/// &lt;/summary>&#xA;&#x9;&#x9;/// &lt;returns>&#xA;&#x9;&#x9;/// If the non-blocking operation has completed, returns information&#xA;&#x9;&#x9;/// about the completed communication operation. Otherwise, returns&#xA;&#x9;&#x9;/// &lt;c>null&lt;/c> to indicate that the operation has not completed.&#xA;&#x9;&#x9;/// &lt;/returns>&#xA;&#x9;&#x9;public CompletedStatus Test()&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;MPI.CompletedStatus internal_status = internal_request.Test();&#xA;&#x9;&#x9;&#x9;return internal_status != null ? MPICompletedStatus.createStatus(internal_status, source) : null;&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;/// &lt;summary>&#xA;&#x9;&#x9;/// Cancel this communication request.&#xA;&#x9;&#x9;/// &lt;/summary>&#xA;&#x9;&#x9;public void Cancel()&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;internal_request.Cancel();&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;public static IRequest createRequest(MPI.Request internal_status, Tuple&lt;int, int> source)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;return new MPIRequest(internal_status, source);&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;// Convert an object to a byte array&#xA;&#x9;&#x9;protected static byte[] ObjectToByteArray(Object obj)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;if (obj == null)&#xA;&#x9;&#x9;&#x9;&#x9;return null;&#xA;&#x9;&#x9;&#x9;BinaryFormatter bf = new BinaryFormatter();&#xA;&#x9;&#x9;&#x9;MemoryStream ms = new MemoryStream();&#xA;&#x9;&#x9;&#x9;bf.Serialize(ms, obj);&#xA;&#x9;&#x9;&#x9;return ms.ToArray();&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;protected static Object ByteArrayToObject(byte[] arrBytes)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;MemoryStream memStream = new MemoryStream();&#xA;&#x9;&#x9;&#x9;BinaryFormatter binForm = new BinaryFormatter();&#xA;&#x9;&#x9;&#x9;memStream.Write(arrBytes, 0, arrBytes.Length);&#xA;&#x9;&#x9;&#x9;memStream.Seek(0, SeekOrigin.Begin);&#xA;&#x9;&#x9;&#x9;Object obj = (Object)binForm.Deserialize(memStream);&#xA;&#x9;&#x9;&#x9;return obj;&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;}&#xA;&#xA;&#x9;public interface IReceiveRequest : IRequest&#xA;&#x9;{&#xA;&#x9;&#x9;object GetValue();&#xA;&#x9;}&#xA;&#xA;&#x9;public abstract class ReceiveRequest : Request, IReceiveRequest&#xA;&#x9;{&#xA;&#x9;&#x9;internal ReceiveRequest(ManualResetEvent e, Tuple&lt;int, int> source, int tag) : base(e, source, tag)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;/// &lt;summary>&#xA;&#x9;&#x9;/// Retrieve the value received via this communication. The value&#xA;&#x9;&#x9;/// will only be available when the communication has completed.&#xA;&#x9;&#x9;/// &lt;/summary>&#xA;&#x9;&#x9;/// &lt;returns>The value received by this communication.&lt;/returns>&#xA;&#x9;&#x9;public abstract object GetValue();&#xA;&#x9;}&#xA;&#x9;/// &lt;summary>&#xA;&#x9;/// A non-blocking receive request. &#xA;&#x9;/// &lt;/summary>&#xA;&#x9;/// &lt;remarks>&#xA;&#x9;/// This class allows one to test a receive&#xA;&#x9;/// request for completion, wait for completion of a request, cancel a request,&#xA;&#x9;/// or extract the value received by this communication request.&#xA;&#x9;/// &lt;/remarks>&#xA;&#x9;public abstract class MPIReceiveRequest : MPIRequest, IReceiveRequest&#xA;&#x9;{&#xA;&#xA;&#x9;&#x9;internal MPIReceiveRequest(MPI.ReceiveRequest internal_request, Tuple&lt;int, int> source) : base(internal_request, source)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;/// &lt;summary>&#xA;&#x9;&#x9;/// Retrieve the value received via this communication. The value&#xA;&#x9;&#x9;/// will only be available when the communication has completed.&#xA;&#x9;&#x9;/// &lt;/summary>&#xA;&#x9;&#x9;/// &lt;returns>The value received by this communication.&lt;/returns>&#xA;&#x9;&#x9;public abstract object GetValue();&#xA;&#x9;}&#xA;&#xA;&#x9;/// &lt;summary>&#xA;&#x9;/// A non-blocking receive request. &#xA;&#x9;/// &lt;/summary>&#xA;&#x9;/// &lt;remarks>&#xA;&#x9;/// This class allows one to test a receive&#xA;&#x9;/// request for completion, wait for completion of a request, cancel a request,&#xA;&#x9;/// or extract the value received by this communication request.&#xA;&#x9;/// &lt;/remarks>&#xA;&#x9;public class ValueReceiveRequest&lt;T> : ReceiveRequest&#xA;&#x9;{&#xA;&#x9;&#x9;Tuple&lt;int, int> source = null;&#xA;&#x9;&#x9;int? tag = null;&#xA;&#xA;&#x9;&#x9;internal ValueReceiveRequest(ManualResetEvent e, Tuple&lt;int, int> source, int tag) : base(e, source, tag)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;this.source = source;&#xA;&#x9;&#x9;&#x9;this.tag = tag;&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;private object value = null;&#xA;&#xA;&#x9;&#x9;/// &lt;summary>&#xA;&#x9;&#x9;/// Retrieve the value received via this communication. The value&#xA;&#x9;&#x9;/// will only be available when the communication has completed.&#xA;&#x9;&#x9;/// &lt;/summary>&#xA;&#x9;&#x9;/// &lt;returns>The value received by this communication.&lt;/returns>&#xA;&#x9;&#x9;public override object GetValue()&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;return value;&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;public void SetValue(byte[] v)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;value = (T)ByteArrayToObject(v);&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;public static new ValueReceiveRequest&lt;T> createRequest(ManualResetEvent e, Tuple&lt;int, int> source, int tag)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;return new ValueReceiveRequest&lt;T>(e, source, tag);&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;public new CompletedStatus Wait()&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;SAFeCompletedStatus status = (SAFeCompletedStatus)base.Wait();&#xA;&#x9;&#x9;&#x9;status.Count = 1;&#xA;&#x9;&#x9;&#x9;return status;&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;public new CompletedStatus Test()&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;SAFeCompletedStatus status = (SAFeCompletedStatus)base.Test();&#xA;&#xA;&#x9;&#x9;&#x9;if (status != null)&#xA;&#x9;&#x9;&#x9;&#x9;status.Count = 1;&#xA;&#xA;&#x9;&#x9;&#x9;return status;&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#xA;&#xA;&#x9;/// &lt;summary>&#xA;&#x9;/// A non-blocking receive request. &#xA;&#x9;/// &lt;/summary>&#xA;&#x9;/// &lt;remarks>&#xA;&#x9;/// This class allows one to test a receive&#xA;&#x9;/// request for completion, wait for completion of a request, cancel a request,&#xA;&#x9;/// or extract the value received by this communication request.&#xA;&#x9;/// &lt;/remarks>&#xA;&#x9;public class MPIValueReceiveRequest&lt;T> : MPIReceiveRequest&#xA;&#x9;{&#xA;&#x9;&#x9;private MPI.ReceiveRequest internal_request;&#xA;&#xA;&#x9;&#x9;internal MPIValueReceiveRequest(MPI.ReceiveRequest internal_request, Tuple&lt;int, int> source) : base(internal_request, source)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;this.internal_request = internal_request;&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;/// &lt;summary>&#xA;&#x9;&#x9;/// Retrieve the value received via this communication. The value&#xA;&#x9;&#x9;/// will only be available when the communication has completed.&#xA;&#x9;&#x9;/// &lt;/summary>&#xA;&#x9;&#x9;/// &lt;returns>The value received by this communication.&lt;/returns>&#xA;&#x9;&#x9;public override object GetValue()&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;byte[] v = (byte[])this.internal_request.GetValue();&#xA;&#x9;&#x9;&#x9;return (T)ByteArrayToObject(v);&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;public static MPIValueReceiveRequest&lt;T> createRequest(MPI.ReceiveRequest internal_status, Tuple&lt;int, int> source)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;return new MPIValueReceiveRequest&lt;T>(internal_status, source);&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;}&#xA;&#xA;&#x9;/// &lt;summary>&#xA;&#x9;/// A non-blocking receive request. &#xA;&#x9;/// &lt;/summary>&#xA;&#x9;/// &lt;remarks>&#xA;&#x9;/// This class allows one to test a receive&#xA;&#x9;/// request for completion, wait for completion of a request, cancel a request,&#xA;&#x9;/// or extract the value received by this communication request.&#xA;&#x9;/// &lt;/remarks>&#xA;&#x9;public class ArrayReceiveRequest&lt;T> : ReceiveRequest&#xA;&#x9;{&#xA;&#x9;&#x9;private T[] values = null;&#xA;&#x9;&#x9;private byte[] v = null;&#xA;&#x9;&#x9;Tuple&lt;int, int> source = null;&#xA;&#x9;&#x9;int? tag = null;&#xA;&#xA;&#x9;&#x9;internal ArrayReceiveRequest(ManualResetEvent e, Tuple&lt;int, int> source, int tag, T[] values) : base(e, source, tag)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;this.values = values;&#xA;&#x9;&#x9;&#x9;this.source = source;&#xA;&#x9;&#x9;&#x9;this.tag = null;&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;/// &lt;summary>&#xA;&#x9;&#x9;/// Retrieve the value received via this communication. The value&#xA;&#x9;&#x9;/// will only be available when the communication has completed.&#xA;&#x9;&#x9;/// &lt;/summary>&#xA;&#x9;&#x9;/// &lt;returns>The value received by this communication.&lt;/returns>&#xA;&#x9;&#x9;public override object GetValue()&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;if (v == null)&#xA;&#x9;&#x9;&#x9;&#x9;return null;&#xA;&#xA;&#x9;&#x9;&#x9;T[] values_ = (T[])ByteArrayToObject(v);&#xA;&#xA;&#x9;&#x9;&#x9;// Copy the received values to the destination array (forcing original MPI semantics)&#xA;&#x9;&#x9;&#x9;int size = values.Length &lt;= values_.Length ? values.Length : values_.Length;&#xA;&#x9;&#x9;&#x9;for (int i = 0; i &lt; size; i++)&#xA;&#x9;&#x9;&#x9;&#x9;values[i] = values_[i];&#xA;&#xA;&#x9;&#x9;&#x9;return values;&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;public void SetValue(byte[] v)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;values = (T[])ByteArrayToObject(v);&#xA;&#x9;&#x9;}&#xA;&#xA;&#xA;&#x9;&#x9;public static ArrayReceiveRequest&lt;T> createRequest(ManualResetEvent e, Tuple&lt;int, int> source, int tag, T[] values)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;return new ArrayReceiveRequest&lt;T>(e, source, tag, values);&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;public new CompletedStatus Wait()&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;SAFeCompletedStatus status = (SAFeCompletedStatus)base.Wait();&#xA;&#x9;&#x9;&#x9;status.Count = values.Length;&#xA;&#x9;&#x9;&#x9;return status;&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;public new CompletedStatus Test()&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;SAFeCompletedStatus status = (SAFeCompletedStatus)base.Test();&#xA;&#xA;&#x9;&#x9;&#x9;if (status != null)&#xA;&#x9;&#x9;&#x9;&#x9;status.Count = values.Length;&#xA;&#xA;&#x9;&#x9;&#x9;return status;&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;}&#xA;&#xA;&#xA;&#x9;/// &lt;summary>&#xA;&#x9;/// A non-blocking receive request. &#xA;&#x9;/// &lt;/summary>&#xA;&#x9;/// &lt;remarks>&#xA;&#x9;/// This class allows one to test a receive&#xA;&#x9;/// request for completion, wait for completion of a request, cancel a request,&#xA;&#x9;/// or extract the value received by this communication request.&#xA;&#x9;/// &lt;/remarks>&#xA;&#x9;public class MPIArrayReceiveRequest&lt;T> : MPIReceiveRequest&#xA;&#x9;{&#xA;&#x9;&#x9;private MPI.ReceiveRequest internal_request;&#xA;&#x9;&#x9;private T[] values = null;&#xA;&#xA;&#x9;&#x9;internal MPIArrayReceiveRequest(MPI.ReceiveRequest internal_request, Tuple&lt;int, int> source, T[] values) : base(internal_request, source)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;this.internal_request = internal_request;&#xA;&#x9;&#x9;&#x9;this.values = values;&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;/// &lt;summary>&#xA;&#x9;&#x9;/// Retrieve the value received via this communication. The value&#xA;&#x9;&#x9;/// will only be available when the communication has completed.&#xA;&#x9;&#x9;/// &lt;/summary>&#xA;&#x9;&#x9;/// &lt;returns>The value received by this communication.&lt;/returns>&#xA;&#x9;&#x9;public override object GetValue()&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;byte[] v = (byte[])this.internal_request.GetValue();&#xA;&#x9;&#x9;&#x9;T[] values_ = (T[])ByteArrayToObject(v);&#xA;&#xA;&#x9;&#x9;&#x9;// Copy the received values to the destination array (forcing original MPI semantics)&#xA;&#x9;&#x9;&#x9;int size = values.Length &lt;= values_.Length ? values.Length : values_.Length;&#xA;&#x9;&#x9;&#x9;for (int i = 0; i &lt; size; i++)&#xA;&#x9;&#x9;&#x9;&#x9;values[i] = values_[i];&#xA;&#xA;&#x9;&#x9;&#x9;return values;&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;public static MPIArrayReceiveRequest&lt;T> createRequest(MPI.ReceiveRequest internal_status, Tuple&lt;int, int> source, T[] values)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;return new MPIArrayReceiveRequest&lt;T>(internal_status, source, values);&#xA;&#x9;&#x9;}&#xA;&#xA;&#xA;&#x9;}&#xA;&#xA;&#xA;&#x9;/// &lt;summary>&#xA;&#x9;/// A request list contains a list of outstanding MPI requests. &#xA;&#x9;/// &lt;/summary>&#xA;&#x9;/// &#xA;&#x9;/// &lt;remarks>&#xA;&#x9;/// The requests in a &lt;c>RequestList&lt;/c>&#xA;&#x9;/// are typically non-blocking send or receive operations (e.g.,&#xA;&#x9;/// &lt;see cref=&quot;Communicator.ImmediateSend&amp;lt;T&amp;gt;(T, int, int)&quot;/>,&#xA;&#x9;/// &lt;see cref=&quot;Communicator.ImmediateReceive&amp;lt;T&amp;gt;(int, int)&quot;/>). The&#xA;&#x9;/// request list provides the ability to operate on the set of MPI requests&#xA;&#x9;/// as a whole, for example by waiting until all requests complete before&#xA;&#x9;/// returning or testing whether any of the requests have completed.&#xA;&#x9;/// &lt;/remarks>&#xA;&#x9;public class RequestList&#xA;&#x9;{&#xA;&#x9;&#x9;/// &lt;summary>&#xA;&#x9;&#x9;/// Create a new, empty request list.&#xA;&#x9;&#x9;/// &lt;/summary>&#xA;&#x9;&#x9;public RequestList()&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;this.requests = new List&lt;IRequest>();&#xA;&#x9;&#x9;}&#xA;&#xA;&#xA;&#xA;&#x9;&#x9;/// &lt;summary>&#xA;&#x9;&#x9;/// Add a new request to the request list.&#xA;&#x9;&#x9;/// &lt;/summary>&#xA;&#x9;&#x9;/// &lt;param name=&quot;request&quot;>The request to add.&lt;/param>&#xA;&#x9;&#x9;public void Add(IRequest request)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;requests.Add(request);&#xA;&#xA;&#x9;&#x9;&#x9;if (sync_request != null)&#xA;&#x9;&#x9;&#x9;&#x9;request.registerWaitingSet(sync_request);&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;/// &lt;summary>&#xA;&#x9;&#x9;/// Remove a request from the request list.&#xA;&#x9;&#x9;/// &lt;/summary>&#xA;&#x9;&#x9;/// &lt;param name=&quot;request&quot;>Request to remove.&lt;/param>&#xA;&#x9;&#x9;public void Remove(IRequest request)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;requests.Remove(request);&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;/// &lt;summary>&#xA;&#x9;&#x9;/// Retrieves the number of elements in this list of requests.&#xA;&#x9;&#x9;/// &lt;/summary>&#xA;&#x9;&#x9;public int Count&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;get&#xA;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;return this.requests.Count;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;AutoResetEvent sync_request = null;&#xA;&#xA;&#x9;&#x9;/// &lt;summary>&#xA;&#x9;&#x9;/// Waits until any request has completed. That request will then be removed &#xA;&#x9;&#x9;/// from the request list and returned.&#xA;&#x9;&#x9;/// &lt;/summary>&#xA;&#x9;&#x9;/// &lt;returns>The completed request, which has been removed from the request list.&lt;/returns>&#xA;&#x9;&#x9;public IRequest WaitAny()&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;if (requests.Count == 0)&#xA;&#x9;&#x9;&#x9;&#x9;throw new ArgumentException(&quot;Cannot call MPI.RequestList.WaitAny with an empty request list&quot;);&#xA;&#xA;&#x9;&#x9;&#x9;sync_request = new AutoResetEvent(false);&#xA;&#xA;&#x9;&#x9;&#x9;foreach (IRequest req_item in requests)&#xA;&#x9;&#x9;&#x9;&#x9;req_item.registerWaitingSet(sync_request);&#xA;&#xA;&#x9;&#x9;&#x9;sync_request.WaitOne();&#xA;&#x9;&#x9;&#x9;sync_request = null;&#xA;&#xA;&#x9;&#x9;&#x9;IRequest req = this.TestAny();&#xA;&#xA;&#x9;&#x9;&#x9;foreach (IRequest req_item in requests)&#xA;&#x9;&#x9;&#x9;&#x9;req_item.unregisterWaitingSet(sync_request);&#xA;&#xA;&#x9;&#x9;&#x9;return req;&#xA;&#xA;&#xA;&#x9;&#x9;&#x9;/*          while (true)&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;Thread.Sleep (200);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;Request req = TestAny();&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (req != null)&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;return req;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}*/&#xA;&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;/// &lt;summary>&#xA;&#x9;&#x9;/// Determines whether any request has completed. If so, that request will be removed&#xA;&#x9;&#x9;/// from the request list and returned. &#xA;&#x9;&#x9;/// &lt;/summary>&#xA;&#x9;&#x9;/// &lt;returns>&#xA;&#x9;&#x9;///   The first request that has completed, if any. Otherwise, returns &lt;c>null&lt;/c> to&#xA;&#x9;&#x9;///   indicate that no request has completed.&#xA;&#x9;&#x9;/// &lt;/returns>&#xA;&#x9;&#x9;public IRequest TestAny()&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;int n = requests.Count;&#xA;&#x9;&#x9;&#x9;for (int i = 0; i &lt; n; ++i)&#xA;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;IRequest req = requests[i];&#xA;&#x9;&#x9;&#x9;&#x9;if (req.Test() != null)&#xA;&#x9;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;requests.RemoveAt(i);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;return req;&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;&#x9;return null;&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;/// &lt;summary>&#xA;&#x9;&#x9;/// Wait until all of the requests has completed before returning.&#xA;&#x9;&#x9;/// &lt;/summary>&#xA;&#x9;&#x9;/// &lt;returns>A list containing all of the completed requests.&lt;/returns>&#xA;&#x9;&#x9;public List&lt;IRequest> WaitAll()&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;List&lt;IRequest> result = new List&lt;IRequest>();&#xA;&#x9;&#x9;&#x9;foreach (IRequest req in requests)&#xA;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;req.Wait();&#xA;&#x9;&#x9;&#x9;&#x9;result.Add(req);&#xA;&#x9;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;&#x9;/*&#xA;            List&lt;Request> result = new List&lt;Request>();&#xA;            while (requests.Count > 0)&#xA;            {&#xA;                Request req = WaitAny();&#xA;                result.Add(req);&#xA;            }*/&#xA;&#xA;&#x9;&#x9;&#x9;return result;&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;/// &lt;summary>&#xA;&#x9;&#x9;/// Test whether all of the requests have completed. If all of the&#xA;&#x9;&#x9;/// requests have completed, the result is the list of requests. &#xA;&#x9;&#x9;/// Otherwise, the result is &lt;c>null&lt;/c>.&#xA;&#x9;&#x9;/// &lt;/summary>&#xA;&#x9;&#x9;/// &lt;returns>Either the list of all completed requests, or null.&lt;/returns>&#xA;&#x9;&#x9;public List&lt;IRequest> TestAll()&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;int n = requests.Count;&#xA;&#x9;&#x9;&#x9;for (int i = 0; i &lt; n; ++i)&#xA;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;if (requests[i].Test() == null)&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;return null;&#xA;&#x9;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;&#x9;List&lt;IRequest> result = requests;&#xA;&#x9;&#x9;&#x9;requests = new List&lt;IRequest>();&#xA;&#x9;&#x9;&#x9;return result;&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;/// &lt;summary>&#xA;&#x9;&#x9;/// Wait for at least one request to complete, then return a list of&#xA;&#x9;&#x9;/// all of the requests that have completed at this point.&#xA;&#x9;&#x9;/// &lt;/summary>&#xA;&#x9;&#x9;/// &lt;returns>&#xA;&#x9;&#x9;///   A list of all of the requests that have completed, which&#xA;&#x9;&#x9;///   will contain at least one element.&#xA;&#x9;&#x9;/// &lt;/returns>&#xA;&#x9;&#x9;public List&lt;IRequest> WaitSome()&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;if (requests.Count == 0)&#xA;&#x9;&#x9;&#x9;&#x9;throw new ArgumentException(&quot;Cannot call MPI.RequestList.WaitAny with an empty request list&quot;);&#xA;&#xA;&#x9;&#x9;&#x9;List&lt;IRequest> result = new List&lt;IRequest>();&#xA;&#x9;&#x9;&#x9;while (result.Count == 0)&#xA;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;int n = requests.Count;&#xA;&#x9;&#x9;&#x9;&#x9;for (int i = 0; i &lt; n; ++i)&#xA;&#x9;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;IRequest req = requests[i];&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if (req.Test() != null)&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;requests.RemoveAt(i);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;--i;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;--n;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;result.Add(req);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;return result;&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;/// &lt;summary>&#xA;&#x9;&#x9;/// Return a list of all requests that have completed.&#xA;&#x9;&#x9;/// &lt;/summary>&#xA;&#x9;&#x9;/// &lt;returns>&#xA;&#x9;&#x9;///   A list of all of the requests that have completed. If&#xA;&#x9;&#x9;///   no requests have completed, returns &lt;c>null&lt;/c>.&#xA;&#x9;&#x9;/// &lt;/returns>&#xA;&#x9;&#x9;public List&lt;IRequest> TestSome()&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;List&lt;IRequest> result = null;&#xA;&#x9;&#x9;&#x9;int n = requests.Count;&#xA;&#x9;&#x9;&#x9;for (int i = 0; i &lt; n; ++i)&#xA;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;IRequest req = requests[i];&#xA;&#x9;&#x9;&#x9;&#x9;if (req.Test() != null)&#xA;&#x9;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;requests.RemoveAt(i);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;--i;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;--n;&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if (result == null)&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;result = new List&lt;IRequest>();&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;result.Add(req);&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;return result;&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;/// &lt;summary>&#xA;&#x9;&#x9;/// The actual list of requests.&#xA;&#x9;&#x9;/// &lt;/summary>&#xA;&#x9;&#x9;protected List&lt;IRequest> requests;&#xA;&#x9;}&#xA;&#xA;&#xA;&#xA;}&#xA;&#xA;" name="Aliencommunicator.cs" uri="br.ufc.mdcc.hpc.storm.binding.channel.Binding/bin/1.0.0.0/Aliencommunicator.dll" versionId="1.0.0.0">
          <externalDependency>MPI</externalDependency>
        </file>
      </sources>
      <visualDescription h="40" w="179" x="227" y="489">
        <color b="144" g="238" r="144"/>
      </visualDescription>
      <externalReferences>MPI</externalReferences>
    </interface>
    <unit facet="0" iRef="IChannelRoot" multiple="false" private="true" replica="0" uRef="root" visibleInterface="true">
      <super cRef="base" uRef="root"/>
      <visualDescription h="40" w="146" x="215" y="128"/>
    </unit>
    <unit facet="0" iRef="IChannel" multiple="true" private="false" replica="0" uRef="peer" visibleInterface="true">
      <super cRef="base" uRef="peer"/>
      <visualDescription h="47" w="133" x="229" y="366"/>
    </unit>
  </componentInfo>
</component:component>