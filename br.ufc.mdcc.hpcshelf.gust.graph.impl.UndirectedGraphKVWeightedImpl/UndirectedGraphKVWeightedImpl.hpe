<?xml version="1.0" encoding="ASCII"?>
<component:component xmlns:component="http://www.example.org/HashComponent">
  <header hash_component_UID="00240000048000009400000006020000002400005253413100040000110000005b28b5a99875a52c30e9c80fe3c323c2c830267a4b7d687075b2cf01ca70efcc2cc73cd5e22172c5b90aa95c6c0a5430d38c5028a38a2c8985fec27c3a332726495f3d803a0eb6f03e4c2e7805d6cac4c4dce5cd1cbb97547e7749b524977cb5b6b5e350d4fc4159e7d611e3d9fd1d6857802e5b6b11007fd6588aaaec66f3a0" isAbstract="false" kind="Data" name="UndirectedGraphKVWeightedImpl" packagePath="br.ufc.mdcc.hpcshelf.gust.graph.impl">
    <baseType>
      <extensionType>
        <implements>true</implements>
      </extensionType>
      <component hash_component_UID="0024000004800000940000000602000000240000525341310004000011000000fb4da1412c4edb36db2d6a11df0060ac38aa48d250c592357e366179f1459959fb9a88740ca1e6dd07f4b612e8d3034bb19c7b9f817af432eb194570c601ab91fcd5aa0e0ac6d648c01874c21652cff20b5eb559ff4123b0981ac926ec6bbe71b887319f36d384e02385bc456cf3b9826d2da1e053b1481a6ecd10bf7b14069b" localRef="base" location="br.ufc.mdcc.hpcshelf.gust.graph.UndirectedGraph/UndirectedGraph.hpe" name="UndirectedGraph" package="br.ufc.mdcc.hpcshelf.gust.graph" version="1.0.0.0">
        <visualDescription h="60" w="100" x="344" y="290">
          <color b="255" g="255" r="255"/>
        </visualDescription>
        <parameter formFieldId="container" varName="CTN"/>
        <parameter formFieldId="vertex_type" varName="V"/>
        <parameter formFieldId="edge_type" varName="E"/>
        <unitBounds facet="0" facet_instance="0" facet_instance_enclosing="0" parallel="false" uRef="data">
          <visualDescription h="20" w="20" x="5" y="2"/>
        </unitBounds>
      </component>
    </baseType>
    <versions field1="1" field2="0" field3="0" field4="0"/>
    <visualAttributes>
      <color b="255" g="255" r="255"/>
    </visualAttributes>
    <facet_configuration facet="0" multiple="false"/>
  </header>
  <componentInfo>
    <innerComponent localRef="v" location="br.ufc.mdcc.hpcshelf.gust.graph.Vertex/Vertex.hpe" multiple="false" name="Vertex" package="br.ufc.mdcc.hpcshelf.gust.graph" exposed="true">
      <visualDescription h="60" w="142" x="119" y="290">
        <color b="255" g="255" r="255"/>
      </visualDescription>
      <unitBounds facet="0" facet_instance="0" parallel="false" uRef="data">
        <visualDescription h="20" w="20" x="5" y="2"/>
      </unitBounds>
    </innerComponent>
    <innerComponent localRef="e" location="br.ufc.mdcc.hpcshelf.gust.graph.Edge/Edge.hpe" multiple="false" name="Edge" package="br.ufc.mdcc.hpcshelf.gust.graph" exposed="true">
      <visualDescription h="60" w="161" x="524" y="302">
        <color b="255" g="255" r="255"/>
      </visualDescription>
      <parameter formFieldId="vertex_type" varName="V"/>
      <unitBounds facet="0" facet_instance="0" parallel="false" uRef="data">
        <visualDescription h="20" w="20" x="5" y="2"/>
      </unitBounds>
    </innerComponent>
    <innerComponent localRef="ctn" location="br.ufc.mdcc.hpcshelf.gust.graph.container.DataContainerKV/DataContainerKV.hpe" multiple="false" name="DataContainerKV" package="br.ufc.mdcc.hpcshelf.gust.graph.container" exposed="true">
      <visualDescription h="60" w="187" x="317" y="408">
        <color b="255" g="255" r="255"/>
      </visualDescription>
      <parameter formFieldId="vertex_type" varName="V"/>
      <parameter formFieldId="edge_type" varName="E"/>
      <unitBounds facet="0" facet_instance="0" parallel="false" uRef="data">
        <visualDescription h="20" w="20" x="5" y="2"/>
      </unitBounds>
    </innerComponent>
    <supplyParameter cRef="v" direct="true" varName="V"/>
    <supplyParameter cRef="e" direct="true" varName="E"/>
    <supplyParameter cRef="ctn" direct="true" varName="CTN"/>
    <interface iRef="IUndirectedGraphKVWeightedImpl" nArgs="3">
      <sources sourceType="C# Language" versionId="1.0.0.0">
        <file contents="/* Automatically Generated Code */&#xA;&#xA;using System;&#xA;using br.ufc.pargo.hpe.backend.DGAC;&#xA;using br.ufc.pargo.hpe.basic;&#xA;using br.ufc.pargo.hpe.kinds;&#xA;using br.ufc.mdcc.hpcshelf.gust.graph.Edge;&#xA;using br.ufc.mdcc.hpcshelf.gust.graph.Vertex;&#xA;using br.ufc.mdcc.hpcshelf.gust.graph.container.DataContainer;&#xA;using br.ufc.mdcc.hpcshelf.gust.graph.container.DataContainerKV;&#xA;using br.ufc.mdcc.hpcshelf.gust.graph.UndirectedGraph;&#xA;&#xA;namespace br.ufc.mdcc.hpcshelf.gust.graph.impl.UndirectedGraphKVWeightedImpl &#xA;{&#xA;&#x9;public abstract class BaseIUndirectedGraphKVWeightedImpl&lt;CTN, V, E>: DataStructure, BaseIUndirectedGraph&lt;CTN, V, E>&#xA;&#x9;&#x9;where CTN:IDataContainerKV&lt;V, E>&#xA;&#x9;&#x9;where V:IVertex&#xA;&#x9;&#x9;where E:IEdge&lt;V>&#xA;&#x9;{&#xA;&#x9;&#x9;private E edgeFactory = default(E);&#xA;&#xA;&#x9;&#x9;public E EdgeFactory&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;get&#xA;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;if (this.edgeFactory == null)&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;this.edgeFactory = (E) Services.getPort(&quot;edgeFactory&quot;);&#xA;&#x9;&#x9;&#x9;&#x9;return this.edgeFactory;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;private V vertex = default(V);&#xA;&#xA;&#x9;&#x9;public V Vertex&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;get&#xA;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;if (this.vertex == null)&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;this.vertex = (V) Services.getPort(&quot;vertex&quot;);&#xA;&#x9;&#x9;&#x9;&#x9;return this.vertex;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;private CTN dataContainer = default(CTN);&#xA;&#xA;&#x9;&#x9;public CTN DataContainer&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;get&#xA;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;if (this.dataContainer == null)&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;this.dataContainer = (CTN) Services.getPort(&quot;dataContainer&quot;);&#xA;&#x9;&#x9;&#x9;&#x9;return this.dataContainer;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;}" name="BaseIUndirectedGraphKVWeightedImpl.cs" srcType="base" uri="br.ufc.mdcc.hpcshelf.gust.graph.impl.UndirectedGraphKVWeightedImpl/bin/1.0.0.0/BaseIUndirectedGraphKVWeightedImpl.dll" versionId="1.0.0.0">
          <dependency>br.ufc.mdcc.hpcshelf.gust.graph.Edge/bin/1.0.0.0/IEdge.dll</dependency>
          <dependency>br.ufc.mdcc.hpcshelf.gust.graph.Vertex/bin/1.0.0.0/IVertex.dll</dependency>
          <dependency>br.ufc.mdcc.hpcshelf.gust.graph.container.DataContainer/bin/1.0.0.0/IDataContainer.dll</dependency>
          <dependency>br.ufc.mdcc.hpcshelf.gust.graph.container.DataContainerKV/bin/1.0.0.0/IDataContainerKV.dll</dependency>
          <dependency>br.ufc.mdcc.hpcshelf.gust.graph.UndirectedGraph/bin/1.0.0.0/BaseIUndirectedGraph.dll</dependency>
        </file>
        <file contents="using System;&#xA;using System.Collections.Generic;&#xA;using System.Linq;&#xA;using br.ufc.pargo.hpe.backend.DGAC;&#xA;using br.ufc.pargo.hpe.basic;&#xA;using br.ufc.pargo.hpe.kinds;&#xA;using br.ufc.mdcc.hpcshelf.gust.graph.container.DataContainerKV;&#xA;using br.ufc.mdcc.hpcshelf.gust.graph.container.DataContainer;&#xA;using br.ufc.mdcc.hpcshelf.gust.graph.Vertex;&#xA;using br.ufc.mdcc.hpcshelf.gust.graph.Edge;&#xA;using br.ufc.mdcc.hpcshelf.gust.graph.UndirectedGraph;&#xA;using br.ufc.mdcc.hpcshelf.gust.graph.Graph;&#xA;&#xA;namespace br.ufc.mdcc.hpcshelf.gust.graph.impl.UndirectedGraphKVWeightedImpl&#xA;{&#xA;&#x9;public class IUndirectedGraphKVWeightedImpl&lt;CTN, V, E> : BaseIUndirectedGraphKVWeightedImpl&lt;CTN, V, E>, IUndirectedGraph&lt;CTN, V, E>&#xA;where CTN:IDataContainerKV&lt;V, E>&#xA;where V:IVertex&#xA;where E:IEdge&lt;V> {&#xA;&#xA;&#x9;&#x9;override public void after_initialize()&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;newInstance(); &#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;public object newInstance () {&#xA;&#x9;&#x9;&#x9;return newInstance (0);&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;public object Instance {&#xA;&#x9;&#x9;&#x9;get { return graphInstanceT; }&#xA;&#x9;&#x9;&#x9;set { this.graphInstanceT = value; }&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;private object graphInstanceT = null;&#xA;&#x9;&#x9;public object GraphInstanceT { &#xA;&#x9;&#x9;&#x9;get{ &#xA;&#x9;&#x9;&#x9;&#x9;return this.graphInstanceT;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;public IUndirectedGraphInstance&lt;V, E, TV, TE> newInstanceT&lt;TV, TE> (TE e, int size)  where TE: IEdgeInstance&lt;V, TV> {&#xA;&#x9;&#x9;&#x9;IDataContainerKVInstance&lt;V, E, TV, TE> dc = DataContainer.InstanceTFactory&lt;TV, TE>(e);&#xA;&#x9;&#x9;&#x9;dc.newDataSet (size);&#xA;&#x9;&#x9;&#x9;IGraphHelperKV&lt;V, E, TV, TE> h = new IGraphHelperKVImpl&lt;V, E, TV, TE>(dc);&#xA;&#x9;&#x9;&#x9;this.graphInstanceT = new IUndirectedGraphKVWeightedInstanceImpl&lt;V, E, TV, TE> (h);&#xA;&#x9;&#x9;&#x9;return (IUndirectedGraphInstance&lt;V, E, TV, TE>) this.graphInstanceT;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;public IUndirectedGraphInstance&lt;V, E, int, IEdgeInstance&lt;V, int>> newInstance(int size) {&#xA;&#x9;&#x9;&#x9;IDataContainerKVInstance&lt;V, E, int, IEdgeInstance&lt;V, int>> dc = DataContainer.DataContainerKVInstance;&#xA;&#x9;&#x9;&#x9;dc.newDataSet (size);&#xA;&#x9;&#x9;&#x9;IGraphHelperKV&lt;V, E, int, IEdgeInstance&lt;V, int>> h = new IGraphHelperKVImpl&lt;V, E, int, IEdgeInstance&lt;V, int>>(dc);&#xA;&#x9;&#x9;&#x9;this.graphInstanceT = new IUndirectedGraphKVWeightedInstanceImpl&lt;V, E, int, IEdgeInstance&lt;V, int>> (h);&#xA;&#x9;&#x9;&#x9;return (IUndirectedGraphInstance&lt;V, E, int, IEdgeInstance&lt;V, int>>) this.graphInstanceT;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;public class IUndirectedGraphKVWeightedInstanceImpl&lt;V, E, TV, TE>: IUndirectedGraphInstance&lt;V, E, TV, TE> &#xA;&#x9;&#x9;&#x9;where V:IVertex  &#xA;&#x9;&#x9;&#x9;where E:IEdge&lt;V> &#xA;&#x9;&#x9;&#x9;where TE: IEdgeInstance&lt;V, TV> {&#xA;&#xA;&#x9;&#x9;&#x9;public IGraphHelperKV&lt;V, E, TV, TE> delegator;&#xA;&#xA;&#x9;&#x9;&#x9;public IDataContainerInstance&lt;V, E> DataContainer{&#xA;&#x9;&#x9;&#x9;&#x9;get{ return this.delegator.Container; }&#xA;&#x9;&#x9;&#x9;&#x9;set{ this.delegator.Container = (IDataContainerKVInstance&lt;V, E, TV, TE>)value; }&#xA;&#x9;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;&#x9;public IUndirectedGraphKVWeightedInstanceImpl(IGraphHelperKV&lt;V, E, TV, TE> d){&#xA;&#x9;&#x9;&#x9;&#x9;delegator = d;&#xA;&#x9;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;&#x9;public object ObjValue {&#xA;&#x9;&#x9;&#x9;&#x9;get { return new Tuple&lt;IGraphHelperKV&lt;V, E, TV, TE>>(delegator); }&#xA;&#x9;&#x9;&#x9;&#x9;set { &#xA;&#x9;&#x9;&#x9;&#x9;&#x9;this.delegator = ((Tuple&lt;IGraphHelperKV&lt;V, E, TV, TE>>)value).Item1;&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;&#x9;//************** implementation ***********************&#xA;&#x9;&#x9;&#x9;public ICollection&lt;TE> getAllEdges (TV sourceVertex, TV targetVertex) {&#xA;&#x9;&#x9;&#x9;&#x9;ICollection&lt;TE> edges = null;&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;if (containsVertex (sourceVertex) &amp;&amp; containsVertex (targetVertex)) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;edges = new List&lt;TE>();&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;IEnumerator&lt;TE> iter = iteratorEdgesOf (sourceVertex);&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;while (iter.MoveNext ()) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;TE e = iter.Current;&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;bool equal = isEqualsStraightOrInverted (sourceVertex, targetVertex, e);&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (equal) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;edges.Add (e);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;return edges;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public TE getEdge (TV sourceVertex, TV targetVertex) {&#xA;&#x9;&#x9;&#x9;&#x9;if (containsVertex (sourceVertex) &amp;&amp; containsVertex (targetVertex)) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;IEnumerator&lt;TE> iter = iteratorEdgesOf (sourceVertex);&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;while (iter.MoveNext ()) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;TE e = iter.Current;&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;bool equal = isEqualsStraightOrInverted (sourceVertex, targetVertex, e);&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (equal) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;return e;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;return default(TE);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public TE addEdge (TV sourceVertex, TV targetVertex) {&#xA;&#x9;&#x9;&#x9;&#x9;if (containsVertex (sourceVertex) &amp;&amp; containsVertex (targetVertex)) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if (!delegator.Container.AllowingMultipleEdges &amp;&amp; containsEdge (sourceVertex, targetVertex)) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;return default(TE);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if (!delegator.Container.AllowingLoops &amp;&amp; sourceVertex.Equals (targetVertex)) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;return default(TE);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;TE e = (TE) delegator.Container.EdgeFactory.newInstance (sourceVertex, targetVertex);&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;addEdgeToContainer(e);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;return e;&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;return default(TE);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public bool addEdge (TE e) {&#xA;&#x9;&#x9;&#x9;&#x9;if (e == null || e.Source == null || e.Target == null) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;return false;&#xA;&#x9;&#x9;&#x9;&#x9;} &#xA;&#x9;&#x9;&#x9;&#x9;if (containsVertex (e.Source) &amp;&amp; containsVertex (e.Target)) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if (!delegator.Container.AllowingMultipleEdges &amp;&amp; containsEdge (e.Source, e.Target)) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;return false;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if (!delegator.Container.AllowingLoops &amp;&amp; e.Source.Equals (e.Target)) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;return false;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;addEdgeToContainer(e);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;return true;&#xA;&#x9;&#x9;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;return false;&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public bool addVertex (TV v) {&#xA;&#x9;&#x9;&#x9;&#x9;return delegator.addVertex (v);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public bool containsEdge(TV sourceVertex, TV targetVertex){&#xA;&#x9;&#x9;&#x9;&#x9;return getEdge(sourceVertex, targetVertex) != null;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public bool containsEdge(TE e){&#xA;&#x9;&#x9;&#x9;&#x9;if (e != null) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if (containsVertex (e.Source) &amp;&amp; containsVertex (e.Target))&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;return delegator.containsEdge (e);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;else&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;return false;&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;return false;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public bool containsVertex (TV v){&#xA;&#x9;&#x9;&#x9;&#x9;if (v == null) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;Console.WriteLine (&quot;WARNING: containsVertex(parameter null!) &quot;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;return false;&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;return delegator.containsVertex (v);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public IEnumerator&lt;TE> edgeSet () {&#xA;&#x9;&#x9;&#x9;&#x9;return delegator.edgeSet ();&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public ICollection&lt;TE> edgesOf (TV vertex) {&#xA;&#x9;&#x9;&#x9;&#x9;return delegator.edgesOf (vertex);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public IEnumerator&lt;TE> iteratorEdgesOf (TV vertex) {&#xA;&#x9;&#x9;&#x9;&#x9;return delegator.iteratorEdgesOf (vertex);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public ICollection&lt;TV> neighborsOf (TV vertex){&#xA;&#x9;&#x9;&#x9;&#x9;ICollection&lt;KeyValuePair&lt;TV, float>> i = delegator.incoming&lt;KeyValuePair&lt;TV, float>> (vertex);&#xA;&#x9;&#x9;&#x9;&#x9;ICollection&lt;TV> edges = new HashSet&lt;TV> ();&#xA;&#x9;&#x9;&#x9;&#x9;foreach (KeyValuePair&lt;TV, float> kv in i)&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;edges.Add (kv.Key);&#xA;&#x9;&#x9;&#x9;&#x9;ICollection&lt;KeyValuePair&lt;TV, float>> o = delegator.outgoing&lt;KeyValuePair&lt;TV, float>> (vertex);&#xA;&#x9;&#x9;&#x9;&#x9;foreach (KeyValuePair&lt;TV, float> kv in o)&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;edges.Add (kv.Key);&#xA;&#x9;&#x9;&#x9;&#x9;return edges;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public IEnumerator&lt;TV> iteratorNeighborsOf (TV vertex){&#xA;&#x9;&#x9;&#x9;&#x9;ICollection&lt;KeyValuePair&lt;TV, float>> o = delegator.outgoing&lt;KeyValuePair&lt;TV, float>> (vertex);&#xA;&#x9;&#x9;&#x9;&#x9;ICollection&lt;KeyValuePair&lt;TV, float>> i = delegator.incoming&lt;KeyValuePair&lt;TV, float>> (vertex);&#xA;//&#x9;&#x9;&#x9;&#x9;ICollection&lt;TV> edges = new HashSet&lt;TV> ();&#xA;//&#x9;&#x9;&#x9;&#x9;if (!delegator.Container.AllowingMultipleEdges) {&#xA;//&#x9;&#x9;&#x9;&#x9;&#x9;foreach (KeyValuePair&lt;TV, float> kv in o)&#xA;//&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (!edges.Contains (kv.Key)) {&#xA;//&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;edges.Add (kv.Key);&#xA;//&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;yield return kv.Key;&#xA;//&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;//&#x9;&#x9;&#x9;&#x9;&#x9;foreach(KeyValuePair&lt;TV, float> kv in i)&#xA;//&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (!edges.Contains (kv.Key)) {&#xA;//&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;edges.Add (kv.Key);&#xA;//&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;yield return kv.Key;&#xA;//&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;//&#x9;&#x9;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;foreach(KeyValuePair&lt;TV, float> kv in o) yield return kv.Key;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;foreach(KeyValuePair&lt;TV, float> kv in i) yield return kv.Key;&#xA;//&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;//&#xA;&#x9;&#x9;&#x9;public IEnumerator&lt;KeyValuePair&lt;TV, float>> iteratorVertexWeightOf(TV vertex){&#xA;&#x9;&#x9;&#x9;&#x9;ICollection&lt;KeyValuePair&lt;TV, float>> o = delegator.outgoing&lt;KeyValuePair&lt;TV, float>> (vertex);&#xA;&#x9;&#x9;&#x9;&#x9;ICollection&lt;KeyValuePair&lt;TV, float>> i = delegator.incoming&lt;KeyValuePair&lt;TV, float>> (vertex);&#xA;&#x9;&#x9;&#x9;&#x9;ICollection&lt;TV> edges = new HashSet&lt;TV> ();&#xA;&#x9;&#x9;&#x9;&#x9;if (!delegator.Container.AllowingMultipleEdges) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;foreach (KeyValuePair&lt;TV, float> kv in o) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;bool contain = edges.Contains (kv.Key);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (!contain) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;edges.Add (kv.Key);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;yield return kv;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;//edges.Clear ();&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;foreach (KeyValuePair&lt;TV, float> kv in i) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;bool contain = edges.Contains (kv.Key);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (!contain) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;edges.Add (kv.Key);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;yield return kv;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;foreach (KeyValuePair&lt;TV, float> kv in o) yield return kv;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;foreach (KeyValuePair&lt;TV, float> kv in i) yield return kv;&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;//&#xA;&#x9;&#x9;&#x9;public bool removeAllEdges(ICollection&lt;TE> edges){&#xA;&#x9;&#x9;&#x9;&#x9;bool modified = false;&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;foreach (TE e in edges) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;modified |= removeEdge(e);&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;return modified;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public ICollection&lt;TE> removeAllEdges(TV sourceVertex, TV targetVertex){&#xA;&#x9;&#x9;&#x9;&#x9;ICollection&lt;TE> removed = getAllEdges(sourceVertex, targetVertex);&#xA;&#x9;&#x9;&#x9;&#x9;if (removed == null) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;return null;&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;removeAllEdges(removed);&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;return removed;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public bool removeAllVertices(ICollection&lt;TV> vertices){&#xA;&#x9;&#x9;&#x9;&#x9;bool modified = false;&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;foreach (TV v in vertices) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;modified |= removeVertex(v);&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;return modified;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public TE removeEdge (TV sourceVertex, TV targetVertex) {&#xA;&#x9;&#x9;&#x9;&#x9;TE e = getEdge (sourceVertex, targetVertex);&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;if (e != null) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;removeEdgeFromContainer (e);&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;return e;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public bool removeEdge (TE e) {&#xA;&#x9;&#x9;&#x9;&#x9;if (containsEdge (e)) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;removeEdgeFromContainer (e);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;return true;&#xA;&#x9;&#x9;&#x9;&#x9;} &#xA;&#x9;&#x9;&#x9;&#x9;else { return false; }&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public bool removeVertex (TV v) {&#xA;&#x9;&#x9;&#x9;&#x9;if (containsVertex (v)) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;ICollection&lt;TE> edges = edgesOf (v);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;foreach (TE e in edges) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;removeEdgeFromContainer (e);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;return delegator.removeVertex (v);&#xA;&#x9;&#x9;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;return false;&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public ICollection&lt;TV> vertexSet () {&#xA;&#x9;&#x9;&#x9;&#x9;return delegator.vertexSet ();&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public TV getEdgeSource (TE e) {&#xA;&#x9;&#x9;&#x9;&#x9;return e.Source;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public TV getEdgeTarget (TE e) {&#xA;&#x9;&#x9;&#x9;&#x9;return e.Target;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public float getEdgeWeight (TE e) {&#xA;&#x9;&#x9;&#x9;&#x9;return getEdgeWeight (e.Source, e.Target);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public void setAllEdgeWeight (TE e, float weight) {&#xA;&#x9;&#x9;&#x9;&#x9;setAllEdgeWeight (e.Source, e.Target, weight);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public void setAllEdgeWeight (TV sourceVertex, TV targetVertex, float weight){&#xA;&#x9;&#x9;&#x9;&#x9;if (delegator.Container.AllowingMultipleEdges) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;ICollection&lt;TE> list = this.getAllEdges (sourceVertex, targetVertex);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;removeAllEdges (list);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;foreach (TE ei in list) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;addEdgeToContainer ( (TE) delegator.Container.EdgeFactory.newInstance(sourceVertex, targetVertex, weight));&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;bool b = removeEdge (sourceVertex, targetVertex)!=null;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if (b) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;addEdgeToContainer ( (TE) delegator.Container.EdgeFactory.newInstance(sourceVertex, targetVertex, weight));&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public float getEdgeWeight (TV sourceVertex, TV targetVertex){&#xA;&#x9;&#x9;&#x9;&#x9;TE e = this.getEdge (sourceVertex, targetVertex);&#xA;&#x9;&#x9;&#x9;&#x9;if (e != null) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;return e.Weight;&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;return 0f;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;// End interface implements&#xA;&#xA;&#x9;&#x9;&#x9;public bool isAllowingLoops () { return delegator.Container.AllowingLoops; }&#xA;&#x9;&#x9;&#x9;public bool isAllowingMultipleEdges () { return delegator.Container.AllowingMultipleEdges; }&#xA;&#xA;&#x9;&#x9;&#x9;#region ICloneable implementation&#xA;&#x9;&#x9;&#x9;public object Clone () {&#xA;&#x9;&#x9;&#x9;&#x9;IGraphHelperKV&lt;V, E, TV, TE> d = (IGraphHelperKV&lt;V, E, TV, TE>) this.delegator.Clone ();&#xA;&#x9;&#x9;&#x9;&#x9;IUndirectedGraphKVWeightedInstanceImpl&lt;V, E, TV, TE> clone = new IUndirectedGraphKVWeightedInstanceImpl&lt;V, E, TV, TE>(d);&#xA;&#x9;&#x9;&#x9;&#x9;return clone;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;#endregion&#xA;&#xA;&#x9;&#x9;&#x9;public override string ToString () { &#xA;&#x9;&#x9;&#x9;&#x9;IEnumerator&lt;TV> vertexSet = this.vertexSet ().GetEnumerator();&#xA;&#x9;&#x9;&#x9;&#x9;IEnumerator&lt;TE> edgeSet = this.edgeSet ();&#xA;&#x9;&#x9;&#x9;&#x9;System.Text.StringBuilder sb = new System.Text.StringBuilder();&#xA;&#x9;&#x9;&#x9;&#x9;String ret = &quot;&quot;;&#xA;&#x9;&#x9;&#x9;&#x9;sb.Append (&quot;Vertexs [&quot;);&#xA;&#x9;&#x9;&#x9;&#x9;for(int i = 0; vertexSet.MoveNext();i++){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;sb.Append (vertexSet.Current.ToString ()+&quot;,&quot;);&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;sb.Remove (sb.Length-1, 1);&#xA;&#x9;&#x9;&#x9;&#x9;sb.Append(&quot;]&quot;);&#xA;&#x9;&#x9;&#x9;&#x9;sb.AppendLine();&#xA;&#x9;&#x9;&#x9;&#x9;sb.Append(&quot;edges&quot;);&#xA;&#x9;&#x9;&#x9;&#x9;for (int i=0; edgeSet.MoveNext(); i++) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;sb.Append(&quot;(&quot;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;sb.Append (edgeSet.Current.ToString());&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;sb.Append(&quot;) &quot;);&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;ret = sb.ToString ();&#xA;&#x9;&#x9;&#x9;&#x9;sb.Clear ();&#xA;&#x9;&#x9;&#x9;&#x9;return ret;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public void noSafeAdd(TE e){&#xA;&#x9;&#x9;&#x9;&#x9;delegator.noSafeAdd (e);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public void noSafeAdd(TV source, TV target){&#xA;&#x9;&#x9;&#x9;&#x9;delegator.noSafeAdd (source, target);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public void noSafeAdd(TV source, TV target, float weight){&#xA;&#x9;&#x9;&#x9;&#x9;delegator.noSafeAdd (source, target, weight);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public void addEdgeToContainer (TE e) {&#xA;&#x9;&#x9;&#x9;&#x9;delegator.addOutgoingEdge (e);&#xA;&#x9;&#x9;&#x9;&#x9;delegator.addIncomingEdge (e);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public void removeEdgeFromContainer (TE e) {&#xA;&#x9;&#x9;&#x9;&#x9;delegator.removeOutgoingEdge (e);&#xA;&#x9;&#x9;&#x9;&#x9;delegator.removeIncomingEdge (e);&#xA;&#x9;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;&#x9;private bool isEqualsStraightOrInverted (Object sourceVertex, Object targetVertex, TE e) {&#xA;&#x9;&#x9;&#x9;&#x9;bool equalStraight = sourceVertex.Equals (e.Source) &amp;&amp; targetVertex.Equals (e.Target);&#xA;&#x9;&#x9;&#x9;&#x9;bool equalInverted = sourceVertex.Equals (e.Target) &amp;&amp; targetVertex.Equals (e.Source);&#xA;&#x9;&#x9;&#x9;&#x9;return equalStraight || equalInverted;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public int degreeOf (TV vertex) {&#xA;&#x9;&#x9;&#x9;&#x9;if (delegator.Container.AllowingLoops) {&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;int degree = 0;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;ICollection&lt;TE> edges = edgesOf (vertex);&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;foreach (TE e in edges) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (e.Source.Equals (e.Target)) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;degree += 2;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;degree += 1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;return degree;&#xA;&#x9;&#x9;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;return delegator.degreeOf (vertex);&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public int countE() { return delegator.countE(); }&#xA;&#x9;&#x9;&#x9;public int countV() { return delegator.countV(); }&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;public interface IGraphHelperKV&lt;V, E, TV, TE>: IGraphHelper&lt;V, E, TV, TE> &#xA;&#x9;&#x9;&#x9;where V:IVertex where E:IEdge&lt;V> where TE: IEdgeInstance&lt;V, TV> {&#xA;&#x9;&#x9;&#x9;IDataContainerKVInstance&lt;V, E, TV, TE> Container { get; set; }&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;internal class IGraphHelperKVImpl&lt;V, E, TV, TE>: IGraphHelperKV&lt;V, E, TV, TE> &#xA;&#x9;&#x9;&#x9;where V:IVertex &#xA;&#x9;&#x9;&#x9;where E:IEdge&lt;V>&#xA;&#x9;&#x9;&#x9;where TE: IEdgeInstance&lt;V, TV> {&#xA;&#xA;&#x9;&#x9;&#x9;private int count_edges = 0;&#xA;&#x9;&#x9;&#x9;private IDataContainerKVInstance&lt;V, E, TV, TE> container;&#xA;&#xA;&#x9;&#x9;&#x9;public IGraphHelperKVImpl (IDataContainerKVInstance&lt;V, E, TV, TE> c) {&#xA;&#x9;&#x9;&#x9;&#x9;container = c;&#xA;&#x9;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;&#x9;public IDataContainerKVInstance&lt;V, E, TV, TE> Container{&#xA;&#x9;&#x9;&#x9;&#x9;get{ return this.container; }&#xA;&#x9;&#x9;&#x9;&#x9;set{ this.container = (IDataContainerKVInstance&lt;V, E, TV, TE>)value; }&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public IDataContainerInstance&lt;V, E> DataContainer{&#xA;&#x9;&#x9;&#x9;&#x9;get{ return this.container; }&#xA;&#x9;&#x9;&#x9;&#x9;set{ this.container = (IDataContainerKVInstance&lt;V, E, TV, TE>)value; }&#xA;&#x9;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;&#x9;#region ICloneable implementation&#xA;&#x9;&#x9;&#x9;public object Clone () {&#xA;&#x9;&#x9;&#x9;&#x9;IDataContainerKVInstance&lt;V, E, TV, TE> c = (IDataContainerKVInstance&lt;V, E, TV, TE>) this.Container.Clone ();&#xA;&#x9;&#x9;&#x9;&#x9;IGraphHelperKVImpl&lt;V, E, TV, TE> clone = new IGraphHelperKVImpl&lt;V, E, TV, TE> (c);&#xA;&#x9;&#x9;&#x9;&#x9;clone.count_edges = this.count_edges;&#xA;&#x9;&#x9;&#x9;&#x9;return clone;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;#endregion&#xA;&#xA;&#x9;&#x9;&#x9;// ************************* implements ***********************************&#xA;&#x9;&#x9;&#x9;public IEnumerator&lt;TE> edgeSet () {&#xA;&#x9;&#x9;&#x9;&#x9;ICollection&lt;TV> collection = container.DataSet.Keys;&#xA;&#x9;&#x9;&#x9;&#x9;foreach (TV v in collection) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;IEdgeContainer&lt;KeyValuePair&lt;TV, float>> ec = container.DataSet[v];&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;IEnumerator&lt;KeyValuePair&lt;TV, float>> iterator = ec.outgoing.GetEnumerator();&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;while (iterator.MoveNext ()) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;yield return (TE) container.EdgeFactory.newInstance (v, iterator.Current.Key, iterator.Current.Value);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public ICollection&lt;TE> edgesOf (TV vertex) {&#xA;&#x9;&#x9;&#x9;&#x9;IEdgeContainer&lt;KeyValuePair&lt;TV, float>> ec;&#xA;&#x9;&#x9;&#x9;&#x9;ICollection&lt;TE> edges;&#xA;&#x9;&#x9;&#x9;&#x9;if (!container.AllowingMultipleEdges)&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;edges = new HashSet&lt;TE> ();&#xA;&#x9;&#x9;&#x9;&#x9;else&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;edges = new List&lt;TE> ();&#xA;&#x9;&#x9;&#x9;&#x9;if (container.DataSet.TryGetValue (vertex, out ec)) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;foreach (KeyValuePair&lt;TV, float> kv in ec.outgoing) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;edges.Add ((TE) container.EdgeFactory.newInstance (vertex, kv.Key, kv.Value));&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;foreach (KeyValuePair&lt;TV, float> kv in ec.incoming)&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if(!vertex.Equals(kv.Key)) edges.Add ((TE) container.EdgeFactory.newInstance (kv.Key, vertex, kv.Value));&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;return edges;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public IEnumerator&lt;TE> iteratorEdgesOf (TV vertex) {&#xA;&#x9;&#x9;&#x9;&#x9;IEdgeContainer&lt;KeyValuePair&lt;TV, float>> ec;&#xA;&#x9;&#x9;&#x9;&#x9;if (container.DataSet.TryGetValue (vertex, out ec)) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;foreach (KeyValuePair&lt;TV, float> kv in ec.outgoing) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;yield return ((TE) container.EdgeFactory.newInstance (vertex, kv.Key, kv.Value));&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;foreach (KeyValuePair&lt;TV, float> kv in ec.incoming)&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if(!vertex.Equals(kv.Key)) yield return ((TE) container.EdgeFactory.newInstance (kv.Key, vertex, kv.Value));&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public ICollection&lt;TV> vertexSet () {&#xA;&#x9;&#x9;&#x9;&#x9;return container.DataSet.Keys;&#xA;&#x9;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;&#x9;public void addIncomingEdge (TE e) {//if (container.DataSet.ContainsKey (e.target))&#xA;&#x9;&#x9;&#x9;&#x9;if (!e.Source.Equals (e.Target)) { &#xA;&#x9;&#x9;&#x9;&#x9;&#x9;KeyValuePair&lt;TV, float> kv = new KeyValuePair&lt;TV, float>(e.Source, e.Weight);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;container.DataSet [e.Target].incoming.Add (kv);&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public void addOutgoingEdge (TE e) { //if (container.DataSet.ContainsKey (e.source))&#xA;&#x9;&#x9;&#x9;&#x9;KeyValuePair&lt;TV, float> kv = new KeyValuePair&lt;TV, float>(e.Target, e.Weight);&#xA;&#x9;&#x9;&#x9;&#x9;container.DataSet [e.Source].outgoing.Add (kv);&#xA;&#x9;&#x9;&#x9;&#x9;count_edges++;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public void removeIncomingEdge (TE e) { //if (container.DataSet.ContainsKey (e.target))&#xA;&#x9;&#x9;&#x9;&#x9;KeyValuePair&lt;TV, float> kv = new KeyValuePair&lt;TV, float>(e.Source, e.Weight);&#xA;&#x9;&#x9;&#x9;&#x9;container.DataSet [e.Target].incoming.Remove (kv);&#xA;&#x9;&#x9;&#x9;&#x9;count_edges--;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public void removeOutgoingEdge (TE e) { //if (container.DataSet.ContainsKey (e.source))&#xA;&#x9;&#x9;&#x9;&#x9;KeyValuePair&lt;TV, float> kv = new KeyValuePair&lt;TV, float>(e.Target, e.Weight);&#xA;&#x9;&#x9;&#x9;&#x9;container.DataSet [e.Source].outgoing.Remove (kv);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public void noSafeAdd(TE e){&#xA;&#x9;&#x9;&#x9;&#x9;if (!containsEdge(e)) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;KeyValuePair&lt;TV, float> kv_ou = new KeyValuePair&lt;TV, float>(e.Target, e.Weight);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;container.DataSet [e.Source].outgoing.Add (kv_ou);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if (!e.Source.Equals (e.Target)) { &#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;KeyValuePair&lt;TV, float> kv_in = new KeyValuePair&lt;TV, float>(e.Source, e.Weight);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;container.DataSet [e.Target].incoming.Add (kv_in);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;count_edges++;&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public void noSafeAdd(TV source, TV target){&#xA;&#x9;&#x9;&#x9;&#x9;KeyValuePair&lt;TV, float> kv_ou = new KeyValuePair&lt;TV, float>(target, 1.0f);&#xA;&#x9;&#x9;&#x9;&#x9;KeyValuePair&lt;TV, float> kv_in = new KeyValuePair&lt;TV, float>(source, 1.0f);&#xA;&#x9;&#x9;&#x9;&#x9;bool b = container.DataSet [source].outgoing.Contains (kv_ou) || container.DataSet [target].outgoing.Contains (kv_in);&#xA;&#x9;&#x9;&#x9;&#x9;if (!b) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;container.DataSet [source].outgoing.Add (kv_ou);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if (!source.Equals (target)) { &#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;container.DataSet [target].incoming.Add (kv_in);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;count_edges++;&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public void noSafeAdd(TV source, TV target, float weight){&#xA;&#x9;&#x9;&#x9;&#x9;KeyValuePair&lt;TV, float> kv_ou = new KeyValuePair&lt;TV, float>(target, weight);&#xA;&#x9;&#x9;&#x9;&#x9;KeyValuePair&lt;TV, float> kv_in = new KeyValuePair&lt;TV, float>(source, weight);&#xA;&#x9;&#x9;&#x9;&#x9;bool b = container.DataSet [source].outgoing.Contains (kv_ou) || container.DataSet [target].outgoing.Contains (kv_in);&#xA;&#x9;&#x9;&#x9;&#x9;if (!b) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;container.DataSet [source].outgoing.Add (kv_ou);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if (!source.Equals (target)) { &#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;container.DataSet [target].incoming.Add (kv_in);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;count_edges++;&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public ICollection&lt;T> incoming&lt;T>(TV vertex){&#xA;&#x9;&#x9;&#x9;&#x9;IEdgeContainer&lt;KeyValuePair&lt;TV, float>> ec;&#xA;&#x9;&#x9;&#x9;&#x9;if (container.DataSet.TryGetValue (vertex, out ec))&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;return ((List&lt;T>)ec.incoming).AsReadOnly();&#xA;&#x9;&#x9;&#x9;&#x9;return new List&lt;T>().AsReadOnly();&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public ICollection&lt;T> outgoing&lt;T>(TV vertex){&#xA;&#x9;&#x9;&#x9;&#x9;IEdgeContainer&lt;KeyValuePair&lt;TV, float>> ec;&#xA;&#x9;&#x9;&#x9;&#x9;if (container.DataSet.TryGetValue (vertex, out ec))&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;return ((List&lt;T>)ec.outgoing).AsReadOnly();&#xA;&#x9;&#x9;&#x9;&#x9;return new List&lt;T>().AsReadOnly();&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public bool addVertex (TV vertex) {&#xA;&#x9;&#x9;&#x9;&#x9;if (container.DataSet.ContainsKey (vertex)) return false;&#xA;&#x9;&#x9;&#x9;&#x9;else { &#xA;&#x9;&#x9;&#x9;&#x9;&#x9;IEdgeContainer&lt;KeyValuePair&lt;TV, float>> ec = new EdgeContainer&lt;KeyValuePair&lt;TV, float>>(); &#xA;&#x9;&#x9;&#x9;&#x9;&#x9;ec.outgoing = new List&lt;KeyValuePair&lt;TV, float>> ();&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;ec.incoming = new List&lt;KeyValuePair&lt;TV, float>> ();&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;container.DataSet[vertex] = ec;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;return true; &#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public bool containsEdge(TE e){&#xA;&#x9;&#x9;&#x9;&#x9;KeyValuePair&lt;TV, float> kv_ou = new KeyValuePair&lt;TV, float>(e.Target, e.Weight);&#xA;&#x9;&#x9;&#x9;&#x9;KeyValuePair&lt;TV, float> kv_in = new KeyValuePair&lt;TV, float>(e.Source, e.Weight);&#xA;&#x9;&#x9;&#x9;&#x9;return container.DataSet [e.Source].outgoing.Contains (kv_ou) || container.DataSet [e.Target].outgoing.Contains (kv_in);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public bool containsVertex (TV v){&#xA;&#x9;&#x9;&#x9;&#x9;return container.DataSet.ContainsKey (v);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public bool removeVertex (TV v) {&#xA;&#x9;&#x9;&#x9;&#x9;return container.DataSet.Remove (v);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public int countE() { return count_edges; }&#xA;&#x9;&#x9;&#x9;public int countV() { return container.DataSet.Count; }&#xA;&#x9;&#x9;&#x9;public int degreeOf(TV v) { &#xA;&#x9;&#x9;&#x9;&#x9;IEdgeContainer&lt;KeyValuePair&lt;TV, float>> ec; &#xA;&#x9;&#x9;&#x9;&#x9;if (container.DataSet.TryGetValue (v, out ec)) &#xA;&#x9;&#x9;&#x9;&#x9;&#x9;return ec.outgoing.Count + ec.incoming.Count; &#xA;&#x9;&#x9;&#x9;&#x9;return 0; &#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;}&#xA;" name="IUndirectedGraphKVWeightedImpl.cs" srcType="user" uri="br.ufc.mdcc.hpcshelf.gust.graph.impl.UndirectedGraphKVWeightedImpl/bin/1.0.0.0/IUndirectedGraphKVWeightedImpl.dll" versionId="1.0.0.0">
          <dependency>br.ufc.mdcc.hpcshelf.gust.graph.container.DataContainerKV/bin/1.0.0.0/IDataContainerKV.dll</dependency>
          <dependency>br.ufc.mdcc.hpcshelf.gust.graph.Vertex/bin/1.0.0.0/IVertex.dll</dependency>
          <dependency>br.ufc.mdcc.hpcshelf.gust.graph.Edge/bin/1.0.0.0/IEdge.dll</dependency>
          <dependency>%WORKSPACE/br.ufc.mdcc.hpcshelf.gust.graph.impl.UndirectedGraphKVWeightedImpl/bin/1.0.0.0/BaseIUndirectedGraphKVWeightedImpl.dll</dependency>
          <dependency>br.ufc.mdcc.hpcshelf.gust.graph.UndirectedGraph/bin/1.0.0.0/IUndirectedGraph.dll</dependency>
        </file>
      </sources>
      <visualDescription h="40" w="277" x="113" y="141">
        <color b="207" g="159" r="114"/>
      </visualDescription>
      <parameter iname="IDataContainerKV" order="0" parid="container" uname="data" varid="CTN"/>
      <parameter iname="IEdge" order="2" parid="edge_type" uname="data" varid="E"/>
      <parameter iname="IVertex" order="1" parid="vertex_type" uname="data" varid="V"/>
    </interface>
    <unit facet="0" iRef="IUndirectedGraphKVWeightedImpl" multiple="false" private="false" replica="0" uRef="data" visibleInterface="true">
      <super cRef="base" uRef="data"/>
      <visualDescription h="40" w="80" x="301" y="213"/>
    </unit>
  </componentInfo>
</component:component>