<?xml version="1.0" encoding="ASCII"?>
<component:component xmlns:component="http://www.example.org/HashComponent">
  <header hash_component_UID="00240000048000009400000006020000002400005253413100040000110000009f6131d3287c6db2f35fdfe09f2dbce2459cc959908ce67f82776f01fd20fa659317bbf334956d70a7ba173ec69f3e2fb6e8e7939279997f79b20ab9d88bfb2d755bdc99b00cb58959532148e8dbfe4e49ca265d95b63a1553896712e11c5e9d04ef2f846fee5f3c76e3b6755a2bb9568f306c61d872901acbf36a83ff900f88" isAbstract="false" kind="Data" name="DirectedGraphVImpl" packagePath="br.ufc.mdcc.hpcshelf.gust.graph.impl">
    <baseType>
      <extensionType>
        <implements>true</implements>
      </extensionType>
      <component hash_component_UID="00240000048000009400000006020000002400005253413100040000110000003191befb441a3dd4290d22e1af11b908c913fc2f864e5110035cd463b09c5d5d00001114c7cb0f198876af07c4319730d25069d71f17176d371a311cdc36b49e1ba4a7ed7086522ba522fd6a274ce23247fa9e59ef889852cb23de1e02887a04a735bff8e98162e81418287948b3bebe1af09ab1cdc6ecc18044070e7819bead" localRef="base" location="br.ufc.mdcc.hpcshelf.gust.graph.DirectedGraph/DirectedGraph.hpe" name="DirectedGraph" package="br.ufc.mdcc.hpcshelf.gust.graph" version="1.0.0.0">
        <visualDescription h="60" w="100" x="405" y="324">
          <color b="255" g="255" r="255"/>
        </visualDescription>
        <parameter formFieldId="container" varName="CTN"/>
        <parameter formFieldId="vertex_type" varName="V"/>
        <parameter formFieldId="edge_type" varName="E"/>
        <unitBounds facet="0" facet_instance="0" facet_instance_enclosing="0" parallel="false" uRef="data">
          <visualDescription h="20" w="20" x="5" y="2"/>
        </unitBounds>
      </component>
    </baseType>
    <versions field1="1" field2="0" field3="0" field4="0"/>
    <visualAttributes>
      <color b="255" g="255" r="255"/>
    </visualAttributes>
    <facet_configuration facet="0" multiple="false"/>
  </header>
  <componentInfo>
    <innerComponent localRef="v" location="br.ufc.mdcc.hpcshelf.gust.graph.Vertex/Vertex.hpe" multiple="false" name="Vertex" package="br.ufc.mdcc.hpcshelf.gust.graph" exposed="true">
      <visualDescription h="60" w="142" x="170" y="340">
        <color b="255" g="255" r="255"/>
      </visualDescription>
      <unitBounds facet="0" facet_instance="0" parallel="false" uRef="data">
        <visualDescription h="20" w="20" x="5" y="2"/>
      </unitBounds>
    </innerComponent>
    <innerComponent localRef="e" location="br.ufc.mdcc.hpcshelf.gust.graph.Edge/Edge.hpe" multiple="false" name="Edge" package="br.ufc.mdcc.hpcshelf.gust.graph" exposed="true">
      <visualDescription h="60" w="161" x="609" y="289">
        <color b="255" g="255" r="255"/>
      </visualDescription>
      <parameter formFieldId="vertex_type" varName="V"/>
      <unitBounds facet="0" facet_instance="0" parallel="false" uRef="data">
        <visualDescription h="20" w="20" x="5" y="2"/>
      </unitBounds>
    </innerComponent>
    <innerComponent localRef="ctn" location="br.ufc.mdcc.hpcshelf.gust.graph.container.DataContainerV/DataContainerV.hpe" multiple="false" name="DataContainerV" package="br.ufc.mdcc.hpcshelf.gust.graph.container" exposed="true">
      <visualDescription h="60" w="187" x="339" y="456">
        <color b="255" g="255" r="255"/>
      </visualDescription>
      <parameter formFieldId="vertex_type" varName="V"/>
      <parameter formFieldId="edge_type" varName="E"/>
      <unitBounds facet="0" facet_instance="0" parallel="false" uRef="data">
        <visualDescription h="20" w="20" x="5" y="2"/>
      </unitBounds>
    </innerComponent>
    <supplyParameter cRef="v" direct="true" varName="V"/>
    <supplyParameter cRef="e" direct="true" varName="E"/>
    <supplyParameter cRef="ctn" direct="true" varName="CTN"/>
    <interface iRef="IDirectedGraphVImpl" nArgs="3">
      <sources sourceType="C# Language" versionId="1.0.0.0">
        <file contents="/* Automatically Generated Code */&#xA;&#xA;using System;&#xA;using br.ufc.pargo.hpe.backend.DGAC;&#xA;using br.ufc.pargo.hpe.basic;&#xA;using br.ufc.pargo.hpe.kinds;&#xA;using br.ufc.mdcc.hpcshelf.gust.graph.Edge;&#xA;using br.ufc.mdcc.hpcshelf.gust.graph.Vertex;&#xA;using br.ufc.mdcc.hpcshelf.gust.graph.container.DataContainer;&#xA;using br.ufc.mdcc.hpcshelf.gust.graph.container.DataContainerV;&#xA;using br.ufc.mdcc.hpcshelf.gust.graph.DirectedGraph;&#xA;&#xA;namespace br.ufc.mdcc.hpcshelf.gust.graph.impl.DirectedGraphVImpl &#xA;{&#xA;&#x9;public abstract class BaseIDirectedGraphVImpl&lt;CTN, V, E>: DataStructure, BaseIDirectedGraph&lt;CTN, V, E>&#xA;&#x9;&#x9;where CTN:IDataContainerV&lt;V, E>&#xA;&#x9;&#x9;where V:IVertex&#xA;&#x9;&#x9;where E:IEdge&lt;V>&#xA;&#x9;{&#xA;&#x9;&#x9;private E edgeFactory = default(E);&#xA;&#xA;&#x9;&#x9;public E EdgeFactory&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;get&#xA;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;if (this.edgeFactory == null)&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;this.edgeFactory = (E) Services.getPort(&quot;edgeFactory&quot;);&#xA;&#x9;&#x9;&#x9;&#x9;return this.edgeFactory;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;private V vertex = default(V);&#xA;&#xA;&#x9;&#x9;public V Vertex&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;get&#xA;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;if (this.vertex == null)&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;this.vertex = (V) Services.getPort(&quot;vertex&quot;);&#xA;&#x9;&#x9;&#x9;&#x9;return this.vertex;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;private CTN dataContainer = default(CTN);&#xA;&#xA;&#x9;&#x9;public CTN DataContainer&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;get&#xA;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;if (this.dataContainer == null)&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;this.dataContainer = (CTN) Services.getPort(&quot;dataContainer&quot;);&#xA;&#x9;&#x9;&#x9;&#x9;return this.dataContainer;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;}" name="BaseIDirectedGraphVImpl.cs" srcType="base" uri="br.ufc.mdcc.hpcshelf.gust.graph.impl.DirectedGraphVImpl/bin/1.0.0.0/BaseIDirectedGraphVImpl.dll" versionId="1.0.0.0">
          <dependency>br.ufc.mdcc.hpcshelf.gust.graph.Edge/bin/1.0.0.0/IEdge.dll</dependency>
          <dependency>br.ufc.mdcc.hpcshelf.gust.graph.Vertex/bin/1.0.0.0/IVertex.dll</dependency>
          <dependency>br.ufc.mdcc.hpcshelf.gust.graph.container.DataContainer/bin/1.0.0.0/IDataContainer.dll</dependency>
          <dependency>br.ufc.mdcc.hpcshelf.gust.graph.container.DataContainerV/bin/1.0.0.0/IDataContainerV.dll</dependency>
          <dependency>br.ufc.mdcc.hpcshelf.gust.graph.DirectedGraph/bin/1.0.0.0/BaseIDirectedGraph.dll</dependency>
        </file>
        <file contents="using System;&#xA;using System.Collections.Generic;&#xA;using System.Linq;&#xA;using br.ufc.pargo.hpe.backend.DGAC;&#xA;using br.ufc.pargo.hpe.basic;&#xA;using br.ufc.pargo.hpe.kinds;&#xA;using br.ufc.mdcc.hpcshelf.gust.graph.container.DataContainer;&#xA;using br.ufc.mdcc.hpcshelf.gust.graph.container.DataContainerV;&#xA;using br.ufc.mdcc.hpcshelf.gust.graph.Vertex;&#xA;using br.ufc.mdcc.hpcshelf.gust.graph.Edge;&#xA;using br.ufc.mdcc.hpcshelf.gust.graph.Graph;&#xA;using br.ufc.mdcc.hpcshelf.gust.graph.DirectedGraph;&#xA;&#xA;namespace br.ufc.mdcc.hpcshelf.gust.graph.impl.DirectedGraphVImpl&#xA;{&#xA;&#x9;public class IDirectedGraphVImpl&lt;CTN, V, E> : BaseIDirectedGraphVImpl&lt;CTN, V, E>, IDirectedGraph&lt;CTN, V, E>&#xA;where CTN:IDataContainerV&lt;V, E>&#xA;where V:IVertex&#xA;where E:IEdge&lt;V> {&#xA;&#xA;&#x9;&#x9;override public void after_initialize()&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;newInstance(); &#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;public object newInstance () {&#xA;&#x9;&#x9;&#x9;return newInstance (0);&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;public object Instance {&#xA;&#x9;&#x9;&#x9;get { return graphInstanceT; }&#xA;&#x9;&#x9;&#x9;set { this.graphInstanceT = value; }&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;private object graphInstanceT = null;&#xA;&#x9;&#x9;public object GraphInstanceT { &#xA;&#x9;&#x9;&#x9;get{ &#xA;&#x9;&#x9;&#x9;&#x9;return this.graphInstanceT;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;public IDirectedGraphInstance&lt;V, E, TV, TE> newInstanceT&lt;TV, TE> (TE e, int size)  where TE: IEdgeInstance&lt;V, TV> {&#xA;&#x9;&#x9;&#x9;IDataContainerVInstance&lt;V, E, TV, TE> dc = DataContainer.InstanceTFactory&lt;TV, TE>(e);&#xA;&#x9;&#x9;&#x9;dc.newDataSet (size);&#xA;&#x9;&#x9;&#x9;IGraphHelperV&lt;V, E, TV, TE> h = new IGraphHelperVImpl&lt;V, E, TV, TE>(dc);&#xA;&#x9;&#x9;&#x9;this.graphInstanceT = new IDirectedGraphVInstanceImpl&lt;V, E, TV, TE> (h);&#xA;&#x9;&#x9;&#x9;return (IDirectedGraphInstance&lt;V, E, TV, TE>) this.graphInstanceT;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;public IDirectedGraphInstance&lt;V, E, int, IEdgeInstance&lt;V, int>> newInstance(int size) {&#xA;&#x9;&#x9;&#x9;IDataContainerVInstance&lt;V, E, int, IEdgeInstance&lt;V, int>> dc = DataContainer.DataContainerVInstance;&#xA;&#x9;&#x9;&#x9;dc.newDataSet (size);&#xA;&#x9;&#x9;&#x9;IGraphHelperV&lt;V, E, int, IEdgeInstance&lt;V, int>> h = new IGraphHelperVImpl&lt;V, E, int, IEdgeInstance&lt;V, int>>(dc);&#xA;&#x9;&#x9;&#x9;this.graphInstanceT = new IDirectedGraphVInstanceImpl&lt;V, E, int, IEdgeInstance&lt;V, int>> (h);&#xA;&#x9;&#x9;&#x9;return (IDirectedGraphInstance&lt;V, E, int, IEdgeInstance&lt;V, int>>) this.graphInstanceT;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;public class IDirectedGraphVInstanceImpl&lt;V, E, TV, TE>: IDirectedGraphInstance&lt;V, E, TV, TE> &#xA;&#x9;&#x9;&#x9;where V:IVertex  &#xA;&#x9;&#x9;&#x9;where E:IEdge&lt;V> &#xA;&#x9;&#x9;&#x9;where TE: IEdgeInstance&lt;V, TV> {&#xA;&#xA;&#x9;&#x9;&#x9;public IGraphHelperV&lt;V, E, TV, TE> delegator;&#xA;&#xA;&#x9;&#x9;&#x9;public IDataContainerInstance&lt;V, E> DataContainer{&#xA;&#x9;&#x9;&#x9;&#x9;get{ return this.delegator.Container; }&#xA;&#x9;&#x9;&#x9;&#x9;set{ this.delegator.Container = (IDataContainerVInstance&lt;V, E, TV, TE>)value; }&#xA;&#x9;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;&#x9;public IDirectedGraphVInstanceImpl(IGraphHelperV&lt;V, E, TV, TE> d){&#xA;&#x9;&#x9;&#x9;&#x9;delegator = d;&#xA;&#x9;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;&#x9;public object ObjValue {&#xA;&#x9;&#x9;&#x9;&#x9;get { return new Tuple&lt;IGraphHelperV&lt;V, E, TV, TE>>(delegator); }&#xA;&#x9;&#x9;&#x9;&#x9;set { &#xA;&#x9;&#x9;&#x9;&#x9;&#x9;this.delegator = ((Tuple&lt;IGraphHelperV&lt;V, E, TV, TE>>)value).Item1;&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;&#x9;public ICollection&lt;TE> getAllEdges (TV sourceVertex, TV targetVertex) {&#xA;&#x9;&#x9;&#x9;&#x9;ICollection&lt;TE> edges = null; &#xA;&#xA;&#x9;&#x9;&#x9;&#x9;if (containsVertex (sourceVertex) &amp;&amp; containsVertex (targetVertex)) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;edges = new List&lt;TE> ();&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;IEnumerator&lt;TV> iter = delegator.outgoing&lt;TV> (sourceVertex).GetEnumerator();&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;while (iter.MoveNext ()) {&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (iter.Current.Equals (targetVertex)) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;TE e = (TE) delegator.Container.EdgeFactory.newInstance (sourceVertex, iter.Current);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;edges.Add (e);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;return edges;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public TE getEdge (TV sourceVertex, TV targetVertex) {&#xA;&#x9;&#x9;&#x9;&#x9;if (containsVertex (sourceVertex) &amp;&amp; containsVertex (targetVertex)) {&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;IEnumerator&lt;TV> iter = delegator.outgoing&lt;TV> (sourceVertex).GetEnumerator();&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;while (iter.MoveNext ()) {&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (iter.Current.Equals (targetVertex)) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;TE e = (TE) delegator.Container.EdgeFactory.newInstance (sourceVertex, iter.Current);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;return e;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;return default(TE);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public TE addEdge (TV sourceVertex, TV targetVertex) {&#xA;&#x9;&#x9;&#x9;&#x9;if (containsVertex (sourceVertex) &amp;&amp; containsVertex (targetVertex)) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if (!delegator.Container.AllowingMultipleEdges &amp;&amp; containsEdge (sourceVertex, targetVertex)) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;return default(TE);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if (!delegator.Container.AllowingLoops &amp;&amp; sourceVertex.Equals (targetVertex)) { Console.WriteLine (&quot;LOOPS NOT ALLOWED&quot;); return default(TE); }&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;TE e = (TE) delegator.Container.EdgeFactory.newInstance (sourceVertex, targetVertex);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;addEdgeToContainer (e);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;return e;&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;return default(TE);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public bool addEdge (TE e) {&#xA;&#x9;&#x9;&#x9;&#x9;if (e == null || e.Source == null || e.Target == null) { &#xA;&#x9;&#x9;&#x9;&#x9;&#x9;return false; &#xA;&#x9;&#x9;&#x9;&#x9;} &#xA;&#x9;&#x9;&#x9;&#x9;if (containsVertex (e.Source) &amp;&amp; containsVertex (e.Target)) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if (!delegator.Container.AllowingMultipleEdges &amp;&amp; containsEdge (e.Source, e.Target)) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;return false;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if (!delegator.Container.AllowingLoops &amp;&amp; e.Source.Equals (e.Target)) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;Console.WriteLine (&quot;LOOPS NOT ALLOWED&quot;);  &#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;return false; &#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;addEdgeToContainer (e);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;return true;&#xA;&#x9;&#x9;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;return false;&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public bool addVertex (TV v) {&#xA;&#x9;&#x9;&#x9;&#x9;return delegator.addVertex (v);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public bool containsEdge(TV sourceVertex, TV targetVertex){&#xA;&#x9;&#x9;&#x9;&#x9;return delegator.outgoing&lt;TV> (sourceVertex).Contains (targetVertex);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public bool containsEdge(TE e){&#xA;&#x9;&#x9;&#x9;&#x9;if (e != null) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if (containsVertex (e.Source) &amp;&amp; containsVertex (e.Target))&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;return delegator.outgoing&lt;TV> (e.Source).Contains (e.Target);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;else&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;return false;&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;return false;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public bool containsVertex (TV v){&#xA;&#x9;&#x9;&#x9;&#x9;if (v == null) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;Console.WriteLine (&quot;WARNING: containsVertex(PARAMETER NULL!) &quot;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;return false;&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;return delegator.containsVertex (v);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public IEnumerator&lt;TE> edgeSet () {&#xA;&#x9;&#x9;&#x9;&#x9;return delegator.edgeSet ();&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public ICollection&lt;TE> edgesOf (TV vertex) {&#xA;&#x9;&#x9;&#x9;&#x9;return delegator.edgesOf (vertex);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public IEnumerator&lt;TE> iteratorEdgesOf (TV vertex) {&#xA;&#x9;&#x9;&#x9;&#x9;return delegator.iteratorEdgesOf (vertex);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public ICollection&lt;TV> neighborsOf (TV vertex){&#xA;&#x9;&#x9;&#x9;&#x9;ICollection&lt;TV> o = delegator.outgoing&lt;TV> (vertex);&#xA;&#x9;&#x9;&#x9;&#x9;ICollection&lt;TV> i = delegator.incoming&lt;TV> (vertex);&#xA;&#x9;&#x9;&#x9;&#x9;return new HashSet&lt;TV> (o.Union (i));&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public bool removeAllEdges(ICollection&lt;TE> edges){&#xA;&#x9;&#x9;&#x9;&#x9;bool modified = false;&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;foreach (TE e in edges) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;modified |= removeEdge(e);&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;return modified;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public ICollection&lt;TE> removeAllEdges(TV sourceVertex, TV targetVertex){&#xA;&#x9;&#x9;&#x9;&#x9;ICollection&lt;TE> removed = getAllEdges(sourceVertex, targetVertex);&#xA;&#x9;&#x9;&#x9;&#x9;if (removed == null) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;return null;&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;removeAllEdges(removed);&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;return removed;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public bool removeAllVertices(ICollection&lt;TV> vertices){&#xA;&#x9;&#x9;&#x9;&#x9;bool modified = false;&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;foreach (TV v in vertices) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;modified |= removeVertex(v);&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;return modified;&#xA;&#x9;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;&#x9;public TE removeEdge (TV sourceVertex, TV targetVertex) {&#xA;&#x9;&#x9;&#x9;&#x9;TE e = getEdge (sourceVertex, targetVertex);&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;if (e != null) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;removeEdgeFromContainer (e);&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;return e;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public bool removeEdge (TE e) {&#xA;&#x9;&#x9;&#x9;&#x9;if (containsEdge (e)) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;removeEdgeFromContainer (e);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;return true;&#xA;&#x9;&#x9;&#x9;&#x9;} &#xA;&#x9;&#x9;&#x9;&#x9;else { return false; }&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public bool removeVertex (TV v) {&#xA;&#x9;&#x9;&#x9;&#x9;if (containsVertex (v)) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;ICollection&lt;TE> edges = edgesOf (v);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;foreach (TE e in edges) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;removeEdgeFromContainer (e);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;return delegator.removeVertex (v);&#xA;&#x9;&#x9;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;return false;&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public ICollection&lt;TV> vertexSet () {&#xA;&#x9;&#x9;&#x9;&#x9;return delegator.vertexSet ();&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public TV getEdgeSource (TE e) {&#xA;&#x9;&#x9;&#x9;&#x9;return e.Source;&#xA;&#x9;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;&#x9;public TV getEdgeTarget (TE e) {&#xA;&#x9;&#x9;&#x9;&#x9;return e.Target; &#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public float getEdgeWeight (TE e) {&#xA;&#x9;&#x9;&#x9;&#x9;return getEdgeWeight (e.Source, e.Target);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public void setAllEdgeWeight (TE e, float weight) {&#xA;&#x9;&#x9;&#x9;&#x9;setAllEdgeWeight (e.Source, e.Target, weight);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public void setAllEdgeWeight (TV sourceVertex, TV targetVertex, float weight){&#xA;&#x9;&#x9;&#x9;&#x9;Console.WriteLine (&quot;WARNING: Operation setAllEdgeWeight not Supported&quot;);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public float getEdgeWeight (TV sourceVertex, TV targetVertex){&#xA;&#x9;&#x9;&#x9;&#x9;return delegator.Container.EdgeFactory.newInstance (sourceVertex, targetVertex).Weight;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;// end interface implements&#xA;&#xA;&#x9;&#x9;&#x9;#region ICloneable implementation&#xA;&#x9;&#x9;&#x9;public object Clone () {&#xA;&#x9;&#x9;&#x9;&#x9;IGraphHelperV&lt;V, E, TV, TE> d = (IGraphHelperV&lt;V, E, TV, TE>) this.delegator.Clone ();&#xA;&#x9;&#x9;&#x9;&#x9;IDirectedGraphVInstanceImpl&lt;V, E, TV, TE> clone = new IDirectedGraphVInstanceImpl&lt;V, E, TV, TE>(d);&#xA;&#x9;&#x9;&#x9;&#x9;return clone;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;#endregion&#xA;&#xA;&#x9;&#x9;&#x9;public bool isAllowingLoops () { return delegator.Container.AllowingLoops; }&#xA;&#xA;&#x9;&#x9;&#x9;public bool isAllowingMultipleEdges () { return delegator.Container.AllowingMultipleEdges; }&#xA;&#xA;&#x9;&#x9;&#x9;public override string ToString () { &#xA;&#x9;&#x9;&#x9;&#x9;IEnumerator&lt;TV> vertexSet = this.vertexSet ().GetEnumerator();&#xA;&#x9;&#x9;&#x9;&#x9;IEnumerator&lt;TE> edgeSet = this.edgeSet ();&#xA;&#x9;&#x9;&#x9;&#x9;System.Text.StringBuilder sb = new System.Text.StringBuilder();&#xA;&#x9;&#x9;&#x9;&#x9;String ret = &quot;&quot;;&#xA;&#x9;&#x9;&#x9;&#x9;sb.Append (&quot;Vertexs [&quot;);&#xA;&#x9;&#x9;&#x9;&#x9;for(int i = 0; vertexSet.MoveNext();i++){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;sb.Append (vertexSet.Current.ToString ()+&quot;,&quot;);&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;sb.Remove (sb.Length-1, 1);&#xA;&#x9;&#x9;&#x9;&#x9;sb.Append(&quot;]&quot;);&#xA;&#x9;&#x9;&#x9;&#x9;sb.AppendLine();&#xA;&#x9;&#x9;&#x9;&#x9;sb.Append(&quot;edges&quot;);&#xA;&#x9;&#x9;&#x9;&#x9;for (int i=0; edgeSet.MoveNext(); i++) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;sb.Append(&quot;(&quot;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;sb.Append (edgeSet.Current.ToString());&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;sb.Append(&quot;) &quot;);&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;ret = sb.ToString ();&#xA;&#x9;&#x9;&#x9;&#x9;sb.Clear ();&#xA;&#x9;&#x9;&#x9;&#x9;return ret;&#xA;&#x9;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;&#x9;public void noSafeAdd(TE e){&#xA;&#x9;&#x9;&#x9;&#x9;delegator.noSafeAdd (e);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public void noSafeAdd(TV source, TV target){&#xA;&#x9;&#x9;&#x9;&#x9;delegator.noSafeAdd (source, target);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public void noSafeAdd(TV source, TV target, float weight){&#xA;&#x9;&#x9;&#x9;&#x9;delegator.noSafeAdd (source, target, weight);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public void addEdgeToContainer (TE e) {&#xA;&#x9;&#x9;&#x9;&#x9;delegator.addOutgoingEdge (e);&#xA;&#x9;&#x9;&#x9;&#x9;delegator.addIncomingEdge (e);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public int inDegreeOf (TV vertex) {&#xA;&#x9;&#x9;&#x9;&#x9;return delegator.incoming&lt;TV> (vertex).Count;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public int outDegreeOf (TV vertex) {&#xA;&#x9;&#x9;&#x9;&#x9;return delegator.outgoing&lt;TV> (vertex).Count;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public ICollection&lt;TE> incomingEdgesOf (TV vertex) {&#xA;&#x9;&#x9;&#x9;&#x9;ICollection&lt;TV> incoming_list = delegator.incoming&lt;TV> (vertex);&#xA;&#x9;&#x9;&#x9;&#x9;ICollection&lt;TE> edges;&#xA;&#x9;&#x9;&#x9;&#x9;if (!delegator.Container.AllowingMultipleEdges)&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;edges = new HashSet&lt;TE> ();&#xA;&#x9;&#x9;&#x9;&#x9;else&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;edges = new List&lt;TE> ();&#xA;&#x9;&#x9;&#x9;&#x9;foreach (TV v in incoming_list)&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;edges.Add ((TE) delegator.Container.EdgeFactory.newInstance(v, vertex));&#xA;&#x9;&#x9;&#x9;&#x9;return edges;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public ICollection&lt;TE> outgoingEdgesOf (TV vertex) {&#xA;&#x9;&#x9;&#x9;&#x9;ICollection&lt;TV> outgoing_list = delegator.outgoing&lt;TV> (vertex);&#xA;&#x9;&#x9;&#x9;&#x9;ICollection&lt;TE> edges;&#xA;&#x9;&#x9;&#x9;&#x9;if (!delegator.Container.AllowingMultipleEdges)&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;edges = new HashSet&lt;TE> ();&#xA;&#x9;&#x9;&#x9;&#x9;else&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;edges = new List&lt;TE> ();&#xA;&#x9;&#x9;&#x9;&#x9;foreach (TV v in outgoing_list)&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;edges.Add ((TE) delegator.Container.EdgeFactory.newInstance(vertex, v));&#xA;&#x9;&#x9;&#x9;&#x9;return edges;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public IEnumerator&lt;TV> iteratorNeighborsOf (TV vertex){&#xA;&#x9;&#x9;&#x9;&#x9;ICollection&lt;TV> o = delegator.outgoing&lt;TV> (vertex);&#xA;&#x9;&#x9;&#x9;&#x9;ICollection&lt;TV> i = delegator.incoming&lt;TV> (vertex);&#xA;//&#x9;&#x9;&#x9;&#x9;ICollection&lt;TV> edges = new HashSet&lt;TV> ();&#xA;//&#x9;&#x9;&#x9;&#x9;if (!delegator.Container.AllowingMultipleEdges) {&#xA;//&#x9;&#x9;&#x9;&#x9;&#x9;foreach (TV v in o)&#xA;//&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (!edges.Contains (v)) {&#xA;//&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;edges.Add (v);&#xA;//&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;yield return v;&#xA;//&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;//&#x9;&#x9;&#x9;&#x9;&#x9;//edges.Clear ();&#xA;//&#x9;&#x9;&#x9;&#x9;&#x9;foreach(TV v in i)&#xA;//&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (!edges.Contains (v)) {&#xA;//&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;edges.Add (v);&#xA;//&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;yield return v;&#xA;//&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;//&#x9;&#x9;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;foreach(TV v in o) yield return v;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;foreach(TV v in i) yield return v;&#xA;//&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;//&#xA;&#x9;&#x9;&#x9;public IEnumerator&lt;KeyValuePair&lt;TV, float>> iteratorVertexWeightOf(TV vertex){&#xA;&#x9;&#x9;&#x9;&#x9;float weight_default = ((TE) delegator.Container.EdgeFactory.newInstance(vertex, vertex)).Weight;&#xA;&#x9;&#x9;&#x9;&#x9;IEnumerator&lt;TV> vneighbors = this.iteratorNeighborsOf (vertex);&#xA;&#x9;&#x9;&#x9;&#x9;ICollection&lt;TV> edges = new HashSet&lt;TV> ();&#xA;&#x9;&#x9;&#x9;&#x9;if (!delegator.Container.AllowingMultipleEdges) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;while (vneighbors.MoveNext()) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;KeyValuePair&lt;TV, float> kv = (new KeyValuePair&lt;TV, float>(vneighbors.Current, weight_default));&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;bool contain = edges.Contains (kv.Key);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (!contain) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;edges.Add (kv.Key);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;yield return kv;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;else&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;while (vneighbors.MoveNext())&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;yield return (new KeyValuePair&lt;TV, float>(vneighbors.Current, weight_default));&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public IEnumerator&lt;KeyValuePair&lt;TV, float>> iteratorOutgoingVertexWeightOf(TV vertex){&#xA;&#x9;&#x9;&#x9;&#x9;float weight_default = ((TE) delegator.Container.EdgeFactory.newInstance(vertex, vertex)).Weight;&#xA;&#x9;&#x9;&#x9;&#x9;ICollection&lt;TV> outgoing_list = delegator.outgoing&lt;TV> (vertex);&#xA;&#x9;&#x9;&#x9;&#x9;ICollection&lt;TV> edges;&#xA;&#x9;&#x9;&#x9;&#x9;if (!delegator.Container.AllowingMultipleEdges) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;edges = new HashSet&lt;TV> ();&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;foreach (TV v in outgoing_list) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;KeyValuePair&lt;TV, float> kv = (new KeyValuePair&lt;TV, float>(v, weight_default));&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;bool contain = edges.Contains (kv.Key);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (!contain) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;edges.Add (kv.Key);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;yield return kv;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;else&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;foreach (TV v in outgoing_list)&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;yield return (new KeyValuePair&lt;TV, float>(v, weight_default));&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public ICollection&lt;TV> outgoingVertexOf (TV vertex) {&#xA;&#x9;&#x9;&#x9;&#x9;ICollection&lt;TV> outgoing_list = delegator.outgoing&lt;TV> (vertex);&#xA;&#x9;&#x9;&#x9;&#x9;ICollection&lt;TV> edges;&#xA;&#x9;&#x9;&#x9;&#x9;if (!delegator.Container.AllowingMultipleEdges)&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;return (new HashSet&lt;TV> (outgoing_list));&#xA;&#x9;&#x9;&#x9;&#x9;else&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;return outgoing_list;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public IEnumerator&lt;TV> iteratorOutgoingVertexOf(TV vertex){&#xA;&#x9;&#x9;&#x9;&#x9;ICollection&lt;TV> outgoing_list = delegator.outgoing&lt;TV> (vertex);&#xA;&#x9;&#x9;&#x9;&#x9;ICollection&lt;TV> edges;&#xA;&#x9;&#x9;&#x9;&#x9;if (!delegator.Container.AllowingMultipleEdges) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;edges = new HashSet&lt;TV> ();&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;foreach (TV v in outgoing_list) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;bool contain = edges.Contains (v);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (!contain) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;edges.Add (v);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;yield return v;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;else&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;foreach (TV v in outgoing_list)&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;yield return v;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;//&#xA;&#x9;&#x9;&#x9;public void removeEdgeFromContainer (TE e) {&#xA;&#x9;&#x9;&#x9;&#x9;delegator.removeOutgoingEdge (e);&#xA;&#x9;&#x9;&#x9;&#x9;delegator.removeIncomingEdge (e);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public int countE() { return delegator.countE(); }&#xA;&#x9;&#x9;&#x9;public int countV() { return delegator.countV(); }&#xA;&#x9;&#x9;&#x9;public int degreeOf(TV vertex) { &#xA;&#x9;&#x9;&#x9;&#x9;return delegator.degreeOf (vertex);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;public interface IGraphHelperV&lt;V, E, TV, TE>: IGraphHelper&lt;V, E, TV, TE> &#xA;&#x9;&#x9;&#x9;where V:IVertex where E:IEdge&lt;V> where TE: IEdgeInstance&lt;V, TV> {&#xA;&#x9;&#x9;&#x9;IDataContainerVInstance&lt;V, E, TV, TE> Container { get; set; }&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;internal class IGraphHelperVImpl&lt;V, E, TV, TE>: IGraphHelperV&lt;V, E, TV, TE> &#xA;&#x9;&#x9;&#x9;where V:IVertex &#xA;&#x9;&#x9;&#x9;where E:IEdge&lt;V>&#xA;&#x9;&#x9;&#x9;where TE: IEdgeInstance&lt;V, TV> {&#xA;&#xA;&#x9;&#x9;&#x9;private int count_edges = 0;&#xA;&#x9;&#x9;&#x9;private IDataContainerVInstance&lt;V, E, TV, TE> container;&#xA;&#xA;&#x9;&#x9;&#x9;public IGraphHelperVImpl (IDataContainerVInstance&lt;V, E, TV, TE> c) {&#xA;&#x9;&#x9;&#x9;&#x9;container = c;&#xA;&#x9;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;&#x9;public IDataContainerVInstance&lt;V, E, TV, TE> Container{&#xA;&#x9;&#x9;&#x9;&#x9;get{ return this.container; }&#xA;&#x9;&#x9;&#x9;&#x9;set{ this.container = (IDataContainerVInstance&lt;V, E, TV, TE>)value; }&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public IDataContainerInstance&lt;V, E> DataContainer{&#xA;&#x9;&#x9;&#x9;&#x9;get{ return this.container; }&#xA;&#x9;&#x9;&#x9;&#x9;set{ this.container = (IDataContainerVInstance&lt;V, E, TV, TE>)value; }&#xA;&#x9;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;&#x9;#region ICloneable implementation&#xA;&#x9;&#x9;&#x9;public object Clone () {&#xA;&#x9;&#x9;&#x9;&#x9;IDataContainerVInstance&lt;V, E, TV, TE> c = (IDataContainerVInstance&lt;V, E, TV, TE>) this.Container.Clone ();&#xA;&#x9;&#x9;&#x9;&#x9;IGraphHelperVImpl&lt;V, E, TV, TE> clone = new IGraphHelperVImpl&lt;V, E, TV, TE> (c);&#xA;&#x9;&#x9;&#x9;&#x9;clone.count_edges = this.count_edges;&#xA;&#x9;&#x9;&#x9;&#x9;return clone;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;#endregion&#xA;&#xA;&#x9;&#x9;&#x9;public IEnumerator&lt;TE> edgeSet () {&#xA;&#x9;&#x9;&#x9;&#x9;ICollection&lt;TV> collection = container.DataSet.Keys;&#xA;&#x9;&#x9;&#x9;&#x9;foreach (TV v in collection) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;IEdgeContainer&lt;TV> ec = container.DataSet[v];&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;IEnumerator&lt;TV> iterator = ec.incoming.GetEnumerator();&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;while (iterator.MoveNext ()) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;yield return (TE) container.EdgeFactory.newInstance (iterator.Current, v);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public ICollection&lt;TE> edgesOf (TV vertex) {&#xA;&#x9;&#x9;&#x9;&#x9;IEdgeContainer&lt;TV> ec;&#xA;&#x9;&#x9;&#x9;&#x9;ICollection&lt;TE> edges;&#xA;&#x9;&#x9;&#x9;&#x9;if (!container.AllowingMultipleEdges)&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;edges = new HashSet&lt;TE> ();&#xA;&#x9;&#x9;&#x9;&#x9;else&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;edges = new List&lt;TE> ();&#xA;&#x9;&#x9;&#x9;&#x9;if (container.DataSet.TryGetValue (vertex, out ec)) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;foreach (TV v in ec.incoming)&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;edges.Add ((TE)container.EdgeFactory.newInstance (v, vertex));&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;foreach (TV v in ec.outgoing) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (!vertex.Equals (v))&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;edges.Add ((TE)container.EdgeFactory.newInstance (vertex, v));&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;return edges;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public IEnumerator&lt;TE> iteratorEdgesOf (TV vertex) {&#xA;&#x9;&#x9;&#x9;&#x9;IEdgeContainer&lt;TV> ec;&#xA;&#x9;&#x9;&#x9;&#x9;if (container.DataSet.TryGetValue (vertex, out ec)) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;foreach (TV v in ec.incoming)&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;yield return ((TE)container.EdgeFactory.newInstance (v, vertex));&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;foreach (TV v in ec.outgoing) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (!vertex.Equals (v))&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;yield return ((TE)container.EdgeFactory.newInstance (vertex, v));&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public ICollection&lt;TV> vertexSet () {&#xA;&#x9;&#x9;&#x9;&#x9;return container.DataSet.Keys;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public void addIncomingEdge (TE e) {&#xA;&#x9;&#x9;&#x9;&#x9;container.DataSet [e.Target].incoming.Add (e.Source); &#xA;&#x9;&#x9;&#x9;&#x9;count_edges++;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public void addOutgoingEdge (TE e) { &#xA;&#x9;&#x9;&#x9;&#x9;container.DataSet [e.Source].outgoing.Add (e.Target);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public void removeIncomingEdge (TE e) { &#xA;&#x9;&#x9;&#x9;&#x9;container.DataSet [e.Target].incoming.Remove (e.Source);&#xA;&#x9;&#x9;&#x9;&#x9;count_edges--;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public void removeOutgoingEdge (TE e) { &#xA;&#x9;&#x9;&#x9;&#x9;container.DataSet [e.Source].outgoing.Remove (e.Target); &#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public void noSafeAdd(TE e){&#xA;&#x9;&#x9;&#x9;&#x9;addOutgoingEdge (e);&#xA;&#x9;&#x9;&#x9;&#x9;addIncomingEdge (e);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public void noSafeAdd(TV source, TV target){&#xA;&#x9;&#x9;&#x9;&#x9;container.DataSet [source].outgoing.Add (target);&#xA;&#x9;&#x9;&#x9;&#x9;container.DataSet [target].incoming.Add (source); &#xA;&#x9;&#x9;&#x9;&#x9;count_edges++;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public void noSafeAdd(TV source, TV target, float weight){&#xA;&#x9;&#x9;&#x9;&#x9;new  NotSupportedException (&quot;Weight not Supported Exception!&quot;);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public ICollection&lt;T> incoming&lt;T>(TV vertex){&#xA;&#x9;&#x9;&#x9;&#x9;IEdgeContainer&lt;TV> ec;&#xA;&#x9;&#x9;&#x9;&#x9;if (container.DataSet.TryGetValue (vertex, out ec))&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;return ((List&lt;T>)ec.incoming).AsReadOnly();&#xA;&#x9;&#x9;&#x9;&#x9;return new List&lt;T>().AsReadOnly();&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public ICollection&lt;T> outgoing&lt;T>(TV vertex){&#xA;&#x9;&#x9;&#x9;&#x9;IEdgeContainer&lt;TV> ec;&#xA;&#x9;&#x9;&#x9;&#x9;if (container.DataSet.TryGetValue (vertex, out ec))&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;return ((List&lt;T>)ec.outgoing).AsReadOnly();&#xA;&#x9;&#x9;&#x9;&#x9;return new List&lt;T>().AsReadOnly();&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public bool addVertex (TV vertex) {&#xA;&#x9;&#x9;&#x9;&#x9;if (container.DataSet.ContainsKey (vertex)) return false;&#xA;&#x9;&#x9;&#x9;&#x9;else { &#xA;&#x9;&#x9;&#x9;&#x9;&#x9;IEdgeContainer&lt;TV> ec = new EdgeContainer&lt;TV>(); ec.outgoing = new List&lt;TV> (); ec.incoming = new List&lt;TV> ();&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;container.DataSet[vertex] = ec;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;return true; &#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public bool containsEdge(TE e){&#xA;&#x9;&#x9;&#x9;&#x9;return container.DataSet [e.Source].outgoing.Contains (e.Target);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public bool containsVertex (TV v){ &#xA;&#x9;&#x9;&#x9;&#x9;return container.DataSet.ContainsKey (v); &#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public bool removeVertex (TV v) { &#xA;&#x9;&#x9;&#x9;&#x9;return container.DataSet.Remove (v);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public int countE() { return count_edges; }&#xA;&#x9;&#x9;&#x9;public int countV() { return container.DataSet.Count; }&#xA;&#x9;&#x9;&#x9;public int degreeOf(TV v) { &#xA;&#x9;&#x9;&#x9;&#x9;IEdgeContainer&lt;TV> ec; &#xA;&#x9;&#x9;&#x9;&#x9;if (container.DataSet.TryGetValue (v, out ec)) &#xA;&#x9;&#x9;&#x9;&#x9;&#x9;return ec.outgoing.Count + ec.incoming.Count; &#xA;&#x9;&#x9;&#x9;&#x9;return 0; &#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;}&#xA;" name="IDirectedGraphVImpl.cs" srcType="user" uri="br.ufc.mdcc.hpcshelf.gust.graph.impl.DirectedGraphVImpl/bin/1.0.0.0/IDirectedGraphVImpl.dll" versionId="1.0.0.0">
          <dependency>br.ufc.mdcc.hpcshelf.gust.graph.container.DataContainerV/bin/1.0.0.0/IDataContainerV.dll</dependency>
          <dependency>br.ufc.mdcc.hpcshelf.gust.graph.Vertex/bin/1.0.0.0/IVertex.dll</dependency>
          <dependency>br.ufc.mdcc.hpcshelf.gust.graph.Edge/bin/1.0.0.0/IEdge.dll</dependency>
          <dependency>%WORKSPACE/br.ufc.mdcc.hpcshelf.gust.graph.impl.DirectedGraphVImpl/bin/1.0.0.0/BaseIDirectedGraphVImpl.dll</dependency>
          <dependency>br.ufc.mdcc.hpcshelf.gust.graph.DirectedGraph/bin/1.0.0.0/IDirectedGraph.dll</dependency>
        </file>
      </sources>
      <visualDescription h="40" w="193" x="141" y="160">
        <color b="207" g="159" r="114"/>
      </visualDescription>
      <parameter iname="IDataContainerV" parid="container" uname="data" varid="CTN"/>
      <parameter iname="IEdge" order="1" parid="edge_type" uname="data" varid="E"/>
      <parameter iname="IVertex" order="0" parid="vertex_type" uname="data" varid="V"/>
    </interface>
    <unit facet="0" iRef="IDirectedGraphVImpl" multiple="false" private="false" replica="0" uRef="data" visibleInterface="true">
      <super cRef="base" uRef="data"/>
      <visualDescription h="40" w="80" x="335" y="247"/>
    </unit>
  </componentInfo>
</component:component>