<?xml version="1.0" encoding="ASCII"?>
<component:component xmlns:component="http://www.example.org/HashComponent">
  <header hash_component_UID="0024000004800000940000000602000000240000525341310004000011000000f78f115c74cfd6c496898b3e09bfc9c0f5514941fca8c5b6b70a3de08961e3be77c6827458e96d8509005b27b26a8916b6b50f7eff29250e472e347bf61f7f5f6cb5aa06cfdbfc62ab8a864b3c67aa1b1f4a66a9db0e623ab884fdbb99acb77dd350e92610431c9c8b279fa11798af7fb10f9f63ba4258964fd8adc5e9ada18c" isAbstract="false" kind="Data" name="UndirectedGraphEImpl" packagePath="br.ufc.mdcc.hpcshelf.gust.graph.impl">
    <baseType>
      <extensionType>
        <implements>true</implements>
      </extensionType>
      <component hash_component_UID="0024000004800000940000000602000000240000525341310004000011000000fb4da1412c4edb36db2d6a11df0060ac38aa48d250c592357e366179f1459959fb9a88740ca1e6dd07f4b612e8d3034bb19c7b9f817af432eb194570c601ab91fcd5aa0e0ac6d648c01874c21652cff20b5eb559ff4123b0981ac926ec6bbe71b887319f36d384e02385bc456cf3b9826d2da1e053b1481a6ecd10bf7b14069b" localRef="base" location="br.ufc.mdcc.hpcshelf.gust.graph.UndirectedGraph/UndirectedGraph.hpe" name="UndirectedGraph" package="br.ufc.mdcc.hpcshelf.gust.graph" version="1.0.0.0">
        <visualDescription h="60" w="100" x="324" y="305">
          <color b="255" g="255" r="255"/>
        </visualDescription>
        <parameter formFieldId="container" varName="CTN"/>
        <parameter formFieldId="vertex_type" varName="V"/>
        <parameter formFieldId="edge_type" varName="E"/>
        <unitBounds facet="0" facet_instance="0" facet_instance_enclosing="0" parallel="false" uRef="data">
          <visualDescription h="20" w="20" x="5" y="2"/>
        </unitBounds>
      </component>
    </baseType>
    <versions field1="1" field2="0" field3="0" field4="0"/>
    <visualAttributes>
      <color b="255" g="255" r="255"/>
    </visualAttributes>
    <facet_configuration facet="0" multiple="false"/>
  </header>
  <componentInfo>
    <innerComponent localRef="v" location="br.ufc.mdcc.hpcshelf.gust.graph.Vertex/Vertex.hpe" multiple="false" name="Vertex" package="br.ufc.mdcc.hpcshelf.gust.graph" exposed="true">
      <visualDescription h="60" w="142" x="125" y="330">
        <color b="255" g="255" r="255"/>
      </visualDescription>
      <unitBounds facet="0" facet_instance="0" parallel="false" uRef="data">
        <visualDescription h="20" w="20" x="5" y="2"/>
      </unitBounds>
    </innerComponent>
    <innerComponent localRef="e" location="br.ufc.mdcc.hpcshelf.gust.graph.Edge/Edge.hpe" multiple="false" name="Edge" package="br.ufc.mdcc.hpcshelf.gust.graph" exposed="true">
      <visualDescription h="60" w="161" x="494" y="337">
        <color b="255" g="255" r="255"/>
      </visualDescription>
      <parameter formFieldId="vertex_type" varName="V"/>
      <unitBounds facet="0" facet_instance="0" parallel="false" uRef="data">
        <visualDescription h="20" w="20" x="5" y="2"/>
      </unitBounds>
    </innerComponent>
    <innerComponent localRef="ctn" location="br.ufc.mdcc.hpcshelf.gust.graph.container.DataContainerE/DataContainerE.hpe" multiple="false" name="DataContainerE" package="br.ufc.mdcc.hpcshelf.gust.graph.container" exposed="true">
      <visualDescription h="60" w="187" x="301" y="449">
        <color b="255" g="255" r="255"/>
      </visualDescription>
      <parameter formFieldId="vertex_type" varName="V"/>
      <parameter formFieldId="edge_type" varName="E"/>
      <unitBounds facet="0" facet_instance="0" parallel="false" uRef="data">
        <visualDescription h="20" w="20" x="5" y="2"/>
      </unitBounds>
    </innerComponent>
    <supplyParameter cRef="v" direct="true" varName="V"/>
    <supplyParameter cRef="e" direct="true" varName="E"/>
    <supplyParameter cRef="ctn" direct="true" varName="CTN"/>
    <interface iRef="IUndirectedGraphEImpl" nArgs="3">
      <sources sourceType="C# Language" versionId="1.0.0.0">
        <file contents="/* Automatically Generated Code */&#xA;&#xA;using System;&#xA;using br.ufc.pargo.hpe.backend.DGAC;&#xA;using br.ufc.pargo.hpe.basic;&#xA;using br.ufc.pargo.hpe.kinds;&#xA;using br.ufc.mdcc.hpcshelf.gust.graph.Edge;&#xA;using br.ufc.mdcc.hpcshelf.gust.graph.Vertex;&#xA;using br.ufc.mdcc.hpcshelf.gust.graph.container.DataContainer;&#xA;using br.ufc.mdcc.hpcshelf.gust.graph.container.DataContainerE;&#xA;using br.ufc.mdcc.hpcshelf.gust.graph.UndirectedGraph;&#xA;&#xA;namespace br.ufc.mdcc.hpcshelf.gust.graph.impl.UndirectedGraphEImpl &#xA;{&#xA;&#x9;public abstract class BaseIUndirectedGraphEImpl&lt;CTN, V, E>: DataStructure, BaseIUndirectedGraph&lt;CTN, V, E>&#xA;&#x9;&#x9;where CTN:IDataContainerE&lt;V, E>&#xA;&#x9;&#x9;where V:IVertex&#xA;&#x9;&#x9;where E:IEdge&lt;V>&#xA;&#x9;{&#xA;&#x9;&#x9;private E edgeFactory = default(E);&#xA;&#xA;&#x9;&#x9;public E EdgeFactory&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;get&#xA;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;if (this.edgeFactory == null)&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;this.edgeFactory = (E) Services.getPort(&quot;edgeFactory&quot;);&#xA;&#x9;&#x9;&#x9;&#x9;return this.edgeFactory;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;private V vertex = default(V);&#xA;&#xA;&#x9;&#x9;public V Vertex&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;get&#xA;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;if (this.vertex == null)&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;this.vertex = (V) Services.getPort(&quot;vertex&quot;);&#xA;&#x9;&#x9;&#x9;&#x9;return this.vertex;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;private CTN dataContainer = default(CTN);&#xA;&#xA;&#x9;&#x9;public CTN DataContainer&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;get&#xA;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;if (this.dataContainer == null)&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;this.dataContainer = (CTN) Services.getPort(&quot;dataContainer&quot;);&#xA;&#x9;&#x9;&#x9;&#x9;return this.dataContainer;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;}" name="BaseIUndirectedGraphEImpl.cs" srcType="base" uri="br.ufc.mdcc.hpcshelf.gust.graph.impl.UndirectedGraphEImpl/bin/1.0.0.0/BaseIUndirectedGraphEImpl.dll" versionId="1.0.0.0">
          <dependency>br.ufc.mdcc.hpcshelf.gust.graph.Edge/bin/1.0.0.0/IEdge.dll</dependency>
          <dependency>br.ufc.mdcc.hpcshelf.gust.graph.Vertex/bin/1.0.0.0/IVertex.dll</dependency>
          <dependency>br.ufc.mdcc.hpcshelf.gust.graph.container.DataContainer/bin/1.0.0.0/IDataContainer.dll</dependency>
          <dependency>br.ufc.mdcc.hpcshelf.gust.graph.container.DataContainerE/bin/1.0.0.0/IDataContainerE.dll</dependency>
          <dependency>br.ufc.mdcc.hpcshelf.gust.graph.UndirectedGraph/bin/1.0.0.0/BaseIUndirectedGraph.dll</dependency>
        </file>
        <file contents="using System;&#xA;using System.Collections.Generic;&#xA;using System.Linq;&#xA;using br.ufc.pargo.hpe.backend.DGAC;&#xA;using br.ufc.pargo.hpe.basic;&#xA;using br.ufc.pargo.hpe.kinds;&#xA;using br.ufc.mdcc.hpcshelf.gust.graph.container.DataContainerE;&#xA;using br.ufc.mdcc.hpcshelf.gust.graph.container.DataContainer;&#xA;using br.ufc.mdcc.hpcshelf.gust.graph.Vertex;&#xA;using br.ufc.mdcc.hpcshelf.gust.graph.Edge;&#xA;using br.ufc.mdcc.hpcshelf.gust.graph.UndirectedGraph;&#xA;using br.ufc.mdcc.hpcshelf.gust.graph.Graph;&#xA;&#xA;namespace br.ufc.mdcc.hpcshelf.gust.graph.impl.UndirectedGraphEImpl&#xA;{&#xA;&#x9;public class IUndirectedGraphEImpl&lt;CTN, V, E> : BaseIUndirectedGraphEImpl&lt;CTN, V, E>, IUndirectedGraph&lt;CTN, V, E>&#xA;where CTN:IDataContainerE&lt;V, E>&#xA;where V:IVertex&#xA;where E:IEdge&lt;V> {&#xA;&#xA;&#x9;&#x9;override public void after_initialize()&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;newInstance(); &#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;public object newInstance () {&#xA;&#x9;&#x9;&#x9;return newInstance (0);&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;public object Instance {&#xA;&#x9;&#x9;&#x9;get { return graphInstanceT; }&#xA;&#x9;&#x9;&#x9;set { this.graphInstanceT = value; }&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;private object graphInstanceT = null;&#xA;&#x9;&#x9;public object GraphInstanceT { &#xA;&#x9;&#x9;&#x9;get{ &#xA;&#x9;&#x9;&#x9;&#x9;return this.graphInstanceT;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;public IUndirectedGraphInstance&lt;V, E, TV, TE> newInstanceT&lt;TV, TE> (TE e, int size)  where TE: IEdgeInstance&lt;V, TV> {&#xA;&#x9;&#x9;&#x9;IDataContainerEInstance&lt;V, E, TV, TE> dc = DataContainer.InstanceTFactory&lt;TV, TE>(e);&#xA;&#x9;&#x9;&#x9;dc.newDataSet (size);&#xA;&#x9;&#x9;&#x9;IGraphHelperE&lt;V, E, TV, TE> h = new IGraphHelperEImpl&lt;V, E, TV, TE>(dc);&#xA;&#x9;&#x9;&#x9;this.graphInstanceT = new IUndirectedGraphEInstanceImpl&lt;V, E, TV, TE> (h);&#xA;&#x9;&#x9;&#x9;return (IUndirectedGraphInstance&lt;V, E, TV, TE>) this.graphInstanceT;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;public IUndirectedGraphInstance&lt;V, E, int, IEdgeInstance&lt;V, int>> newInstance(int size) {&#xA;&#x9;&#x9;&#x9;IDataContainerEInstance&lt;V, E, int, IEdgeInstance&lt;V, int>> dc = DataContainer.DataContainerEInstance;&#xA;&#x9;&#x9;&#x9;dc.newDataSet (size);&#xA;&#x9;&#x9;&#x9;IGraphHelperE&lt;V, E, int, IEdgeInstance&lt;V, int>> h = new IGraphHelperEImpl&lt;V, E, int, IEdgeInstance&lt;V, int>>(dc);&#xA;&#x9;&#x9;&#x9;this.graphInstanceT = new IUndirectedGraphEInstanceImpl&lt;V, E, int, IEdgeInstance&lt;V, int>> (h);&#xA;&#x9;&#x9;&#x9;return (IUndirectedGraphInstance&lt;V, E, int, IEdgeInstance&lt;V, int>>) this.graphInstanceT;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;public class IUndirectedGraphEInstanceImpl&lt;V, E, TV, TE>: IUndirectedGraphInstance&lt;V, E, TV, TE> &#xA;&#x9;&#x9;&#x9;where V:IVertex  &#xA;&#x9;&#x9;&#x9;where E:IEdge&lt;V> &#xA;&#x9;&#x9;&#x9;where TE: IEdgeInstance&lt;V, TV> {&#xA;&#xA;&#x9;&#x9;&#x9;public IGraphHelperE&lt;V, E, TV, TE> delegator;&#xA;&#xA;&#x9;&#x9;&#x9;public IDataContainerInstance&lt;V, E> DataContainer{&#xA;&#x9;&#x9;&#x9;&#x9;get{ return this.delegator.Container; }&#xA;&#x9;&#x9;&#x9;&#x9;set{ this.delegator.Container = (IDataContainerEInstance&lt;V, E, TV, TE>)value; }&#xA;&#x9;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;&#x9;public IUndirectedGraphEInstanceImpl(IGraphHelperE&lt;V, E, TV, TE> d){&#xA;&#x9;&#x9;&#x9;&#x9;delegator = d;&#xA;&#x9;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;&#x9;public object ObjValue {&#xA;&#x9;&#x9;&#x9;&#x9;get { return new Tuple&lt;IGraphHelperE&lt;V, E, TV, TE>>(delegator); }&#xA;&#x9;&#x9;&#x9;&#x9;set { &#xA;&#x9;&#x9;&#x9;&#x9;&#x9;this.delegator = ((Tuple&lt;IGraphHelperE&lt;V, E, TV, TE>>)value).Item1;&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;&#x9;//************** implementation ***********************&#xA;&#x9;&#x9;&#x9;public ICollection&lt;TE> getAllEdges (TV sourceVertex, TV targetVertex) {&#xA;&#x9;&#x9;&#x9;&#x9;ICollection&lt;TE> edges = null;&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;if (containsVertex (sourceVertex) &amp;&amp; containsVertex (targetVertex)) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;edges = new List&lt;TE>();&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;IEnumerator&lt;TE> iter = iteratorEdgesOf (sourceVertex);&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;while (iter.MoveNext ()) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;TE e = iter.Current;&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;bool equal = isEqualsStraightOrInverted (sourceVertex, targetVertex, e);&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (equal) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;edges.Add (e);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;return edges;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public TE getEdge (TV sourceVertex, TV targetVertex) {&#xA;&#x9;&#x9;&#x9;&#x9;if (containsVertex (sourceVertex) &amp;&amp; containsVertex (targetVertex)) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;IEnumerator&lt;TE> iter = iteratorEdgesOf (sourceVertex);&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;while (iter.MoveNext ()) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;TE e = iter.Current;&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;bool equal = isEqualsStraightOrInverted (sourceVertex, targetVertex, e);&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (equal) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;return e;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;return default(TE);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public TE addEdge (TV sourceVertex, TV targetVertex) {&#xA;&#x9;&#x9;&#x9;&#x9;if (containsVertex (sourceVertex) &amp;&amp; containsVertex (targetVertex)) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if (!delegator.Container.AllowingMultipleEdges &amp;&amp; containsEdge (sourceVertex, targetVertex)) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;return default(TE);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if (!delegator.Container.AllowingLoops &amp;&amp; sourceVertex.Equals (targetVertex)) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;return default(TE);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;TE e = (TE) delegator.Container.EdgeFactory.newInstance (sourceVertex, targetVertex);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;addEdgeToContainer(e);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;return e;&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;return default(TE);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public bool addEdge (TE e) {&#xA;&#x9;&#x9;&#x9;&#x9;if (e == null || e.Source == null || e.Target == null) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;return false;&#xA;&#x9;&#x9;&#x9;&#x9;} &#xA;&#x9;&#x9;&#x9;&#x9;if (containsVertex (e.Source) &amp;&amp; containsVertex (e.Target)) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if (!delegator.Container.AllowingMultipleEdges &amp;&amp; containsEdge (e.Source, e.Target)) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;return false;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if (!delegator.Container.AllowingLoops &amp;&amp; e.Source.Equals (e.Target)) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;return false;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;addEdgeToContainer(e);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;return true;&#xA;&#x9;&#x9;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;return false;&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public bool addVertex (TV v) {&#xA;&#x9;&#x9;&#x9;&#x9;return delegator.addVertex (v);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public bool containsEdge(TV sourceVertex, TV targetVertex){&#xA;&#x9;&#x9;&#x9;&#x9;return getEdge(sourceVertex, targetVertex) != null;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public bool containsEdge(TE e){&#xA;&#x9;&#x9;&#x9;&#x9;if (e != null) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if (containsVertex (e.Source) &amp;&amp; containsVertex (e.Target))&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;return delegator.containsEdge (e);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;else&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;return false;&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;return false;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public bool containsVertex (TV v){&#xA;&#x9;&#x9;&#x9;&#x9;if (v == null) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;Console.WriteLine (&quot;WARNING: containsVertex(parameter null!) &quot;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;return false;&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;return delegator.containsVertex (v);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public IEnumerator&lt;TE> edgeSet () {&#xA;&#x9;&#x9;&#x9;&#x9;return delegator.edgeSet ();&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public ICollection&lt;TE> edgesOf (TV vertex) {&#xA;&#x9;&#x9;&#x9;&#x9;return delegator.edgesOf (vertex);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public IEnumerator&lt;TE> iteratorEdgesOf (TV vertex) {&#xA;&#x9;&#x9;&#x9;&#x9;return delegator.iteratorEdgesOf (vertex);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public ICollection&lt;TV> neighborsOf (TV vertex){&#xA;&#x9;&#x9;&#x9;&#x9;ICollection&lt;TE> o = delegator.outgoing&lt;TE> (vertex);&#xA;&#x9;&#x9;&#x9;&#x9;ICollection&lt;TE> i = delegator.incoming&lt;TE> (vertex);&#xA;&#x9;&#x9;&#x9;&#x9;HashSet&lt;TV> so = new HashSet&lt;TV> ();&#xA;&#x9;&#x9;&#x9;&#x9;HashSet&lt;TV> si = new HashSet&lt;TV> ();&#xA;&#x9;&#x9;&#x9;&#x9;foreach (TE e in o)&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;so.Add (e.Target);&#xA;&#x9;&#x9;&#x9;&#x9;foreach (TE e in i)&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;si.Add (e.Source);&#xA;&#x9;&#x9;&#x9;&#x9;return new HashSet&lt;TV> (so.Union(si));&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public IEnumerator&lt;TV> iteratorNeighborsOf (TV vertex){&#xA;&#x9;&#x9;&#x9;&#x9;ICollection&lt;TE> o = delegator.outgoing&lt;TE> (vertex);&#xA;&#x9;&#x9;&#x9;&#x9;ICollection&lt;TE> i = delegator.incoming&lt;TE> (vertex);&#xA;//&#x9;&#x9;&#x9;&#x9;ICollection&lt;TV> edges = new HashSet&lt;TV> ();&#xA;//&#x9;&#x9;&#x9;&#x9;if (!delegator.Container.AllowingMultipleEdges) {&#xA;//&#x9;&#x9;&#x9;&#x9;&#x9;foreach (TE e in o)&#xA;//&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (!edges.Contains (e.Target)) {&#xA;//&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;edges.Add (e.Target);&#xA;//&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;yield return e.Target;&#xA;//&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;//&#x9;&#x9;&#x9;&#x9;&#x9;foreach(TE e in i)&#xA;//&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (!edges.Contains (e.Source)) {&#xA;//&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;edges.Add (e.Source);&#xA;//&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;yield return e.Source;&#xA;//&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;//&#x9;&#x9;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;foreach(TE e in o) yield return e.Target;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;foreach(TE e in i) yield return e.Source;&#xA;//&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;//&#xA;&#x9;&#x9;&#x9;public IEnumerator&lt;KeyValuePair&lt;TV, float>> iteratorVertexWeightOf(TV vertex){&#xA;&#x9;&#x9;&#x9;&#x9;ICollection&lt;TE> o = delegator.outgoing&lt;TE> (vertex);&#xA;&#x9;&#x9;&#x9;&#x9;ICollection&lt;TE> i = delegator.incoming&lt;TE> (vertex);&#xA;&#x9;&#x9;&#x9;&#x9;ICollection&lt;TV> edges = new HashSet&lt;TV> ();&#xA;&#x9;&#x9;&#x9;&#x9;if (!delegator.Container.AllowingMultipleEdges) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;foreach (TE e in o) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;KeyValuePair&lt;TV, float> kv = (new KeyValuePair&lt;TV, float> (e.Target, e.Weight));&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;bool contain = edges.Contains (kv.Key);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (!contain) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;edges.Add (kv.Key);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;yield return kv;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;//edges.Clear ();&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;foreach (TE e in i) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;KeyValuePair&lt;TV, float> kv = (new KeyValuePair&lt;TV, float> (e.Source, e.Weight));&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;bool contain = edges.Contains (kv.Key);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (!contain) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;edges.Add (kv.Key);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;yield return kv;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;foreach (TE e in o) yield return (new KeyValuePair&lt;TV, float> (e.Target, e.Weight));&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;foreach (TE e in i) yield return (new KeyValuePair&lt;TV, float> (e.Source, e.Weight));&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;//&#xA;&#x9;&#x9;&#x9;public bool removeAllEdges(ICollection&lt;TE> edges){&#xA;&#x9;&#x9;&#x9;&#x9;bool modified = false;&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;foreach (TE e in edges) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;modified |= removeEdge(e);&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;return modified;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public ICollection&lt;TE> removeAllEdges(TV sourceVertex, TV targetVertex){&#xA;&#x9;&#x9;&#x9;&#x9;ICollection&lt;TE> removed = getAllEdges(sourceVertex, targetVertex);&#xA;&#x9;&#x9;&#x9;&#x9;if (removed == null) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;return null;&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;removeAllEdges(removed);&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;return removed;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public bool removeAllVertices(ICollection&lt;TV> vertices){&#xA;&#x9;&#x9;&#x9;&#x9;bool modified = false;&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;foreach (TV v in vertices) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;modified |= removeVertex(v);&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;return modified;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public TE removeEdge (TV sourceVertex, TV targetVertex) {&#xA;&#x9;&#x9;&#x9;&#x9;TE e = getEdge (sourceVertex, targetVertex);&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;if (e != null) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;removeEdgeFromContainer (e);&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;return e;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public bool removeEdge (TE e) {&#xA;&#x9;&#x9;&#x9;&#x9;if (containsEdge (e)) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;removeEdgeFromContainer (e);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;return true;&#xA;&#x9;&#x9;&#x9;&#x9;} &#xA;&#x9;&#x9;&#x9;&#x9;else { return false; }&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public bool removeVertex (TV v) {&#xA;&#x9;&#x9;&#x9;&#x9;if (containsVertex (v)) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;ICollection&lt;TE> edges = edgesOf (v);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;foreach (TE e in edges) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;removeEdgeFromContainer (e);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;return delegator.removeVertex (v);&#xA;&#x9;&#x9;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;return false;&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public ICollection&lt;TV> vertexSet () {&#xA;&#x9;&#x9;&#x9;&#x9;return delegator.vertexSet ();&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public TV getEdgeSource (TE e) {&#xA;&#x9;&#x9;&#x9;&#x9;return e.Source;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public TV getEdgeTarget (TE e) {&#xA;&#x9;&#x9;&#x9;&#x9;return e.Target;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public float getEdgeWeight (TE e) {&#xA;&#x9;&#x9;&#x9;&#x9;return getEdgeWeight (e.Source, e.Target);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public void setAllEdgeWeight (TE e, float weight) {&#xA;&#x9;&#x9;&#x9;&#x9;setAllEdgeWeight (e.Source, e.Target, weight);&#xA;&#x9;&#x9;&#x9;} &#xA;&#x9;&#x9;&#x9;public void setAllEdgeWeight (TV sourceVertex, TV targetVertex, float weight){&#xA;&#x9;&#x9;&#x9;&#x9;if (delegator.Container.AllowingMultipleEdges) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;ICollection&lt;TE> list = this.getAllEdges (sourceVertex, targetVertex);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;foreach (TE ei in list)&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;ei.Weight = weight;&#xA;&#x9;&#x9;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;TE ei = this.getEdge (sourceVertex, targetVertex);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if(ei!=null)&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;ei.Weight = weight;&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public float getEdgeWeight (TV sourceVertex, TV targetVertex){&#xA;&#x9;&#x9;&#x9;&#x9;TE e = getEdge (sourceVertex, targetVertex);&#xA;&#x9;&#x9;&#x9;&#x9;if (e != null)&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;return e.Weight;&#xA;&#x9;&#x9;&#x9;&#x9;return 0f;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;// End interface implements&#xA;&#xA;&#x9;&#x9;&#x9;public bool isAllowingLoops () { return delegator.Container.AllowingLoops; }&#xA;&#x9;&#x9;&#x9;public bool isAllowingMultipleEdges () { return delegator.Container.AllowingMultipleEdges; }&#xA;&#xA;&#x9;&#x9;&#x9;#region ICloneable implementation&#xA;&#x9;&#x9;&#x9;public object Clone () {&#xA;&#x9;&#x9;&#x9;&#x9;IGraphHelperE&lt;V, E, TV, TE> d = (IGraphHelperE&lt;V, E, TV, TE>) this.delegator.Clone ();&#xA;&#x9;&#x9;&#x9;&#x9;IUndirectedGraphEInstanceImpl&lt;V, E, TV, TE> clone = new IUndirectedGraphEInstanceImpl&lt;V, E, TV, TE>(d);&#xA;&#x9;&#x9;&#x9;&#x9;return clone;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;#endregion&#xA;&#xA;&#x9;&#x9;&#x9;public override string ToString () { &#xA;&#x9;&#x9;&#x9;&#x9;IEnumerator&lt;TV> vertexSet = this.vertexSet ().GetEnumerator();&#xA;&#x9;&#x9;&#x9;&#x9;IEnumerator&lt;TE> edgeSet = this.edgeSet ();&#xA;&#x9;&#x9;&#x9;&#x9;System.Text.StringBuilder sb = new System.Text.StringBuilder();&#xA;&#x9;&#x9;&#x9;&#x9;String ret = &quot;&quot;;&#xA;&#x9;&#x9;&#x9;&#x9;sb.Append (&quot;Vertexs [&quot;);&#xA;&#x9;&#x9;&#x9;&#x9;for(int i = 0; vertexSet.MoveNext();i++){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;sb.Append (vertexSet.Current.ToString ()+&quot;,&quot;);&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;sb.Remove (sb.Length-1, 1);&#xA;&#x9;&#x9;&#x9;&#x9;sb.Append(&quot;]&quot;);&#xA;&#x9;&#x9;&#x9;&#x9;sb.AppendLine();&#xA;&#x9;&#x9;&#x9;&#x9;sb.Append(&quot;edges&quot;);&#xA;&#x9;&#x9;&#x9;&#x9;for (int i=0; edgeSet.MoveNext(); i++) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;sb.Append(&quot;(&quot;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;sb.Append (edgeSet.Current.ToString());&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;sb.Append(&quot;) &quot;);&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;ret = sb.ToString ();&#xA;&#x9;&#x9;&#x9;&#x9;sb.Clear ();&#xA;&#x9;&#x9;&#x9;&#x9;return ret;&#xA;&#x9;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;&#x9;public void noSafeAdd(TE e){&#xA;&#x9;&#x9;&#x9;&#x9;delegator.noSafeAdd (e);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public void noSafeAdd(TV source, TV target){&#xA;&#x9;&#x9;&#x9;&#x9;delegator.noSafeAdd (source, target);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public void noSafeAdd(TV source, TV target, float weight){&#xA;&#x9;&#x9;&#x9;&#x9;delegator.noSafeAdd (source, target, weight);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public void addEdgeToContainer (TE e) {&#xA;&#x9;&#x9;&#x9;&#x9;delegator.addOutgoingEdge (e);&#xA;&#x9;&#x9;&#x9;&#x9;delegator.addIncomingEdge (e);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public void removeEdgeFromContainer (TE e) {&#xA;&#x9;&#x9;&#x9;&#x9;delegator.removeOutgoingEdge (e);&#xA;&#x9;&#x9;&#x9;&#x9;delegator.removeIncomingEdge (e);&#xA;&#x9;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;&#x9;private bool isEqualsStraightOrInverted (Object sourceVertex, Object targetVertex, TE e) {&#xA;&#x9;&#x9;&#x9;&#x9;bool equalStraight = sourceVertex.Equals (e.Source) &amp;&amp; targetVertex.Equals (e.Target);&#xA;&#x9;&#x9;&#x9;&#x9;bool equalInverted = sourceVertex.Equals (e.Target) &amp;&amp; targetVertex.Equals (e.Source);&#xA;&#x9;&#x9;&#x9;&#x9;return equalStraight || equalInverted;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public int degreeOf (TV vertex) {&#xA;&#x9;&#x9;&#x9;&#x9;if (delegator.Container.AllowingLoops) {&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;int degree = 0;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;ICollection&lt;TE> edges = edgesOf (vertex);&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;foreach (TE e in edges) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (e.Source.Equals (e.Target)) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;degree += 2;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;degree += 1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;return degree;&#xA;&#x9;&#x9;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;return delegator.degreeOf (vertex);&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public int countE() { return delegator.countE(); }&#xA;&#x9;&#x9;&#x9;public int countV() { return delegator.countV(); }&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;public interface IGraphHelperE&lt;V, E, TV, TE>: IGraphHelper&lt;V, E, TV, TE> &#xA;&#x9;&#x9;&#x9;where V:IVertex where E:IEdge&lt;V> where TE: IEdgeInstance&lt;V, TV> {&#xA;&#x9;&#x9;&#x9;IDataContainerEInstance&lt;V, E, TV, TE> Container { get; set; }&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;internal class IGraphHelperEImpl&lt;V, E, TV, TE>: IGraphHelperE&lt;V, E, TV, TE> &#xA;&#x9;&#x9;&#x9;where V:IVertex &#xA;&#x9;&#x9;&#x9;where E:IEdge&lt;V>&#xA;&#x9;&#x9;&#x9;where TE: IEdgeInstance&lt;V, TV> {&#xA;&#xA;&#x9;&#x9;&#x9;private int count_edges = 0;&#xA;&#x9;&#x9;&#x9;private IDataContainerEInstance&lt;V, E, TV, TE> container;&#xA;&#xA;&#x9;&#x9;&#x9;public IGraphHelperEImpl (IDataContainerEInstance&lt;V, E, TV, TE> c) {&#xA;&#x9;&#x9;&#x9;&#x9;container = c;&#xA;&#x9;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;&#x9;public IDataContainerEInstance&lt;V, E, TV, TE> Container{&#xA;&#x9;&#x9;&#x9;&#x9;get{ return this.container; }&#xA;&#x9;&#x9;&#x9;&#x9;set{ this.container = (IDataContainerEInstance&lt;V, E, TV, TE>)value; }&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public IDataContainerInstance&lt;V, E> DataContainer{&#xA;&#x9;&#x9;&#x9;&#x9;get{ return this.container; }&#xA;&#x9;&#x9;&#x9;&#x9;set{ this.container = (IDataContainerEInstance&lt;V, E, TV, TE>)value; }&#xA;&#x9;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;&#x9;#region ICloneable implementation&#xA;&#x9;&#x9;&#x9;public object Clone () {&#xA;&#x9;&#x9;&#x9;&#x9;IDataContainerEInstance&lt;V, E, TV, TE> c = (IDataContainerEInstance&lt;V, E, TV, TE>) this.Container.Clone ();&#xA;&#x9;&#x9;&#x9;&#x9;IGraphHelperEImpl&lt;V, E, TV, TE> clone = new IGraphHelperEImpl&lt;V, E, TV, TE> (c);&#xA;&#x9;&#x9;&#x9;&#x9;clone.count_edges = this.count_edges;&#xA;&#x9;&#x9;&#x9;&#x9;return clone;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;#endregion&#xA;&#xA;&#x9;&#x9;&#x9;// ************************* implements ***********************************&#xA;&#x9;&#x9;&#x9;public IEnumerator&lt;TE> edgeSet () {&#xA;&#x9;&#x9;&#x9;&#x9;ICollection&lt;TV> collection = container.DataSet.Keys;&#xA;&#x9;&#x9;&#x9;&#x9;foreach (TV v in collection) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;IEdgeContainer&lt;TE> ec = container.DataSet[v];&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;IEnumerator&lt;TE> iterator = ec.outgoing.GetEnumerator();&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;while (iterator.MoveNext ()) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;yield return iterator.Current;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public ICollection&lt;TE> edgesOf (TV vertex) {&#xA;&#x9;&#x9;&#x9;&#x9;IEdgeContainer&lt;TE> ec;&#xA;&#x9;&#x9;&#x9;&#x9;ICollection&lt;TE> edges;&#xA;&#x9;&#x9;&#x9;&#x9;if (!container.AllowingMultipleEdges)&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;edges = new HashSet&lt;TE> ();&#xA;&#x9;&#x9;&#x9;&#x9;else&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;edges = new List&lt;TE> ();&#xA;&#x9;&#x9;&#x9;&#x9;if (container.DataSet.TryGetValue (vertex, out ec)) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;foreach (TE e_ou in ec.outgoing) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;edges.Add (e_ou);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;foreach (TE e_in in ec.incoming)&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (!vertex.Equals (e_in.Source))&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;edges.Add (e_in);&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;return edges;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public IEnumerator&lt;TE> iteratorEdgesOf (TV vertex) {&#xA;&#x9;&#x9;&#x9;&#x9;IEdgeContainer&lt;TE> ec;&#xA;&#x9;&#x9;&#x9;&#x9;if (container.DataSet.TryGetValue (vertex, out ec)) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;foreach (TE e_ou in ec.outgoing) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;yield return e_ou;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;foreach (TE e_in in ec.incoming)&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (!vertex.Equals (e_in.Source))&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;yield return e_in;&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public ICollection&lt;TV> vertexSet () {&#xA;&#x9;&#x9;&#x9;&#x9;return container.DataSet.Keys;&#xA;&#x9;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;&#x9;public void addIncomingEdge (TE e) {//if (container.DataSet.ContainsKey (e.Target))&#xA;&#x9;&#x9;&#x9;&#x9;if (!e.Source.Equals (e.Target)) { &#xA;&#x9;&#x9;&#x9;&#x9;&#x9;container.DataSet [e.Target].incoming.Add (e);&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public void addOutgoingEdge (TE e) { //if (container.DataSet.ContainsKey (e.Source))&#xA;&#x9;&#x9;&#x9;&#x9;container.DataSet [e.Source].outgoing.Add (e);&#xA;&#x9;&#x9;&#x9;&#x9;count_edges++;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public void removeIncomingEdge (TE e) { //if (container.DataSet.ContainsKey (e.Target))&#xA;&#x9;&#x9;&#x9;&#x9;container.DataSet [e.Target].incoming.Remove (e);&#xA;&#x9;&#x9;&#x9;&#x9;count_edges--;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public void removeOutgoingEdge (TE e) { //if (container.DataSet.ContainsKey (e.Source))&#xA;&#x9;&#x9;&#x9;&#x9;container.DataSet [e.Source].outgoing.Remove (e);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public void noSafeAdd(TE e){&#xA;&#x9;&#x9;&#x9;&#x9;if (!containsEdge(e)) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;container.DataSet [e.Source].outgoing.Add (e);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if (!e.Source.Equals (e.Target)) { &#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;container.DataSet [e.Target].incoming.Add (e);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;count_edges++;&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public void noSafeAdd(TV source, TV target){&#xA;&#x9;&#x9;&#x9;&#x9;TE e = (TE) container.EdgeFactory.newInstance(source, target);&#xA;&#x9;&#x9;&#x9;&#x9;noSafeAdd (e);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public void noSafeAdd(TV source, TV target, float weight){&#xA;&#x9;&#x9;&#x9;&#x9;TE e = (TE) container.EdgeFactory.newInstance(source, target, weight);&#xA;&#x9;&#x9;&#x9;&#x9;noSafeAdd (e);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public ICollection&lt;T> incoming&lt;T>(TV vertex){&#xA;&#x9;&#x9;&#x9;&#x9;IEdgeContainer&lt;TE> ec;&#xA;&#x9;&#x9;&#x9;&#x9;if (container.DataSet.TryGetValue (vertex, out ec))&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;return ((List&lt;T>)ec.incoming).AsReadOnly();&#xA;&#x9;&#x9;&#x9;&#x9;return new List&lt;T>().AsReadOnly();&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public ICollection&lt;T> outgoing&lt;T>(TV vertex){&#xA;&#x9;&#x9;&#x9;&#x9;IEdgeContainer&lt;TE> ec;&#xA;&#x9;&#x9;&#x9;&#x9;if (container.DataSet.TryGetValue (vertex, out ec))&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;return ((List&lt;T>)ec.outgoing).AsReadOnly();&#xA;&#x9;&#x9;&#x9;&#x9;return new List&lt;T>().AsReadOnly();&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public bool addVertex (TV vertex) {&#xA;&#x9;&#x9;&#x9;&#x9;if (container.DataSet.ContainsKey (vertex)) return false;&#xA;&#x9;&#x9;&#x9;&#x9;else { &#xA;&#x9;&#x9;&#x9;&#x9;&#x9;IEdgeContainer&lt;TE> ec = new EdgeContainer&lt;TE>(); &#xA;&#x9;&#x9;&#x9;&#x9;&#x9;ec.outgoing = new List&lt;TE> ();&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;ec.incoming = new List&lt;TE> ();&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;container.DataSet[vertex] = ec;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;return true; &#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public bool containsEdge(TE e){&#xA;&#x9;&#x9;&#x9;&#x9;return container.DataSet [e.Source].outgoing.Contains (e) || container.DataSet [e.Target].outgoing.Contains (e);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public bool containsVertex (TV v){&#xA;&#x9;&#x9;&#x9;&#x9;return container.DataSet.ContainsKey (v);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public bool removeVertex (TV v) {&#xA;&#x9;&#x9;&#x9;&#x9;return container.DataSet.Remove (v);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public int countE() { return count_edges; }&#xA;&#x9;&#x9;&#x9;public int countV() { return container.DataSet.Count; }&#xA;&#x9;&#x9;&#x9;public int degreeOf(TV v) { &#xA;&#x9;&#x9;&#x9;&#x9;IEdgeContainer&lt;TE> ec; &#xA;&#x9;&#x9;&#x9;&#x9;if (container.DataSet.TryGetValue (v, out ec)) &#xA;&#x9;&#x9;&#x9;&#x9;&#x9;return ec.outgoing.Count + ec.incoming.Count; &#xA;&#x9;&#x9;&#x9;&#x9;return 0; &#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;}&#xA;" name="IUndirectedGraphEImpl.cs" srcType="user" uri="br.ufc.mdcc.hpcshelf.gust.graph.impl.UndirectedGraphEImpl/bin/1.0.0.0/IUndirectedGraphEImpl.dll" versionId="1.0.0.0">
          <dependency>br.ufc.mdcc.hpcshelf.gust.graph.container.DataContainerE/bin/1.0.0.0/IDataContainerE.dll</dependency>
          <dependency>br.ufc.mdcc.hpcshelf.gust.graph.Vertex/bin/1.0.0.0/IVertex.dll</dependency>
          <dependency>br.ufc.mdcc.hpcshelf.gust.graph.Edge/bin/1.0.0.0/IEdge.dll</dependency>
          <dependency>%WORKSPACE/br.ufc.mdcc.hpcshelf.gust.graph.impl.UndirectedGraphEImpl/bin/1.0.0.0/BaseIUndirectedGraphEImpl.dll</dependency>
          <dependency>br.ufc.mdcc.hpcshelf.gust.graph.UndirectedGraph/bin/1.0.0.0/IUndirectedGraph.dll</dependency>
        </file>
      </sources>
      <visualDescription h="40" w="193" x="145" y="153">
        <color b="207" g="159" r="114"/>
      </visualDescription>
      <parameter iname="IDataContainerE" order="2" parid="container" uname="data" varid="CTN"/>
      <parameter iname="IEdge" order="1" parid="edge_type" uname="data" varid="E"/>
      <parameter iname="IVertex" order="0" parid="vertex_type" uname="data" varid="V"/>
    </interface>
    <unit facet="0" iRef="IUndirectedGraphEImpl" multiple="false" private="false" replica="0" uRef="data" visibleInterface="true">
      <super cRef="base" uRef="data"/>
      <visualDescription h="40" w="80" x="272" y="251"/>
    </unit>
  </componentInfo>
</component:component>