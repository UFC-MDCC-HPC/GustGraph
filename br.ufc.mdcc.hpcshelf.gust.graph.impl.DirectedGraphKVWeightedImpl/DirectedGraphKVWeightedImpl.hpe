<?xml version="1.0" encoding="ASCII"?>
<component:component xmlns:component="http://www.example.org/HashComponent">
  <header hash_component_UID="00240000048000009400000006020000002400005253413100040000110000000b101c7c2fe952b6bdafd529b882858612b9cdc86fd6d7ff7431d7dd6ccd41f3050ffa41a124a774087c7c8d98e8ca12d9f71bbd8127031772628f88712cbf707e1558523ef4203e0ddfc98844acff075381e09cb4b7ea51af74858cfe22335cd51aa23ac99842c3a18626a77830550ecc0bbd7123ef4321cc20af85a4bfd5b9" isAbstract="false" kind="Data" name="DirectedGraphKVWeightedImpl" packagePath="br.ufc.mdcc.hpcshelf.gust.graph.impl">
    <baseType>
      <extensionType>
        <implements>true</implements>
      </extensionType>
      <component hash_component_UID="00240000048000009400000006020000002400005253413100040000110000003191befb441a3dd4290d22e1af11b908c913fc2f864e5110035cd463b09c5d5d00001114c7cb0f198876af07c4319730d25069d71f17176d371a311cdc36b49e1ba4a7ed7086522ba522fd6a274ce23247fa9e59ef889852cb23de1e02887a04a735bff8e98162e81418287948b3bebe1af09ab1cdc6ecc18044070e7819bead" localRef="base" location="br.ufc.mdcc.hpcshelf.gust.graph.DirectedGraph/DirectedGraph.hpe" name="DirectedGraph" package="br.ufc.mdcc.hpcshelf.gust.graph" version="1.0.0.0">
        <visualDescription h="60" w="100" x="385" y="296">
          <color b="255" g="255" r="255"/>
        </visualDescription>
        <parameter formFieldId="container" varName="CTN"/>
        <parameter formFieldId="vertex_type" varName="V"/>
        <parameter formFieldId="edge_type" varName="E"/>
        <unitBounds facet="0" facet_instance="0" facet_instance_enclosing="0" parallel="false" uRef="data">
          <visualDescription h="20" w="20" x="5" y="2"/>
        </unitBounds>
      </component>
    </baseType>
    <versions field1="1" field2="0" field3="0" field4="0"/>
    <visualAttributes>
      <color b="255" g="255" r="255"/>
    </visualAttributes>
    <facet_configuration facet="0" multiple="false"/>
  </header>
  <componentInfo>
    <innerComponent localRef="v" location="br.ufc.mdcc.hpcshelf.gust.graph.Vertex/Vertex.hpe" multiple="false" name="Vertex" package="br.ufc.mdcc.hpcshelf.gust.graph" exposed="true">
      <visualDescription h="60" w="142" x="158" y="315">
        <color b="255" g="255" r="255"/>
      </visualDescription>
      <unitBounds facet="0" facet_instance="0" parallel="false" uRef="data">
        <visualDescription h="20" w="20" x="5" y="2"/>
      </unitBounds>
    </innerComponent>
    <innerComponent localRef="e" location="br.ufc.mdcc.hpcshelf.gust.graph.Edge/Edge.hpe" multiple="false" name="Edge" package="br.ufc.mdcc.hpcshelf.gust.graph" exposed="true">
      <visualDescription h="60" w="161" x="597" y="264">
        <color b="255" g="255" r="255"/>
      </visualDescription>
      <parameter formFieldId="vertex_type" varName="V"/>
      <unitBounds facet="0" facet_instance="0" parallel="false" uRef="data">
        <visualDescription h="20" w="20" x="5" y="2"/>
      </unitBounds>
    </innerComponent>
    <innerComponent localRef="ctn" location="br.ufc.mdcc.hpcshelf.gust.graph.container.DataContainerKV/DataContainerKV.hpe" multiple="false" name="DataContainerKV" package="br.ufc.mdcc.hpcshelf.gust.graph.container" exposed="true">
      <visualDescription h="60" w="187" x="327" y="431">
        <color b="255" g="255" r="255"/>
      </visualDescription>
      <parameter formFieldId="vertex_type" varName="V"/>
      <parameter formFieldId="edge_type" varName="E"/>
      <unitBounds facet="0" facet_instance="0" parallel="false" uRef="data">
        <visualDescription h="20" w="20" x="5" y="2"/>
      </unitBounds>
    </innerComponent>
    <supplyParameter cRef="v" direct="true" varName="V"/>
    <supplyParameter cRef="e" direct="true" varName="E"/>
    <supplyParameter cRef="ctn" direct="true" varName="CTN"/>
    <interface iRef="IDirectedGraphKVWeightedImpl" nArgs="3">
      <sources sourceType="C# Language" versionId="1.0.0.0">
        <file contents="/* Automatically Generated Code */&#xA;&#xA;using System;&#xA;using br.ufc.pargo.hpe.backend.DGAC;&#xA;using br.ufc.pargo.hpe.basic;&#xA;using br.ufc.pargo.hpe.kinds;&#xA;using br.ufc.mdcc.hpcshelf.gust.graph.Edge;&#xA;using br.ufc.mdcc.hpcshelf.gust.graph.Vertex;&#xA;using br.ufc.mdcc.hpcshelf.gust.graph.container.DataContainer;&#xA;using br.ufc.mdcc.hpcshelf.gust.graph.container.DataContainerKV;&#xA;using br.ufc.mdcc.hpcshelf.gust.graph.DirectedGraph;&#xA;&#xA;namespace br.ufc.mdcc.hpcshelf.gust.graph.impl.DirectedGraphKVWeightedImpl &#xA;{&#xA;&#x9;public abstract class BaseIDirectedGraphKVWeightedImpl&lt;CTN, V, E>: DataStructure, BaseIDirectedGraph&lt;CTN, V, E>&#xA;&#x9;&#x9;where CTN:IDataContainerKV&lt;V, E>&#xA;&#x9;&#x9;where V:IVertex&#xA;&#x9;&#x9;where E:IEdge&lt;V>&#xA;&#x9;{&#xA;&#x9;&#x9;private E edgeFactory = default(E);&#xA;&#xA;&#x9;&#x9;public E EdgeFactory&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;get&#xA;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;if (this.edgeFactory == null)&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;this.edgeFactory = (E) Services.getPort(&quot;edgeFactory&quot;);&#xA;&#x9;&#x9;&#x9;&#x9;return this.edgeFactory;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;private V vertex = default(V);&#xA;&#xA;&#x9;&#x9;public V Vertex&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;get&#xA;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;if (this.vertex == null)&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;this.vertex = (V) Services.getPort(&quot;vertex&quot;);&#xA;&#x9;&#x9;&#x9;&#x9;return this.vertex;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;private CTN dataContainer = default(CTN);&#xA;&#xA;&#x9;&#x9;public CTN DataContainer&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;get&#xA;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;if (this.dataContainer == null)&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;this.dataContainer = (CTN) Services.getPort(&quot;dataContainer&quot;);&#xA;&#x9;&#x9;&#x9;&#x9;return this.dataContainer;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;}" name="BaseIDirectedGraphKVWeightedImpl.cs" srcType="base" uri="br.ufc.mdcc.hpcshelf.gust.graph.impl.DirectedGraphKVWeightedImpl/bin/1.0.0.0/BaseIDirectedGraphKVWeightedImpl.dll" versionId="1.0.0.0">
          <dependency>br.ufc.mdcc.hpcshelf.gust.graph.Edge/bin/1.0.0.0/IEdge.dll</dependency>
          <dependency>br.ufc.mdcc.hpcshelf.gust.graph.Vertex/bin/1.0.0.0/IVertex.dll</dependency>
          <dependency>br.ufc.mdcc.hpcshelf.gust.graph.container.DataContainer/bin/1.0.0.0/IDataContainer.dll</dependency>
          <dependency>br.ufc.mdcc.hpcshelf.gust.graph.container.DataContainerKV/bin/1.0.0.0/IDataContainerKV.dll</dependency>
          <dependency>br.ufc.mdcc.hpcshelf.gust.graph.DirectedGraph/bin/1.0.0.0/BaseIDirectedGraph.dll</dependency>
        </file>
        <file contents="using System;&#xA;using System.Collections.Generic;&#xA;using br.ufc.mdcc.hpcshelf.gust.graph.container.DataContainer;&#xA;using br.ufc.mdcc.hpcshelf.gust.graph.container.DataContainerKV;&#xA;using br.ufc.mdcc.hpcshelf.gust.graph.DirectedGraph;&#xA;using br.ufc.mdcc.hpcshelf.gust.graph.Edge;&#xA;using br.ufc.mdcc.hpcshelf.gust.graph.Graph;&#xA;using br.ufc.mdcc.hpcshelf.gust.graph.Vertex;&#xA;&#xA;namespace br.ufc.mdcc.hpcshelf.gust.graph.impl.DirectedGraphKVWeightedImpl&#xA;{&#xA;    public class IDirectedGraphKVWeightedImpl&lt;CTN, V, E> : BaseIDirectedGraphKVWeightedImpl&lt;CTN, V, E>, IDirectedGraph&lt;CTN, V, E>&#xA;where CTN:IDataContainerKV&lt;V, E>&#xA;where V:IVertex&#xA;where E:IEdge&lt;V>&#xA;&#x9;{&#xA;&#x9;&#x9;override public void after_initialize()&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;newInstance(); &#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;public object newInstance () {&#xA;&#x9;&#x9;&#x9;return newInstance (0);&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;public object Instance {&#xA;&#x9;&#x9;&#x9;get { return graphInstanceT; }&#xA;&#x9;&#x9;&#x9;set { this.graphInstanceT = value; }&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;private object graphInstanceT = null;&#xA;&#x9;&#x9;public object GraphInstanceT { &#xA;&#x9;&#x9;&#x9;get{ &#xA;&#x9;&#x9;&#x9;&#x9;return this.graphInstanceT;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;public IDirectedGraphInstance&lt;V, E, TV, TE> newInstanceT&lt;TV, TE> (TE e, int size)  where TE: IEdgeInstance&lt;V, TV> {&#xA;&#x9;&#x9;&#x9;IDataContainerKVInstance&lt;V, E, TV, TE> dc = DataContainer.InstanceTFactory&lt;TV, TE> (e);&#xA;&#x9;&#x9;&#x9;dc.newDataSet (size);&#xA;&#x9;&#x9;&#x9;IGraphHelperKV&lt;V, E, TV, TE> h = new IGraphHelperKVImpl&lt;V, E, TV, TE>(dc);&#xA;&#x9;&#x9;&#x9;this.graphInstanceT = new IDirectedGraphKVWeightedInstanceImpl&lt;V, E, TV, TE> (h);&#xA;&#x9;&#x9;&#x9;return (IDirectedGraphInstance&lt;V, E, TV, TE>) this.graphInstanceT;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;public IDirectedGraphInstance&lt;V, E, int, IEdgeInstance&lt;V, int>> newInstance(int size) {&#xA;&#x9;&#x9;&#x9;IDataContainerKVInstance&lt;V, E, int, IEdgeInstance&lt;V, int>> dc = DataContainer.DataContainerKVInstance;&#xA;&#x9;&#x9;&#x9;dc.newDataSet (size);&#xA;&#x9;&#x9;&#x9;IGraphHelperKV&lt;V, E, int, IEdgeInstance&lt;V, int>> h = new IGraphHelperKVImpl&lt;V, E, int, IEdgeInstance&lt;V, int>>(dc);&#xA;&#x9;&#x9;&#x9;this.graphInstanceT = new IDirectedGraphKVWeightedInstanceImpl&lt;V, E, int, IEdgeInstance&lt;V, int>> (h);&#xA;&#x9;&#x9;&#x9;return (IDirectedGraphInstance&lt;V, E, int, IEdgeInstance&lt;V, int>>) this.graphInstanceT;&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;public class IDirectedGraphKVWeightedInstanceImpl&lt;V, E, TV, TE>: IDirectedGraphInstance&lt;V, E, TV, TE> &#xA;&#x9;&#x9;&#x9;where V:IVertex  &#xA;&#x9;&#x9;&#x9;where E:IEdge&lt;V> &#xA;&#x9;&#x9;&#x9;where TE: IEdgeInstance&lt;V, TV> {&#xA;&#xA;&#x9;&#x9;&#x9;public IGraphHelperKV&lt;V, E, TV, TE> delegator;&#xA;&#xA;&#x9;&#x9;&#x9;public IDataContainerInstance&lt;V, E> DataContainer{&#xA;&#x9;&#x9;&#x9;&#x9;get{ return this.delegator.Container; }&#xA;&#x9;&#x9;&#x9;&#x9;set{ this.delegator.Container = (IDataContainerKVInstance&lt;V, E, TV, TE>)value; }&#xA;&#x9;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;&#x9;public IDirectedGraphKVWeightedInstanceImpl(IGraphHelperKV&lt;V, E, TV, TE> d){&#xA;&#x9;&#x9;&#x9;&#x9;delegator = d;&#xA;&#x9;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;&#x9;public object ObjValue {&#xA;&#x9;&#x9;&#x9;&#x9;get { return new Tuple&lt;IGraphHelperKV&lt;V, E, TV, TE>>(delegator); }&#xA;&#x9;&#x9;&#x9;&#x9;set { &#xA;&#x9;&#x9;&#x9;&#x9;&#x9;this.delegator = ((Tuple&lt;IGraphHelperKV&lt;V, E, TV, TE>>)value).Item1;&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;&#x9;public ICollection&lt;TE> getAllEdges (TV sourceVertex, TV targetVertex) {&#xA;&#x9;&#x9;&#x9;&#x9;ICollection&lt;TE> edges = null;&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;if (containsVertex (sourceVertex) &amp;&amp; containsVertex (targetVertex)) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;edges = new List&lt;TE> ();&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;IEnumerator&lt;KeyValuePair&lt;TV, float>> iter = delegator.outgoing&lt;KeyValuePair&lt;TV, float>> (sourceVertex).GetEnumerator();&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;for(;iter.MoveNext();) {&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (iter.Current.Key.Equals (targetVertex)) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;TE e = (TE) delegator.Container.EdgeFactory.newInstance (sourceVertex, iter.Current.Key, iter.Current.Value);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;edges.Add (e);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;return edges;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public TE getEdge (TV sourceVertex, TV targetVertex) {&#xA;&#x9;&#x9;&#x9;&#x9;if (containsVertex (sourceVertex) &amp;&amp; containsVertex (targetVertex)) {&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;IEnumerator&lt;KeyValuePair&lt;TV, float>> iter = delegator.outgoing&lt;KeyValuePair&lt;TV, float>> (sourceVertex).GetEnumerator();&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;for(;iter.MoveNext();) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (iter.Current.Key.Equals (targetVertex)) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;TE e = (TE) delegator.Container.EdgeFactory.newInstance (sourceVertex, iter.Current.Key, iter.Current.Value);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;return e;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;return default(TE);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public TE getEdge (TE edge) {&#xA;&#x9;&#x9;&#x9;&#x9;if (containsVertex (edge.Source) &amp;&amp; containsVertex (edge.Target)) {&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;IEnumerator&lt;KeyValuePair&lt;TV, float>> iter = delegator.outgoing&lt;KeyValuePair&lt;TV, float>> (edge.Source).GetEnumerator();&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;for(;iter.MoveNext();) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (iter.Current.Key.Equals (edge.Target)) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;TE e = (TE) delegator.Container.EdgeFactory.newInstance (edge.Source, iter.Current.Key, iter.Current.Value);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;return e;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;return default(TE);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public TE addEdge (TV sourceVertex, TV targetVertex) {&#xA;&#x9;&#x9;&#x9;&#x9;if (containsVertex (sourceVertex) &amp;&amp; containsVertex (targetVertex)) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if (!delegator.Container.AllowingMultipleEdges &amp;&amp; containsEdge (sourceVertex, targetVertex)) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;return default(TE);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if (!delegator.Container.AllowingLoops &amp;&amp; sourceVertex.Equals (targetVertex)) { Console.WriteLine (&quot;LOOPS NOT ALLOWED&quot;); return default(TE); }&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;TE e = (TE) delegator.Container.EdgeFactory.newInstance (sourceVertex, targetVertex);&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;addEdgeToContainer (e);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;return e;&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;return default(TE);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public bool addEdge (TE e) {&#xA;&#x9;&#x9;&#x9;&#x9;if (e == null || e.Source == null || e.Target == null) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;return false;&#xA;&#x9;&#x9;&#x9;&#x9;} &#xA;&#x9;&#x9;&#x9;&#x9;if (containsVertex (e.Source) &amp;&amp; containsVertex (e.Target)) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if (!delegator.Container.AllowingMultipleEdges &amp;&amp; containsEdge (e.Source, e.Target)) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;return false;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if (!delegator.Container.AllowingLoops &amp;&amp; e.Source.Equals (e.Target)) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;Console.WriteLine (&quot;LOOPS NOT ALLOWED&quot;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;return false;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;addEdgeToContainer (e);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;return true;&#xA;&#x9;&#x9;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;return false;&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public bool addVertex (TV v) {&#xA;&#x9;&#x9;&#x9;&#x9;return delegator.addVertex (v);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public bool containsEdge(TV sourceVertex, TV targetVertex){&#xA;&#x9;&#x9;&#x9;&#x9;return getEdge(sourceVertex, targetVertex) != null;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public bool containsEdge(TE e){&#xA;&#x9;&#x9;&#x9;&#x9;if (e != null) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if (containsVertex (e.Source) &amp;&amp; containsVertex (e.Target))&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;return getEdge(e) != null; //container.outgoing (e.source).ContainsKey (e.target);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;else&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;return false;&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;return false;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public bool containsVertex (TV v){&#xA;&#x9;&#x9;&#x9;&#x9;if (v == null) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;Console.WriteLine (&quot;WARNING: containsVertex(parameter null!) &quot;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;return false;&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;return delegator.containsVertex (v);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public IEnumerator&lt;TE> edgeSet () {&#xA;&#x9;&#x9;&#x9;&#x9;return delegator.edgeSet ();&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public ICollection&lt;TE> edgesOf (TV vertex) {&#xA;&#x9;&#x9;&#x9;&#x9;return delegator.edgesOf (vertex);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public IEnumerator&lt;TE> iteratorEdgesOf (TV vertex) {&#xA;&#x9;&#x9;&#x9;&#x9;return delegator.iteratorEdgesOf (vertex);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public ICollection&lt;TV> neighborsOf (TV vertex){&#xA;&#x9;&#x9;&#x9;&#x9;ICollection&lt;KeyValuePair&lt;TV, float>> i = delegator.incoming&lt;KeyValuePair&lt;TV, float>> (vertex);&#xA;&#x9;&#x9;&#x9;&#x9;ICollection&lt;TV> edges = new HashSet&lt;TV> ();&#xA;&#x9;&#x9;&#x9;&#x9;foreach (KeyValuePair&lt;TV, float> kv in i)&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;edges.Add (kv.Key);&#xA;&#x9;&#x9;&#x9;&#x9;ICollection&lt;KeyValuePair&lt;TV, float>> o = delegator.outgoing&lt;KeyValuePair&lt;TV, float>> (vertex);&#xA;&#x9;&#x9;&#x9;&#x9;foreach (KeyValuePair&lt;TV, float> kv in o)&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;edges.Add (kv.Key);&#xA;&#x9;&#x9;&#x9;&#x9;return edges;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public IEnumerator&lt;TV> iteratorNeighborsOf (TV vertex){&#xA;&#x9;&#x9;&#x9;&#x9;ICollection&lt;KeyValuePair&lt;TV, float>> o = delegator.outgoing&lt;KeyValuePair&lt;TV, float>> (vertex);&#xA;&#x9;&#x9;&#x9;&#x9;ICollection&lt;KeyValuePair&lt;TV, float>> i = delegator.incoming&lt;KeyValuePair&lt;TV, float>> (vertex);&#xA;//&#x9;&#x9;&#x9;&#x9;ICollection&lt;TV> edges = new HashSet&lt;TV> ();&#xA;//&#x9;&#x9;&#x9;&#x9;if (!delegator.Container.AllowingMultipleEdges) {&#xA;//&#x9;&#x9;&#x9;&#x9;&#x9;foreach (KeyValuePair&lt;TV, float> kv in o)&#xA;//&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (!edges.Contains (kv.Key)) {&#xA;//&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;edges.Add (kv.Key);&#xA;//&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;yield return kv.Key;&#xA;//&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;//&#x9;&#x9;&#x9;&#x9;&#x9;//edges.Clear ();&#xA;//&#x9;&#x9;&#x9;&#x9;&#x9;foreach(KeyValuePair&lt;TV, float> kv in i)&#xA;//&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (!edges.Contains (kv.Key)) {&#xA;//&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;edges.Add (kv.Key);&#xA;//&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;yield return kv.Key;&#xA;//&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;//&#x9;&#x9;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;foreach(KeyValuePair&lt;TV, float> kv in o) yield return kv.Key;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;foreach(KeyValuePair&lt;TV, float> kv in i) yield return kv.Key;&#xA;//&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public bool removeAllEdges(ICollection&lt;TE> edges){&#xA;&#x9;&#x9;&#x9;&#x9;bool modified = false;&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;foreach (TE e in edges) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;modified |= removeEdge(e);&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;return modified;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public ICollection&lt;TE> removeAllEdges(TV sourceVertex, TV targetVertex){&#xA;&#x9;&#x9;&#x9;&#x9;ICollection&lt;TE> removed = getAllEdges(sourceVertex, targetVertex);&#xA;&#x9;&#x9;&#x9;&#x9;if (removed == null) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;return null;&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;removeAllEdges(removed);&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;return removed;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public bool removeAllVertices(ICollection&lt;TV> vertices){&#xA;&#x9;&#x9;&#x9;&#x9;bool modified = false;&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;foreach (TV v in vertices) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;modified |= removeVertex(v);&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;return modified;&#xA;&#x9;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;&#x9;public TE removeEdge (TV sourceVertex, TV targetVertex) {&#xA;&#x9;&#x9;&#x9;&#x9;TE e = getEdge (sourceVertex, targetVertex);&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;if (e != null) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;removeEdgeFromContainer (e);&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;return e;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public bool removeEdge (TE e) {&#xA;&#x9;&#x9;&#x9;&#x9;if (containsEdge (e)) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;removeEdgeFromContainer (e);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;return true;&#xA;&#x9;&#x9;&#x9;&#x9;} &#xA;&#x9;&#x9;&#x9;&#x9;else { return false; }&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public bool removeVertex (TV v) {&#xA;&#x9;&#x9;&#x9;&#x9;if (containsVertex (v)) { &#xA;&#x9;&#x9;&#x9;&#x9;&#x9;ICollection&lt;TE> edges = edgesOf (v);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;foreach (TE e in edges) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;removeEdgeFromContainer (e);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;return delegator.removeVertex (v);&#xA;&#x9;&#x9;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;return false;&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public ICollection&lt;TV> vertexSet () {&#xA;&#x9;&#x9;&#x9;&#x9;return delegator.vertexSet ();&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public TV getEdgeSource (TE e) {&#xA;&#x9;&#x9;&#x9;&#x9;return e.Source;&#xA;&#x9;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;&#x9;public TV getEdgeTarget (TE e) {&#xA;&#x9;&#x9;&#x9;&#x9;return e.Target; &#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public float getEdgeWeight (TE e) {&#xA;&#x9;&#x9;&#x9;&#x9;return getEdgeWeight (e.Source, e.Target);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public void setAllEdgeWeight (TE e, float weight) {&#xA;&#x9;&#x9;&#x9;&#x9;setAllEdgeWeight (e.Source, e.Target, weight);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public void setAllEdgeWeight (TV sourceVertex, TV targetVertex, float weight){&#xA;&#x9;&#x9;&#x9;&#x9;if (delegator.Container.AllowingMultipleEdges) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;ICollection&lt;TE> list = this.getAllEdges (sourceVertex, targetVertex);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;removeAllEdges (list);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;foreach (TE ei in list) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;addEdgeToContainer ( (TE) delegator.Container.EdgeFactory.newInstance(sourceVertex, targetVertex, weight));&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;bool b = removeEdge (sourceVertex, targetVertex)!=null;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if (b) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;addEdgeToContainer ( (TE) delegator.Container.EdgeFactory.newInstance(sourceVertex, targetVertex, weight));&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public float getEdgeWeight (TV sourceVertex, TV targetVertex){&#xA;&#x9;&#x9;&#x9;&#x9;TE e = this.getEdge (sourceVertex, targetVertex);&#xA;&#x9;&#x9;&#x9;&#x9;if (e != null) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;return e.Weight;&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;return 0f;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;// end interface implements&#xA;&#xA;&#x9;&#x9;&#x9;#region ICloneable implementation&#xA;&#x9;&#x9;&#x9;public object Clone () {&#xA;&#x9;&#x9;&#x9;&#x9;IGraphHelperKV&lt;V, E, TV, TE> d = (IGraphHelperKV&lt;V, E, TV, TE>) this.delegator.Clone ();&#xA;&#x9;&#x9;&#x9;&#x9;IDirectedGraphKVWeightedInstanceImpl&lt;V, E, TV, TE> clone = new IDirectedGraphKVWeightedInstanceImpl&lt;V, E, TV, TE>(d);&#xA;&#x9;&#x9;&#x9;&#x9;return clone;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;#endregion&#xA;&#xA;&#x9;&#x9;&#x9;public bool isAllowingLoops () { return delegator.Container.AllowingLoops; }&#xA;&#xA;&#x9;&#x9;&#x9;public bool isAllowingMultipleEdges () { return delegator.Container.AllowingMultipleEdges; }&#xA;&#xA;&#x9;&#x9;&#x9;public override string ToString () { &#xA;&#x9;&#x9;&#x9;&#x9;IEnumerator&lt;TV> vertexSet = this.vertexSet ().GetEnumerator();&#xA;&#x9;&#x9;&#x9;&#x9;IEnumerator&lt;TE> edgeSet = this.edgeSet ();&#xA;&#x9;&#x9;&#x9;&#x9;System.Text.StringBuilder sb = new System.Text.StringBuilder();&#xA;&#x9;&#x9;&#x9;&#x9;String ret = &quot;&quot;;&#xA;&#x9;&#x9;&#x9;&#x9;sb.Append (&quot;Vertexs [&quot;);&#xA;&#x9;&#x9;&#x9;&#x9;for(int i = 0; vertexSet.MoveNext();i++){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;sb.Append (vertexSet.Current.ToString ()+&quot;,&quot;);&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;sb.Remove (sb.Length-1, 1);&#xA;&#x9;&#x9;&#x9;&#x9;sb.Append(&quot;]&quot;);&#xA;&#x9;&#x9;&#x9;&#x9;sb.AppendLine();&#xA;&#x9;&#x9;&#x9;&#x9;sb.Append(&quot;edges&quot;);&#xA;&#x9;&#x9;&#x9;&#x9;for (int i=0; edgeSet.MoveNext(); i++) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;sb.Append(&quot;(&quot;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;sb.Append (edgeSet.Current.ToString());&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;sb.Append(&quot;) &quot;);&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;ret = sb.ToString ();&#xA;&#x9;&#x9;&#x9;&#x9;sb.Clear ();&#xA;&#x9;&#x9;&#x9;&#x9;return ret;&#xA;&#x9;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;&#x9;public void noSafeAdd(TE e){&#xA;&#x9;&#x9;&#x9;&#x9;delegator.noSafeAdd (e);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public void noSafeAdd(TV source, TV target){&#xA;&#x9;&#x9;&#x9;&#x9;delegator.noSafeAdd (source, target);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public void noSafeAdd(TV source, TV target, float weight){&#xA;&#x9;&#x9;&#x9;&#x9;delegator.noSafeAdd (source, target, weight);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public void addEdgeToContainer (TE e) {&#xA;&#x9;&#x9;&#x9;&#x9;delegator.addOutgoingEdge (e);&#xA;&#x9;&#x9;&#x9;&#x9;delegator.addIncomingEdge (e);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public int inDegreeOf (TV vertex) {&#xA;&#x9;&#x9;&#x9;&#x9;return delegator.incoming&lt;KeyValuePair&lt;TV, float>> (vertex).Count;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public int outDegreeOf (TV vertex) {&#xA;&#x9;&#x9;&#x9;&#x9;return delegator.outgoing&lt;KeyValuePair&lt;TV, float>> (vertex).Count;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public ICollection&lt;TE> incomingEdgesOf (TV vertex) {&#xA;&#x9;&#x9;&#x9;&#x9;ICollection&lt;KeyValuePair&lt;TV, float>> incoming_list = delegator.incoming&lt;KeyValuePair&lt;TV, float>> (vertex);&#xA;&#x9;&#x9;&#x9;&#x9;ICollection&lt;TE> edges;&#xA;&#x9;&#x9;&#x9;&#x9;if (!delegator.Container.AllowingMultipleEdges)&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;edges = new HashSet&lt;TE> ();&#xA;&#x9;&#x9;&#x9;&#x9;else&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;edges = new List&lt;TE> ();&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;foreach (KeyValuePair&lt;TV, float> kv in incoming_list)&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;edges.Add ((TE) delegator.Container.EdgeFactory.newInstance(kv.Key, vertex, kv.Value));&#xA;&#x9;&#x9;&#x9;&#x9;return edges;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public ICollection&lt;TE> outgoingEdgesOf (TV vertex) {&#xA;&#x9;&#x9;&#x9;&#x9;ICollection&lt;KeyValuePair&lt;TV, float>> outgoing_list = delegator.outgoing&lt;KeyValuePair&lt;TV, float>> (vertex);&#xA;&#x9;&#x9;&#x9;&#x9;ICollection&lt;TE> edges;&#xA;&#x9;&#x9;&#x9;&#x9;if (!delegator.Container.AllowingMultipleEdges)&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;edges = new HashSet&lt;TE> ();&#xA;&#x9;&#x9;&#x9;&#x9;else&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;edges = new List&lt;TE> ();&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;foreach (KeyValuePair&lt;TV, float> kv in outgoing_list)&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;edges.Add ((TE) delegator.Container.EdgeFactory.newInstance(vertex, kv.Key, kv.Value));&#xA;&#x9;&#x9;&#x9;&#x9;return edges;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;//&#xA;&#x9;&#x9;&#x9;public IEnumerator&lt;KeyValuePair&lt;TV, float>> iteratorVertexWeightOf(TV vertex){&#xA;&#x9;&#x9;&#x9;&#x9;ICollection&lt;KeyValuePair&lt;TV, float>> o = delegator.outgoing&lt;KeyValuePair&lt;TV, float>> (vertex);&#xA;&#x9;&#x9;&#x9;&#x9;ICollection&lt;KeyValuePair&lt;TV, float>> i = delegator.incoming&lt;KeyValuePair&lt;TV, float>> (vertex);&#xA;&#x9;&#x9;&#x9;&#x9;ICollection&lt;TV> edges = new HashSet&lt;TV> ();&#xA;&#x9;&#x9;&#x9;&#x9;if (!delegator.Container.AllowingMultipleEdges) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;foreach (KeyValuePair&lt;TV, float> kv in o) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;bool contain = edges.Contains (kv.Key);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (!contain) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;edges.Add (kv.Key);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;yield return kv;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;edges.Clear ();&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;foreach (KeyValuePair&lt;TV, float> kv in i) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;bool contain = edges.Contains (kv.Key);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (!contain) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;edges.Add (kv.Key);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;yield return kv;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;foreach (KeyValuePair&lt;TV, float> kv in o) yield return kv;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;foreach (KeyValuePair&lt;TV, float> kv in i) yield return kv;&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public IEnumerator&lt;KeyValuePair&lt;TV, float>> iteratorOutgoingVertexWeightOf(TV vertex){&#xA;&#x9;&#x9;&#x9;&#x9;ICollection&lt;KeyValuePair&lt;TV, float>> outgoing_list = delegator.outgoing&lt;KeyValuePair&lt;TV, float>> (vertex);&#xA;&#x9;&#x9;&#x9;&#x9;ICollection&lt;TV> edges;&#xA;&#x9;&#x9;&#x9;&#x9;if (!delegator.Container.AllowingMultipleEdges) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;edges = new HashSet&lt;TV> ();&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;foreach (KeyValuePair&lt;TV, float> kv in outgoing_list) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;bool contain = edges.Contains (kv.Key);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (!contain) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;edges.Add (kv.Key);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;yield return kv;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;else&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;foreach (KeyValuePair&lt;TV, float> kv in outgoing_list)&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;yield return kv;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public ICollection&lt;TV> outgoingVertexOf (TV vertex) {&#xA;&#x9;&#x9;&#x9;&#x9;ICollection&lt;KeyValuePair&lt;TV, float>> outgoing_list = delegator.outgoing&lt;KeyValuePair&lt;TV, float>> (vertex);&#xA;&#x9;&#x9;&#x9;&#x9;ICollection&lt;TV> edges;&#xA;&#x9;&#x9;&#x9;&#x9;if (!delegator.Container.AllowingMultipleEdges)&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;edges = new HashSet&lt;TV> ();&#xA;&#x9;&#x9;&#x9;&#x9;else&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;edges = new List&lt;TV> ();&#xA;&#x9;&#x9;&#x9;&#x9;foreach (KeyValuePair&lt;TV, float> kv in outgoing_list)&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;edges.Add (kv.Key);&#xA;&#x9;&#x9;&#x9;&#x9;return edges;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public IEnumerator&lt;TV> iteratorOutgoingVertexOf(TV vertex){&#xA;&#x9;&#x9;&#x9;&#x9;ICollection&lt;KeyValuePair&lt;TV, float>> outgoing_list = delegator.outgoing&lt;KeyValuePair&lt;TV, float>> (vertex);&#xA;&#x9;&#x9;&#x9;&#x9;ICollection&lt;TV> edges;&#xA;&#x9;&#x9;&#x9;&#x9;if (!delegator.Container.AllowingMultipleEdges) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;edges = new HashSet&lt;TV> ();&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;foreach (KeyValuePair&lt;TV, float> kv in outgoing_list) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;bool contain = edges.Contains (kv.Key);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (!contain) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;edges.Add (kv.Key);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;yield return kv.Key;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;else&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;foreach (KeyValuePair&lt;TV, float> kv in outgoing_list)&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;yield return kv.Key;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;//&#xA;&#x9;&#x9;&#x9;public void removeEdgeFromContainer (TE e) {&#xA;&#x9;&#x9;&#x9;&#x9;delegator.removeOutgoingEdge (e);&#xA;&#x9;&#x9;&#x9;&#x9;delegator.removeIncomingEdge (e);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public int countE() { return delegator.countE(); }&#xA;&#x9;&#x9;&#x9;public int countV() { return delegator.countV(); }&#xA;&#x9;&#x9;&#x9;public int degreeOf(TV vertex) { &#xA;&#x9;&#x9;&#x9;&#x9;return delegator.degreeOf (vertex);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;public interface IGraphHelperKV&lt;V, E, TV, TE>: IGraphHelper&lt;V, E, TV, TE> &#xA;&#x9;&#x9;&#x9;where V:IVertex where E:IEdge&lt;V> where TE: IEdgeInstance&lt;V, TV> {&#xA;&#x9;&#x9;&#x9;IDataContainerKVInstance&lt;V, E, TV, TE> Container { get; set; }&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;internal class IGraphHelperKVImpl&lt;V, E, TV, TE>: IGraphHelperKV&lt;V, E, TV, TE> &#xA;&#x9;&#x9;&#x9;where V:IVertex &#xA;&#x9;&#x9;&#x9;where E:IEdge&lt;V>&#xA;&#x9;&#x9;&#x9;where TE: IEdgeInstance&lt;V, TV> {&#xA;&#xA;&#x9;&#x9;&#x9;private int count_edges = 0;&#xA;&#x9;&#x9;&#x9;private IDataContainerKVInstance&lt;V, E, TV, TE> container;&#xA;&#xA;&#x9;&#x9;&#x9;public IGraphHelperKVImpl (IDataContainerKVInstance&lt;V, E, TV, TE> c) {&#xA;&#x9;&#x9;&#x9;&#x9;container = c;&#xA;&#x9;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;&#x9;public IDataContainerKVInstance&lt;V, E, TV, TE> Container{&#xA;&#x9;&#x9;&#x9;&#x9;get{ return this.container; }&#xA;&#x9;&#x9;&#x9;&#x9;set{ this.container = (IDataContainerKVInstance&lt;V, E, TV, TE>)value; }&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public IDataContainerInstance&lt;V, E> DataContainer{&#xA;&#x9;&#x9;&#x9;&#x9;get{ return this.container; }&#xA;&#x9;&#x9;&#x9;&#x9;set{ this.container = (IDataContainerKVInstance&lt;V, E, TV, TE>)value; }&#xA;&#x9;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;&#x9;#region ICloneable implementation&#xA;&#x9;&#x9;&#x9;public object Clone () {&#xA;&#x9;&#x9;&#x9;&#x9;IDataContainerKVInstance&lt;V, E, TV, TE> c = (IDataContainerKVInstance&lt;V, E, TV, TE>) this.Container.Clone ();&#xA;&#x9;&#x9;&#x9;&#x9;IGraphHelperKVImpl&lt;V, E, TV, TE> clone = new IGraphHelperKVImpl&lt;V, E, TV, TE> (c);&#xA;&#x9;&#x9;&#x9;&#x9;clone.count_edges = this.count_edges;&#xA;&#x9;&#x9;&#x9;&#x9;return clone;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;#endregion&#xA;&#xA;&#x9;&#x9;&#x9;public IEnumerator&lt;TE> edgeSet () {&#xA;&#x9;&#x9;&#x9;&#x9;ICollection&lt;TV> collection = container.DataSet.Keys;&#xA;&#x9;&#x9;&#x9;&#x9;foreach (TV v in collection) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;IEdgeContainer&lt;KeyValuePair&lt;TV, float>> ec = container.DataSet[v];&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;IEnumerator&lt;KeyValuePair&lt;TV, float>> iterator = ec.incoming.GetEnumerator();&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;while (iterator.MoveNext ()) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;TE edge = (TE)container.EdgeFactory.newInstance (iterator.Current.Key, v, iterator.Current.Value);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;yield return edge;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public ICollection&lt;TE> edgesOf (TV vertex) {&#xA;&#x9;&#x9;&#x9;&#x9;IEdgeContainer&lt;KeyValuePair&lt;TV, float>> ec;&#xA;&#x9;&#x9;&#x9;&#x9;ICollection&lt;TE> edges;&#xA;&#x9;&#x9;&#x9;&#x9;if (!container.AllowingMultipleEdges)&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;edges = new HashSet&lt;TE> ();&#xA;&#x9;&#x9;&#x9;&#x9;else&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;edges = new List&lt;TE> ();&#xA;&#x9;&#x9;&#x9;&#x9;if (container.DataSet.TryGetValue (vertex, out ec)) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;foreach (KeyValuePair&lt;TV, float> kv in ec.incoming)&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;edges.Add ((TE)container.EdgeFactory.newInstance(kv.Key, vertex, kv.Value));&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;foreach (KeyValuePair&lt;TV, float> kv in ec.outgoing) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if(!vertex.Equals(kv.Key)) edges.Add ((TE)container.EdgeFactory.newInstance (vertex, kv.Key, kv.Value));&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;return edges;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public IEnumerator&lt;TE> iteratorEdgesOf (TV vertex) {&#xA;&#x9;&#x9;&#x9;&#x9;IEdgeContainer&lt;KeyValuePair&lt;TV, float>> ec;&#xA;&#x9;&#x9;&#x9;&#x9;if (container.DataSet.TryGetValue (vertex, out ec)) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;foreach (KeyValuePair&lt;TV, float> kv in ec.incoming)&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;yield return ((TE)container.EdgeFactory.newInstance(kv.Key, vertex, kv.Value));&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;foreach (KeyValuePair&lt;TV, float> kv in ec.outgoing) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if(!vertex.Equals(kv.Key)) yield return ((TE)container.EdgeFactory.newInstance (vertex, kv.Key, kv.Value));&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public ICollection&lt;TV> vertexSet () {&#xA;&#x9;&#x9;&#x9;&#x9;return container.DataSet.Keys;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public void addIncomingEdge (TE e) {&#xA;&#x9;&#x9;&#x9;&#x9;KeyValuePair&lt;TV, float> kv = new KeyValuePair&lt;TV, float>(e.Source, e.Weight);&#xA;&#x9;&#x9;&#x9;&#x9;container.DataSet [e.Target].incoming.Add (kv);&#xA;&#x9;&#x9;&#x9;&#x9;count_edges++;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public void addOutgoingEdge (TE e) {&#xA;&#x9;&#x9;&#x9;&#x9;KeyValuePair&lt;TV, float> kv = new KeyValuePair&lt;TV, float>(e.Target, e.Weight);&#xA;&#x9;&#x9;&#x9;&#x9;container.DataSet [e.Source].outgoing.Add (kv);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public void removeIncomingEdge (TE e) { &#xA;&#x9;&#x9;&#x9;&#x9;KeyValuePair&lt;TV, float> kv = new KeyValuePair&lt;TV, float>(e.Source, e.Weight);&#xA;&#x9;&#x9;&#x9;&#x9;container.DataSet [e.Target].incoming.Remove (kv);&#xA;&#x9;&#x9;&#x9;&#x9;count_edges--;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public void removeOutgoingEdge (TE e) {&#xA;&#x9;&#x9;&#x9;&#x9;KeyValuePair&lt;TV, float> kv = new KeyValuePair&lt;TV, float>(e.Target, e.Weight);&#xA;&#x9;&#x9;&#x9;&#x9;container.DataSet [e.Source].outgoing.Remove (kv); &#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public void noSafeAdd(TE e){&#xA;&#x9;&#x9;&#x9;&#x9;addOutgoingEdge (e);&#xA;&#x9;&#x9;&#x9;&#x9;addIncomingEdge (e);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public void noSafeAdd(TV source, TV target){&#xA;&#x9;&#x9;&#x9;&#x9;KeyValuePair&lt;TV, float> kv1 = new KeyValuePair&lt;TV, float>(target, 1.0f);&#xA;&#x9;&#x9;&#x9;&#x9;container.DataSet [source].outgoing.Add (kv1);&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;KeyValuePair&lt;TV, float> kv2 = new KeyValuePair&lt;TV, float>(source, 1.0f);&#xA;&#x9;&#x9;&#x9;&#x9;container.DataSet [target].incoming.Add (kv2);&#xA;&#x9;&#x9;&#x9;&#x9;count_edges++;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public void noSafeAdd(TV source, TV target, float weight){&#xA;&#x9;&#x9;&#x9;&#x9;KeyValuePair&lt;TV, float> kv1 = new KeyValuePair&lt;TV, float>(target, weight);&#xA;&#x9;&#x9;&#x9;&#x9;container.DataSet [source].outgoing.Add (kv1);&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;KeyValuePair&lt;TV, float> kv2 = new KeyValuePair&lt;TV, float>(source, weight);&#xA;&#x9;&#x9;&#x9;&#x9;container.DataSet [target].incoming.Add (kv2);&#xA;&#x9;&#x9;&#x9;&#x9;count_edges++;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public ICollection&lt;T> incoming&lt;T>(TV vertex){&#xA;&#x9;&#x9;&#x9;&#x9;IEdgeContainer&lt;KeyValuePair&lt;TV, float>> ec;&#xA;&#x9;&#x9;&#x9;&#x9;if (container.DataSet.TryGetValue (vertex, out ec))&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;return ((List&lt;T>)ec.incoming).AsReadOnly();&#xA;&#x9;&#x9;&#x9;&#x9;return new List&lt;T>();&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public ICollection&lt;T> outgoing&lt;T>(TV vertex){&#xA;&#x9;&#x9;&#x9;&#x9;IEdgeContainer&lt;KeyValuePair&lt;TV, float>> ec;&#xA;&#x9;&#x9;&#x9;&#x9;if (container.DataSet.TryGetValue (vertex, out ec))&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;return ((List&lt;T>)ec.outgoing).AsReadOnly();&#xA;&#x9;&#x9;&#x9;&#x9;return new List&lt;T> ();&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public bool addVertex (TV vertex) {&#xA;&#x9;&#x9;&#x9;&#x9;if (container.DataSet.ContainsKey (vertex)) return false;&#xA;&#x9;&#x9;&#x9;&#x9;else { &#xA;&#x9;&#x9;&#x9;&#x9;&#x9;IEdgeContainer&lt;KeyValuePair&lt;TV, float>> ec = new EdgeContainer&lt;KeyValuePair&lt;TV, float>>(); ec.outgoing = new List&lt;KeyValuePair&lt;TV, float>> (); ec.incoming = new List&lt;KeyValuePair&lt;TV, float>> ();&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;container.DataSet[vertex] = ec;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;return true; &#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public bool containsEdge(TE e){&#xA;&#x9;&#x9;&#x9;&#x9;KeyValuePair&lt;TV, float> kv = new KeyValuePair&lt;TV, float> (e.Target, e.Weight);&#xA;&#x9;&#x9;&#x9;&#x9;return container.DataSet [e.Source].outgoing.Contains (kv);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public bool containsVertex (TV v){ &#xA;&#x9;&#x9;&#x9;&#x9;return container.DataSet.ContainsKey (v); &#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public bool removeVertex (TV v) { &#xA;&#x9;&#x9;&#x9;&#x9;return container.DataSet.Remove (v);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public int countE() { return count_edges; }&#xA;&#x9;&#x9;&#x9;public int countV() { return container.DataSet.Count; }&#xA;&#x9;&#x9;&#x9;public int degreeOf(TV v) { &#xA;&#x9;&#x9;&#x9;&#x9;IEdgeContainer&lt;KeyValuePair&lt;TV, float>> ec; &#xA;&#x9;&#x9;&#x9;&#x9;if (container.DataSet.TryGetValue (v, out ec)) &#xA;&#x9;&#x9;&#x9;&#x9;&#x9;return ec.outgoing.Count + ec.incoming.Count; &#xA;&#x9;&#x9;&#x9;&#x9;return 0; &#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;}&#xA;" name="IDirectedGraphKVWeightedImpl.cs" srcType="user" uri="br.ufc.mdcc.hpcshelf.gust.graph.impl.DirectedGraphKVWeightedImpl/bin/1.0.0.0/IDirectedGraphKVWeightedImpl.dll" versionId="1.0.0.0">
          <dependency>br.ufc.mdcc.hpcshelf.gust.graph.container.DataContainerKV/bin/1.0.0.0/IDataContainerKV.dll</dependency>
          <dependency>br.ufc.mdcc.hpcshelf.gust.graph.Vertex/bin/1.0.0.0/IVertex.dll</dependency>
          <dependency>br.ufc.mdcc.hpcshelf.gust.graph.Edge/bin/1.0.0.0/IEdge.dll</dependency>
          <dependency>%WORKSPACE/br.ufc.mdcc.hpcshelf.gust.graph.impl.DirectedGraphKVWeightedImpl/bin/1.0.0.0/BaseIDirectedGraphKVWeightedImpl.dll</dependency>
          <dependency>br.ufc.mdcc.hpcshelf.gust.graph.DirectedGraph/bin/1.0.0.0/IDirectedGraph.dll</dependency>
        </file>
      </sources>
      <visualDescription h="40" w="252" x="133" y="181">
        <color b="207" g="159" r="114"/>
      </visualDescription>
      <parameter iname="IDataContainerKV" parid="container" uname="data" varid="CTN"/>
      <parameter iname="IEdge" order="1" parid="edge_type" uname="data" varid="E"/>
      <parameter iname="IVertex" order="0" parid="vertex_type" uname="data" varid="V"/>
    </interface>
    <unit facet="0" iRef="IDirectedGraphKVWeightedImpl" multiple="false" private="false" replica="0" uRef="data" visibleInterface="true">
      <super cRef="base" uRef="data"/>
      <visualDescription h="40" w="80" x="323" y="222"/>
    </unit>
  </componentInfo>
</component:component>