<?xml version="1.0" encoding="ASCII"?>
<component:component xmlns:component="http://www.example.org/HashComponent">
  <header hash_component_UID="0024000004800000940000000602000000240000525341310004000011000000176c5f21ca67836a210fe6ec503d5ae1d6d12cd315c1faca00d74e859056c290fb2b24ae6079ecb6c1f2320e4456d729146375f5abc082c7528a84e40840f02377144c01a4f9fba61beb39899b7b7852e362c83152b827199d57cc2d85495072d17b8efeebe1f9de0b7a33baabe39b5b5abf77452cd884d67ccc0cebb2ff65ad" isAbstract="false" kind="Data" name="UndirectedGraphVImpl" packagePath="br.ufc.mdcc.hpcshelf.gust.graph.impl">
    <baseType>
      <extensionType>
        <implements>true</implements>
      </extensionType>
      <component hash_component_UID="0024000004800000940000000602000000240000525341310004000011000000fb4da1412c4edb36db2d6a11df0060ac38aa48d250c592357e366179f1459959fb9a88740ca1e6dd07f4b612e8d3034bb19c7b9f817af432eb194570c601ab91fcd5aa0e0ac6d648c01874c21652cff20b5eb559ff4123b0981ac926ec6bbe71b887319f36d384e02385bc456cf3b9826d2da1e053b1481a6ecd10bf7b14069b" localRef="base" location="br.ufc.mdcc.hpcshelf.gust.graph.UndirectedGraph/UndirectedGraph.hpe" name="UndirectedGraph" package="br.ufc.mdcc.hpcshelf.gust.graph" version="1.0.0.0">
        <visualDescription h="60" w="100" x="302" y="342">
          <color b="255" g="255" r="255"/>
        </visualDescription>
        <parameter formFieldId="container" varName="CTN"/>
        <parameter formFieldId="vertex_type" varName="V"/>
        <parameter formFieldId="edge_type" varName="E"/>
        <unitBounds facet="0" facet_instance="0" facet_instance_enclosing="0" parallel="false" uRef="data">
          <visualDescription h="20" w="20" x="5" y="2"/>
        </unitBounds>
      </component>
    </baseType>
    <versions field1="1" field2="0" field3="0" field4="0"/>
    <visualAttributes>
      <color b="255" g="255" r="255"/>
    </visualAttributes>
    <facet_configuration facet="0" multiple="false"/>
  </header>
  <componentInfo>
    <innerComponent localRef="v" location="br.ufc.mdcc.hpcshelf.gust.graph.Vertex/Vertex.hpe" multiple="false" name="Vertex" package="br.ufc.mdcc.hpcshelf.gust.graph" exposed="true">
      <visualDescription h="60" w="142" x="98" y="346">
        <color b="255" g="255" r="255"/>
      </visualDescription>
      <unitBounds facet="0" facet_instance="0" parallel="false" uRef="data">
        <visualDescription h="20" w="20" x="5" y="2"/>
      </unitBounds>
    </innerComponent>
    <innerComponent localRef="e" location="br.ufc.mdcc.hpcshelf.gust.graph.Edge/Edge.hpe" multiple="false" name="Edge" package="br.ufc.mdcc.hpcshelf.gust.graph" exposed="true">
      <visualDescription h="60" w="161" x="465" y="336">
        <color b="255" g="255" r="255"/>
      </visualDescription>
      <parameter formFieldId="vertex_type" varName="V"/>
      <unitBounds facet="0" facet_instance="0" parallel="false" uRef="data">
        <visualDescription h="20" w="20" x="5" y="2"/>
      </unitBounds>
    </innerComponent>
    <innerComponent localRef="ctn" location="br.ufc.mdcc.hpcshelf.gust.graph.container.DataContainerV/DataContainerV.hpe" multiple="false" name="DataContainerV" package="br.ufc.mdcc.hpcshelf.gust.graph.container" exposed="true">
      <visualDescription h="60" w="187" x="304" y="478">
        <color b="255" g="255" r="255"/>
      </visualDescription>
      <parameter formFieldId="vertex_type" varName="V"/>
      <parameter formFieldId="edge_type" varName="E"/>
      <unitBounds facet="0" facet_instance="0" parallel="false" uRef="data">
        <visualDescription h="20" w="20" x="5" y="2"/>
      </unitBounds>
    </innerComponent>
    <supplyParameter cRef="v" direct="true" varName="V"/>
    <supplyParameter cRef="e" direct="true" varName="E"/>
    <supplyParameter cRef="ctn" direct="true" varName="CTN"/>
    <interface iRef="IUndirectedGraphVImpl" nArgs="3">
      <sources sourceType="C# Language" versionId="1.0.0.0">
        <file contents="/* Automatically Generated Code */&#xA;&#xA;using System;&#xA;using br.ufc.pargo.hpe.backend.DGAC;&#xA;using br.ufc.pargo.hpe.basic;&#xA;using br.ufc.pargo.hpe.kinds;&#xA;using br.ufc.mdcc.hpcshelf.gust.graph.Edge;&#xA;using br.ufc.mdcc.hpcshelf.gust.graph.Vertex;&#xA;using br.ufc.mdcc.hpcshelf.gust.graph.container.DataContainer;&#xA;using br.ufc.mdcc.hpcshelf.gust.graph.container.DataContainerV;&#xA;using br.ufc.mdcc.hpcshelf.gust.graph.UndirectedGraph;&#xA;&#xA;namespace br.ufc.mdcc.hpcshelf.gust.graph.impl.UndirectedGraphVImpl &#xA;{&#xA;&#x9;public abstract class BaseIUndirectedGraphVImpl&lt;CTN, V, E>: DataStructure, BaseIUndirectedGraph&lt;CTN, V, E>&#xA;&#x9;&#x9;where CTN:IDataContainerV&lt;V, E>&#xA;&#x9;&#x9;where V:IVertex&#xA;&#x9;&#x9;where E:IEdge&lt;V>&#xA;&#x9;{&#xA;&#x9;&#x9;private E edgeFactory = default(E);&#xA;&#xA;&#x9;&#x9;public E EdgeFactory&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;get&#xA;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;if (this.edgeFactory == null)&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;this.edgeFactory = (E) Services.getPort(&quot;edgeFactory&quot;);&#xA;&#x9;&#x9;&#x9;&#x9;return this.edgeFactory;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;private V vertex = default(V);&#xA;&#xA;&#x9;&#x9;public V Vertex&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;get&#xA;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;if (this.vertex == null)&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;this.vertex = (V) Services.getPort(&quot;vertex&quot;);&#xA;&#x9;&#x9;&#x9;&#x9;return this.vertex;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;private CTN dataContainer = default(CTN);&#xA;&#xA;&#x9;&#x9;public CTN DataContainer&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;get&#xA;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;if (this.dataContainer == null)&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;this.dataContainer = (CTN) Services.getPort(&quot;dataContainer&quot;);&#xA;&#x9;&#x9;&#x9;&#x9;return this.dataContainer;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;}" name="BaseIUndirectedGraphVImpl.cs" srcType="base" uri="br.ufc.mdcc.hpcshelf.gust.graph.impl.UndirectedGraphVImpl/bin/1.0.0.0/BaseIUndirectedGraphVImpl.dll" versionId="1.0.0.0">
          <dependency>br.ufc.mdcc.hpcshelf.gust.graph.Edge/bin/1.0.0.0/IEdge.dll</dependency>
          <dependency>br.ufc.mdcc.hpcshelf.gust.graph.Vertex/bin/1.0.0.0/IVertex.dll</dependency>
          <dependency>br.ufc.mdcc.hpcshelf.gust.graph.container.DataContainer/bin/1.0.0.0/IDataContainer.dll</dependency>
          <dependency>br.ufc.mdcc.hpcshelf.gust.graph.container.DataContainerV/bin/1.0.0.0/IDataContainerV.dll</dependency>
          <dependency>br.ufc.mdcc.hpcshelf.gust.graph.UndirectedGraph/bin/1.0.0.0/BaseIUndirectedGraph.dll</dependency>
        </file>
        <file contents="using System;&#xA;using System.Collections.Generic;&#xA;using System.Linq;&#xA;using br.ufc.pargo.hpe.backend.DGAC;&#xA;using br.ufc.pargo.hpe.basic;&#xA;using br.ufc.pargo.hpe.kinds;&#xA;using br.ufc.mdcc.hpcshelf.gust.graph.container.DataContainerV;&#xA;using br.ufc.mdcc.hpcshelf.gust.graph.container.DataContainer;&#xA;using br.ufc.mdcc.hpcshelf.gust.graph.Vertex;&#xA;using br.ufc.mdcc.hpcshelf.gust.graph.Edge;&#xA;using br.ufc.mdcc.hpcshelf.gust.graph.UndirectedGraph;&#xA;using br.ufc.mdcc.hpcshelf.gust.graph.Graph;&#xA;&#xA;namespace br.ufc.mdcc.hpcshelf.gust.graph.impl.UndirectedGraphVImpl&#xA;{&#xA;&#x9;public class IUndirectedGraphVImpl&lt;CTN, V, E> : BaseIUndirectedGraphVImpl&lt;CTN, V, E>, IUndirectedGraph&lt;CTN, V, E>&#xA;where CTN:IDataContainerV&lt;V, E>&#xA;where V:IVertex&#xA;where E:IEdge&lt;V> {&#xA;&#xA;&#x9;&#x9;override public void after_initialize()&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;newInstance(); &#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;public object newInstance () {&#xA;&#x9;&#x9;&#x9;return newInstance (0);&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;public object Instance {&#xA;&#x9;&#x9;&#x9;get { return graphInstanceT; }&#xA;&#x9;&#x9;&#x9;set { this.graphInstanceT = value; }&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;private object graphInstanceT = null;&#xA;&#x9;&#x9;public object GraphInstanceT { &#xA;&#x9;&#x9;&#x9;get{ &#xA;&#x9;&#x9;&#x9;&#x9;return this.graphInstanceT;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;public IUndirectedGraphInstance&lt;V, E, TV, TE> newInstanceT&lt;TV, TE> (TE e, int size)  where TE: IEdgeInstance&lt;V, TV> {&#xA;&#x9;&#x9;&#x9;IDataContainerVInstance&lt;V, E, TV, TE> dc = DataContainer.InstanceTFactory&lt;TV, TE>(e);&#xA;&#x9;&#x9;&#x9;dc.newDataSet (size);&#xA;&#x9;&#x9;&#x9;IGraphHelperV&lt;V, E, TV, TE> h = new IGraphHelperVImpl&lt;V, E, TV, TE>(dc);&#xA;&#x9;&#x9;&#x9;this.graphInstanceT = new IUndirectedGraphVInstanceImpl&lt;V, E, TV, TE> (h);&#xA;&#x9;&#x9;&#x9;return (IUndirectedGraphInstance&lt;V, E, TV, TE>) this.graphInstanceT;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;public IUndirectedGraphInstance&lt;V, E, int, IEdgeInstance&lt;V, int>> newInstance(int size) {&#xA;&#x9;&#x9;&#x9;IDataContainerVInstance&lt;V, E, int, IEdgeInstance&lt;V, int>> dc = DataContainer.DataContainerVInstance;&#xA;&#x9;&#x9;&#x9;dc.newDataSet (size);&#xA;&#x9;&#x9;&#x9;IGraphHelperV&lt;V, E, int, IEdgeInstance&lt;V, int>> h = new IGraphHelperVImpl&lt;V, E, int, IEdgeInstance&lt;V, int>>(dc);&#xA;&#x9;&#x9;&#x9;this.graphInstanceT = new IUndirectedGraphVInstanceImpl&lt;V, E, int, IEdgeInstance&lt;V, int>> (h);&#xA;&#x9;&#x9;&#x9;return (IUndirectedGraphInstance&lt;V, E, int, IEdgeInstance&lt;V, int>>) this.graphInstanceT;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;public class IUndirectedGraphVInstanceImpl&lt;V, E, TV, TE>: IUndirectedGraphInstance&lt;V, E, TV, TE> &#xA;&#x9;&#x9;&#x9;where V:IVertex  &#xA;&#x9;&#x9;&#x9;where E:IEdge&lt;V> &#xA;&#x9;&#x9;&#x9;where TE: IEdgeInstance&lt;V, TV> {&#xA;&#xA;&#x9;&#x9;&#x9;public IGraphHelperV&lt;V, E, TV, TE> delegator;&#xA;&#xA;&#x9;&#x9;&#x9;public IDataContainerInstance&lt;V, E> DataContainer{&#xA;&#x9;&#x9;&#x9;&#x9;get{ return this.delegator.Container; }&#xA;&#x9;&#x9;&#x9;&#x9;set{ this.delegator.Container = (IDataContainerVInstance&lt;V, E, TV, TE>)value; }&#xA;&#x9;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;&#x9;public IUndirectedGraphVInstanceImpl(IGraphHelperV&lt;V, E, TV, TE> d){&#xA;&#x9;&#x9;&#x9;&#x9;delegator = d;&#xA;&#x9;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;&#x9;public object ObjValue {&#xA;&#x9;&#x9;&#x9;&#x9;get { return new Tuple&lt;IGraphHelperV&lt;V, E, TV, TE>>(delegator); }&#xA;&#x9;&#x9;&#x9;&#x9;set { &#xA;&#x9;&#x9;&#x9;&#x9;&#x9;this.delegator = ((Tuple&lt;IGraphHelperV&lt;V, E, TV, TE>>)value).Item1;&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;&#x9;//************** implementation ***********************&#xA;&#x9;&#x9;&#x9;public ICollection&lt;TE> getAllEdges (TV sourceVertex, TV targetVertex) {&#xA;&#x9;&#x9;&#x9;&#x9;ICollection&lt;TE> edges = null;&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;if (containsVertex (sourceVertex) &amp;&amp; containsVertex (targetVertex)) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;edges = new List&lt;TE>();&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;IEnumerator&lt;TE> iter = iteratorEdgesOf (sourceVertex);//.GetEnumerator ();&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;while (iter.MoveNext ()) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;TE e = iter.Current;&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;bool equal = isEqualsStraightOrInverted (sourceVertex, targetVertex, e);&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (equal) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;edges.Add (e);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;return edges;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public TE getEdge (TV sourceVertex, TV targetVertex) {&#xA;&#x9;&#x9;&#x9;&#x9;if (containsVertex (sourceVertex) &amp;&amp; containsVertex (targetVertex)) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;IEnumerator&lt;TE> iter = iteratorEdgesOf (sourceVertex);//.GetEnumerator ();&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;while (iter.MoveNext ()) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;TE e = iter.Current;&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;bool equal = isEqualsStraightOrInverted (sourceVertex, targetVertex, e);&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (equal) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;return e;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;return default(TE);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public TE addEdge (TV sourceVertex, TV targetVertex) {&#xA;&#x9;&#x9;&#x9;&#x9;if (containsVertex (sourceVertex) &amp;&amp; containsVertex (targetVertex)) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if (!delegator.Container.AllowingMultipleEdges &amp;&amp; containsEdge (sourceVertex, targetVertex)) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;return default(TE);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if (!delegator.Container.AllowingLoops &amp;&amp; sourceVertex.Equals (targetVertex)) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;Console.WriteLine (&quot;LOOPS NOT ALLOWED&quot;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;return default(TE);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;TE e = (TE) delegator.Container.EdgeFactory.newInstance (sourceVertex, targetVertex);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;addEdgeToContainer(e);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;return e;&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;return default(TE);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public bool addEdge (TE e) {&#xA;&#x9;&#x9;&#x9;&#x9;if (e == null || e.Source == null || e.Target == null) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;return false;&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;if (containsVertex (e.Source) &amp;&amp; containsVertex (e.Target)) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if (!delegator.Container.AllowingMultipleEdges &amp;&amp; containsEdge (e.Source, e.Target)) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;return false;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if (!delegator.Container.AllowingLoops &amp;&amp; e.Source.Equals (e.Target)) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;Console.WriteLine (&quot;LOOPS NOT ALLOWED&quot;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;return false;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;addEdgeToContainer(e);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;return true;&#xA;&#x9;&#x9;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;return false;&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public bool addVertex (TV v) {&#xA;&#x9;&#x9;&#x9;&#x9;return delegator.addVertex (v);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public bool containsEdge(TV sourceVertex, TV targetVertex){&#xA;&#x9;&#x9;&#x9;&#x9;return delegator.outgoing&lt;TV> (sourceVertex).Contains (targetVertex) || delegator.outgoing&lt;TV> (targetVertex).Contains (sourceVertex); //getEdge(sourceVertex, targetVertex) != null;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public bool containsEdge(TE e){&#xA;&#x9;&#x9;&#x9;&#x9;if (e != null) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if (containsVertex (e.Source) &amp;&amp; containsVertex (e.Target))&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;return delegator.containsEdge (e);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;else&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;return false;&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;return false;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public bool containsVertex (TV v){&#xA;&#x9;&#x9;&#x9;&#x9;if (v == null) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;Console.WriteLine (&quot;WARNING: containsVertex(parameter null!) &quot;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;return false;&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;return delegator.containsVertex (v);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public IEnumerator&lt;TE> edgeSet () {&#xA;&#x9;&#x9;&#x9;&#x9;return delegator.edgeSet ();&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public ICollection&lt;TE> edgesOf (TV vertex) {&#xA;&#x9;&#x9;&#x9;&#x9;return delegator.edgesOf (vertex);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public IEnumerator&lt;TE> iteratorEdgesOf (TV vertex) {&#xA;&#x9;&#x9;&#x9;&#x9;return delegator.iteratorEdgesOf (vertex);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public ICollection&lt;TV> neighborsOf (TV vertex){&#xA;&#x9;&#x9;&#x9;&#x9;ICollection&lt;TV> o = delegator.outgoing&lt;TV> (vertex);&#xA;&#x9;&#x9;&#x9;&#x9;ICollection&lt;TV> i = delegator.incoming&lt;TV> (vertex);&#xA;&#x9;&#x9;&#x9;&#x9;return new HashSet&lt;TV> (o.Union (i));&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public IEnumerator&lt;TV> iteratorNeighborsOf (TV vertex){&#xA;&#x9;&#x9;&#x9;&#x9;ICollection&lt;TV> o = delegator.outgoing&lt;TV> (vertex);&#xA;&#x9;&#x9;&#x9;&#x9;ICollection&lt;TV> i = delegator.incoming&lt;TV> (vertex);&#xA;//&#x9;&#x9;&#x9;&#x9;ICollection&lt;TV> edges = new HashSet&lt;TV> ();&#xA;//&#x9;&#x9;&#x9;&#x9;if (!delegator.Container.AllowingMultipleEdges) {&#xA;//&#x9;&#x9;&#x9;&#x9;&#x9;foreach (TV v in o)&#xA;//&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (!edges.Contains (v)) {&#xA;//&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;edges.Add (v);&#xA;//&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;yield return v;&#xA;//&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;//&#x9;&#x9;&#x9;&#x9;&#x9;foreach(TV v in i)&#xA;//&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (!edges.Contains (v)) {&#xA;//&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;edges.Add (v);&#xA;//&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;yield return v;&#xA;//&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;//&#x9;&#x9;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;foreach(TV v in o) yield return v;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;foreach(TV v in i) yield return v;&#xA;//&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;//&#xA;&#x9;&#x9;&#x9;public IEnumerator&lt;KeyValuePair&lt;TV, float>> iteratorVertexWeightOf(TV vertex){&#xA;&#x9;&#x9;&#x9;&#x9;float weight_default = ((TE) delegator.Container.EdgeFactory.newInstance(vertex, vertex)).Weight;&#xA;&#x9;&#x9;&#x9;&#x9;IEnumerator&lt;TV> vneighbors = this.iteratorNeighborsOf (vertex);&#xA;&#x9;&#x9;&#x9;&#x9;ICollection&lt;TV> edges = new HashSet&lt;TV> ();&#xA;&#x9;&#x9;&#x9;&#x9;if (!delegator.Container.AllowingMultipleEdges) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;while (vneighbors.MoveNext()) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;KeyValuePair&lt;TV, float> kv = (new KeyValuePair&lt;TV, float>(vneighbors.Current, weight_default));&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;bool contain = edges.Contains (kv.Key);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (!contain) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;edges.Add (kv.Key);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;yield return kv;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;else&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;while (vneighbors.MoveNext())&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;yield return (new KeyValuePair&lt;TV, float>(vneighbors.Current, weight_default));&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;//&#xA;&#x9;&#x9;&#x9;public bool removeAllEdges(ICollection&lt;TE> edges){&#xA;&#x9;&#x9;&#x9;&#x9;bool modified = false;&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;foreach (TE e in edges) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;modified |= removeEdge(e);&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;return modified;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public ICollection&lt;TE> removeAllEdges(TV sourceVertex, TV targetVertex){&#xA;&#x9;&#x9;&#x9;&#x9;ICollection&lt;TE> removed = getAllEdges(sourceVertex, targetVertex);&#xA;&#x9;&#x9;&#x9;&#x9;if (removed == null) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;return null;&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;removeAllEdges(removed);&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;return removed;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public bool removeAllVertices(ICollection&lt;TV> vertices){&#xA;&#x9;&#x9;&#x9;&#x9;bool modified = false;&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;foreach (TV v in vertices) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;modified |= removeVertex(v);&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;return modified;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public TE removeEdge (TV sourceVertex, TV targetVertex) {&#xA;&#x9;&#x9;&#x9;&#x9;TE e = getEdge (sourceVertex, targetVertex);&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;if (e != null) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;removeEdgeFromContainer (e); //container.removeEdge (e);&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;return e;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public bool removeEdge (TE e) {&#xA;&#x9;&#x9;&#x9;&#x9;if (containsEdge (e)) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;removeEdgeFromContainer (e); //container.removeEdge (e);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;return true;&#xA;&#x9;&#x9;&#x9;&#x9;} &#xA;&#x9;&#x9;&#x9;&#x9;else { return false; }&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public bool removeVertex (TV v) {&#xA;&#x9;&#x9;&#x9;&#x9;if (containsVertex (v)) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;ICollection&lt;TE> edges = edgesOf (v);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;foreach (TE e in edges) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;removeEdgeFromContainer (e); //container.removeEdge (e);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;return delegator.removeVertex (v);&#xA;&#x9;&#x9;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;return false;&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public ICollection&lt;TV> vertexSet () {&#xA;&#x9;&#x9;&#x9;&#x9;return delegator.vertexSet ();&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public TV getEdgeSource (TE e) {&#xA;&#x9;&#x9;&#x9;&#x9;return e.Source;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public TV getEdgeTarget (TE e) {&#xA;&#x9;&#x9;&#x9;&#x9;return e.Target;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public float getEdgeWeight (TE e) {&#xA;&#x9;&#x9;&#x9;&#x9;return getEdgeWeight (e.Source, e.Target);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public void setAllEdgeWeight (TE e, float weight) {&#xA;&#x9;&#x9;&#x9;&#x9;setAllEdgeWeight (e.Source, e.Target, weight);&#xA;&#x9;&#x9;&#x9;} &#xA;&#x9;&#x9;&#x9;public void setAllEdgeWeight (TV sourceVertex, TV targetVertex, float weight){&#xA;&#x9;&#x9;&#x9;&#x9;Console.WriteLine (&quot;WARNING: setAllEdgeWeight not Supported&quot;);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public float getEdgeWeight (TV sourceVertex, TV targetVertex){&#xA;&#x9;&#x9;&#x9;&#x9;return delegator.Container.EdgeFactory.newInstance (sourceVertex, targetVertex).Weight;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;// End interface implements&#xA;&#xA;&#x9;&#x9;&#x9;public bool isAllowingLoops () { return delegator.Container.AllowingLoops; }&#xA;&#x9;&#x9;&#x9;public bool isAllowingMultipleEdges () { return delegator.Container.AllowingMultipleEdges; }&#xA;&#xA;&#x9;&#x9;&#x9;#region ICloneable implementation&#xA;&#x9;&#x9;&#x9;public object Clone () {&#xA;&#x9;&#x9;&#x9;&#x9;IGraphHelperV&lt;V, E, TV, TE> d = (IGraphHelperV&lt;V, E, TV, TE>) this.delegator.Clone ();&#xA;&#x9;&#x9;&#x9;&#x9;IUndirectedGraphVInstanceImpl&lt;V, E, TV, TE> clone = new IUndirectedGraphVInstanceImpl&lt;V, E, TV, TE>(d);&#xA;&#x9;&#x9;&#x9;&#x9;return clone;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;#endregion&#xA;&#xA;&#x9;&#x9;&#x9;public override string ToString () { &#xA;&#x9;&#x9;&#x9;&#x9;IEnumerator&lt;TV> vertexSet = this.vertexSet ().GetEnumerator();&#xA;&#x9;&#x9;&#x9;&#x9;IEnumerator&lt;TE> edgeSet = this.edgeSet ();&#xA;&#x9;&#x9;&#x9;&#x9;System.Text.StringBuilder sb = new System.Text.StringBuilder();&#xA;&#x9;&#x9;&#x9;&#x9;String ret = &quot;&quot;;&#xA;&#x9;&#x9;&#x9;&#x9;sb.Append (&quot;Vertexs [&quot;);&#xA;&#x9;&#x9;&#x9;&#x9;for(int i = 0; vertexSet.MoveNext();i++){&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;sb.Append (vertexSet.Current.ToString ()+&quot;,&quot;);&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;sb.Remove (sb.Length-1, 1);&#xA;&#x9;&#x9;&#x9;&#x9;sb.Append(&quot;]&quot;);&#xA;&#x9;&#x9;&#x9;&#x9;sb.AppendLine();&#xA;&#x9;&#x9;&#x9;&#x9;sb.Append(&quot;edges&quot;);&#xA;&#x9;&#x9;&#x9;&#x9;for (int i=0; edgeSet.MoveNext(); i++) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;sb.Append(&quot;(&quot;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;sb.Append (edgeSet.Current.ToString());&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;sb.Append(&quot;) &quot;);&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;ret = sb.ToString ();&#xA;&#x9;&#x9;&#x9;&#x9;sb.Clear ();&#xA;&#x9;&#x9;&#x9;&#x9;return ret;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public void noSafeAdd(TE e){&#xA;&#x9;&#x9;&#x9;&#x9;delegator.noSafeAdd (e);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public void noSafeAdd(TV source, TV target){&#xA;&#x9;&#x9;&#x9;&#x9;delegator.noSafeAdd (source, target);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public void noSafeAdd(TV source, TV target, float weight){&#xA;&#x9;&#x9;&#x9;&#x9;delegator.noSafeAdd (source, target, weight);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public void addEdgeToContainer (TE e) {&#xA;&#x9;&#x9;&#x9;&#x9;delegator.addOutgoingEdge (e);&#xA;&#x9;&#x9;&#x9;&#x9;delegator.addIncomingEdge (e);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public void removeEdgeFromContainer (TE e) {&#xA;&#x9;&#x9;&#x9;&#x9;delegator.removeOutgoingEdge (e);&#xA;&#x9;&#x9;&#x9;&#x9;delegator.removeIncomingEdge (e);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;private bool isEqualsStraightOrInverted (Object sourceVertex, Object targetVertex, TE e) {&#xA;&#x9;&#x9;&#x9;&#x9;bool equalStraight = sourceVertex.Equals (e.Source) &amp;&amp; targetVertex.Equals (e.Target);&#xA;&#x9;&#x9;&#x9;&#x9;bool equalInverted = sourceVertex.Equals (e.Target) &amp;&amp; targetVertex.Equals (e.Source);&#xA;&#x9;&#x9;&#x9;&#x9;return equalStraight || equalInverted;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public int degreeOf (TV vertex) {&#xA;&#x9;&#x9;&#x9;&#x9;if (delegator.Container.AllowingLoops) {&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;int degree = 0;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;ICollection&lt;TE> edges = edgesOf (vertex);&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;foreach (TE e in edges) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (e.Source.Equals (e.Target)) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;degree += 2;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;degree += 1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;return degree;&#xA;&#x9;&#x9;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;return delegator.degreeOf (vertex);&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public int countE() { return delegator.countE(); }&#xA;&#x9;&#x9;&#x9;public int countV() { return delegator.countV(); }&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;public interface IGraphHelperV&lt;V, E, TV, TE>: IGraphHelper&lt;V, E, TV, TE> &#xA;&#x9;&#x9;&#x9;where V:IVertex where E:IEdge&lt;V> where TE: IEdgeInstance&lt;V, TV> {&#xA;&#x9;&#x9;&#x9;IDataContainerVInstance&lt;V, E, TV, TE> Container { get; set; }&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;internal class IGraphHelperVImpl&lt;V, E, TV, TE>: IGraphHelperV&lt;V, E, TV, TE> &#xA;&#x9;&#x9;&#x9;where V:IVertex &#xA;&#x9;&#x9;&#x9;where E:IEdge&lt;V>&#xA;&#x9;&#x9;&#x9;where TE: IEdgeInstance&lt;V, TV> {&#xA;&#xA;&#x9;&#x9;&#x9;private int count_edges = 0;&#xA;&#x9;&#x9;&#x9;private IDataContainerVInstance&lt;V, E, TV, TE> container;&#xA;&#xA;&#x9;&#x9;&#x9;public IGraphHelperVImpl (IDataContainerVInstance&lt;V, E, TV, TE> c) {&#xA;&#x9;&#x9;&#x9;&#x9;container = c;&#xA;&#x9;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;&#x9;public IDataContainerVInstance&lt;V, E, TV, TE> Container{&#xA;&#x9;&#x9;&#x9;&#x9;get{ return this.container; }&#xA;&#x9;&#x9;&#x9;&#x9;set{ this.container = (IDataContainerVInstance&lt;V, E, TV, TE>)value; }&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public IDataContainerInstance&lt;V, E> DataContainer{&#xA;&#x9;&#x9;&#x9;&#x9;get{ return this.container; }&#xA;&#x9;&#x9;&#x9;&#x9;set{ this.container = (IDataContainerVInstance&lt;V, E, TV, TE>)value; }&#xA;&#x9;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;&#x9;#region ICloneable implementation&#xA;&#x9;&#x9;&#x9;public object Clone () {&#xA;&#x9;&#x9;&#x9;&#x9;IDataContainerVInstance&lt;V, E, TV, TE> c = (IDataContainerVInstance&lt;V, E, TV, TE>) this.Container.Clone ();&#xA;&#x9;&#x9;&#x9;&#x9;IGraphHelperVImpl&lt;V, E, TV, TE> clone = new IGraphHelperVImpl&lt;V, E, TV, TE> (c);&#xA;&#x9;&#x9;&#x9;&#x9;clone.count_edges = this.count_edges;&#xA;&#x9;&#x9;&#x9;&#x9;return clone;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;#endregion&#xA;&#xA;&#x9;&#x9;&#x9;// ************************* implements ***********************************&#xA;&#x9;&#x9;&#x9;public IEnumerator&lt;TE> edgeSet () {&#xA;&#x9;&#x9;&#x9;&#x9;ICollection&lt;TV> collection = container.DataSet.Keys;&#xA;&#x9;&#x9;&#x9;&#x9;foreach (TV v in collection) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;IEdgeContainer&lt;TV> ec = container.DataSet[v];&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;IEnumerator&lt;TV> iterator = ec.outgoing.GetEnumerator();&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;while (iterator.MoveNext ()) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;yield return (TE) container.EdgeFactory.newInstance (v, iterator.Current);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public ICollection&lt;TE> edgesOf (TV vertex) {&#xA;&#x9;&#x9;&#x9;&#x9;IEdgeContainer&lt;TV> ec;&#xA;&#x9;&#x9;&#x9;&#x9;ICollection&lt;TE> edges;// = new HashSet&lt;E> ();&#xA;&#x9;&#x9;&#x9;&#x9;if (!container.AllowingMultipleEdges)&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;edges = new HashSet&lt;TE> ();&#xA;&#x9;&#x9;&#x9;&#x9;else&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;edges = new List&lt;TE> ();&#xA;&#x9;&#x9;&#x9;&#x9;if (container.DataSet.TryGetValue (vertex, out ec)) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;foreach (TV v in ec.outgoing) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;edges.Add ((TE)container.EdgeFactory.newInstance (vertex, v));&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;foreach (TV v in ec.incoming)&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if(!vertex.Equals(v)) edges.Add ((TE)container.EdgeFactory.newInstance (v, vertex));&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;return edges;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public IEnumerator&lt;TE> iteratorEdgesOf (TV vertex) {&#xA;&#x9;&#x9;&#x9;&#x9;IEdgeContainer&lt;TV> ec;&#xA;&#x9;&#x9;&#x9;&#x9;if (container.DataSet.TryGetValue (vertex, out ec)) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;foreach (TV v in ec.outgoing) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;yield return ((TE)container.EdgeFactory.newInstance (vertex, v));&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;foreach (TV v in ec.incoming)&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if(!vertex.Equals(v)) yield return ((TE)container.EdgeFactory.newInstance (v, vertex));&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public ICollection&lt;TV> vertexSet () {&#xA;&#x9;&#x9;&#x9;&#x9;return container.DataSet.Keys;&#xA;&#x9;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;&#x9;public void addIncomingEdge (TE e) {//if (container.DataSet.ContainsKey (e.target))&#xA;&#x9;&#x9;&#x9;&#x9;if (!e.Source.Equals (e.Target)) { &#xA;&#x9;&#x9;&#x9;&#x9;&#x9;container.DataSet [e.Target].incoming.Add (e.Source);&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public void addOutgoingEdge (TE e) { //if (container.DataSet.ContainsKey (e.source))&#xA;&#x9;&#x9;&#x9;&#x9;container.DataSet [e.Source].outgoing.Add (e.Target);&#xA;&#x9;&#x9;&#x9;&#x9;count_edges++;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public void removeIncomingEdge (TE e) { //if (container.DataSet.ContainsKey (e.target))&#xA;&#x9;&#x9;&#x9;&#x9;container.DataSet [e.Target].incoming.Remove (e.Source);&#xA;&#x9;&#x9;&#x9;&#x9;count_edges--;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public void removeOutgoingEdge (TE e) { //if (container.DataSet.ContainsKey (e.source))&#xA;&#x9;&#x9;&#x9;&#x9;container.DataSet [e.Source].outgoing.Remove (e.Target); &#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public void noSafeAdd(TE e){&#xA;&#x9;&#x9;&#x9;&#x9;if (!containsEdge(e)) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;container.DataSet [e.Source].outgoing.Add (e.Target);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if (!e.Source.Equals (e.Target)) { &#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;container.DataSet [e.Target].incoming.Add (e.Source);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;count_edges++;&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public void noSafeAdd(TV source, TV target){&#xA;&#x9;&#x9;&#x9;&#x9;bool b = container.DataSet [source].outgoing.Contains (target) || container.DataSet [target].outgoing.Contains (source);&#xA;&#x9;&#x9;&#x9;&#x9;if (!b) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;container.DataSet [source].outgoing.Add (target);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if (!source.Equals (target)) { &#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;container.DataSet [target].incoming.Add (source);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;count_edges++;&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public void noSafeAdd(TV source, TV target, float weight){&#xA;&#x9;&#x9;&#x9;&#x9;new NotSupportedException (&quot;Weight not Supported Exception!&quot;);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public ICollection&lt;T> incoming&lt;T>(TV vertex){&#xA;&#x9;&#x9;&#x9;&#x9;IEdgeContainer&lt;TV> ec;&#xA;&#x9;&#x9;&#x9;&#x9;if (container.DataSet.TryGetValue (vertex, out ec))&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;return ((List&lt;T>)ec.incoming).AsReadOnly();&#xA;&#x9;&#x9;&#x9;&#x9;return new List&lt;T>().AsReadOnly();&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public ICollection&lt;T> outgoing&lt;T>(TV vertex){&#xA;&#x9;&#x9;&#x9;&#x9;IEdgeContainer&lt;TV> ec;&#xA;&#x9;&#x9;&#x9;&#x9;if (container.DataSet.TryGetValue (vertex, out ec))&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;return ((List&lt;T>)ec.outgoing).AsReadOnly();&#xA;&#x9;&#x9;&#x9;&#x9;return new List&lt;T>().AsReadOnly();&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public bool addVertex (TV vertex) {&#xA;&#x9;&#x9;&#x9;&#x9;if (container.DataSet.ContainsKey (vertex)) return false;&#xA;&#x9;&#x9;&#x9;&#x9;else { &#xA;&#x9;&#x9;&#x9;&#x9;&#x9;IEdgeContainer&lt;TV> ec = new EdgeContainer&lt;TV>(); &#xA;&#x9;&#x9;&#x9;&#x9;&#x9;ec.outgoing = new List&lt;TV> ();&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;ec.incoming = new List&lt;TV> ();&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;container.DataSet[vertex] = ec;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;return true; &#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public bool containsEdge(TE e){&#xA;&#x9;&#x9;&#x9;&#x9;return container.DataSet [e.Source].outgoing.Contains (e.Target) || container.DataSet [e.Target].outgoing.Contains (e.Source);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public bool containsVertex (TV v){&#xA;&#x9;&#x9;&#x9;&#x9;return container.DataSet.ContainsKey (v);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public bool removeVertex (TV v) {&#xA;&#x9;&#x9;&#x9;&#x9;return container.DataSet.Remove (v);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;public int countE() { return count_edges; }&#xA;&#x9;&#x9;&#x9;public int countV() { return container.DataSet.Count; }&#xA;&#x9;&#x9;&#x9;public int degreeOf(TV v) { &#xA;&#x9;&#x9;&#x9;&#x9;IEdgeContainer&lt;TV> ec; &#xA;&#x9;&#x9;&#x9;&#x9;if (container.DataSet.TryGetValue (v, out ec)) &#xA;&#x9;&#x9;&#x9;&#x9;&#x9;return ec.outgoing.Count + ec.incoming.Count; &#xA;&#x9;&#x9;&#x9;&#x9;return 0; &#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;}&#xA;" name="IUndirectedGraphVImpl.cs" srcType="user" uri="br.ufc.mdcc.hpcshelf.gust.graph.impl.UndirectedGraphVImpl/bin/1.0.0.0/IUndirectedGraphVImpl.dll" versionId="1.0.0.0">
          <dependency>br.ufc.mdcc.hpcshelf.gust.graph.container.DataContainerV/bin/1.0.0.0/IDataContainerV.dll</dependency>
          <dependency>br.ufc.mdcc.hpcshelf.gust.graph.Vertex/bin/1.0.0.0/IVertex.dll</dependency>
          <dependency>br.ufc.mdcc.hpcshelf.gust.graph.Edge/bin/1.0.0.0/IEdge.dll</dependency>
          <dependency>%WORKSPACE/br.ufc.mdcc.hpcshelf.gust.graph.impl.UndirectedGraphVImpl/bin/1.0.0.0/BaseIUndirectedGraphVImpl.dll</dependency>
          <dependency>br.ufc.mdcc.hpcshelf.gust.graph.UndirectedGraph/bin/1.0.0.0/IUndirectedGraph.dll</dependency>
        </file>
      </sources>
      <visualDescription h="40" w="193" x="145" y="150">
        <color b="207" g="159" r="114"/>
      </visualDescription>
      <parameter iname="IDataContainerV" order="2" parid="container" uname="data" varid="CTN"/>
      <parameter iname="IEdge" order="1" parid="edge_type" uname="data" varid="E"/>
      <parameter iname="IVertex" order="0" parid="vertex_type" uname="data" varid="V"/>
    </interface>
    <unit facet="0" iRef="IUndirectedGraphVImpl" multiple="false" private="false" replica="0" uRef="data" visibleInterface="true">
      <super cRef="base" uRef="data"/>
      <visualDescription h="40" w="80" x="240" y="266"/>
    </unit>
  </componentInfo>
</component:component>