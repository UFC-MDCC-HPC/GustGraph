<?xml version="1.0" encoding="ASCII"?>
<component:component xmlns:component="http://www.example.org/HashComponent">
  <header hash_component_UID="0024000004800000940000000602000000240000525341310004000011000000bb70a786ae2b0edef9f29258621f4ac2631506798e518fe6afd5d3a8070fc432e8beea729f4e0b182833cc0109b1c3d840e6937af54c8eec7de6cbb2756297e16fccf19c530fafaf2cf8500a78f38b08b1f0bad447c187d5191b61a5999dd1af7d427491b83feef6e31cb3ac502ed93d30e0ce50312e2c1966a4b917aa5f4581" isAbstract="false" kind="Binding" name="SAFeBindingImpl" packagePath="br.ufc.mdcc.hpc.storm.binding.channel.impl">
    <baseType>
      <extensionType>
        <implements>true</implements>
      </extensionType>
      <component hash_component_UID="00240000048000009400000006020000002400005253413100040000110000008f55e794f708d1cbb5e337a05a27654ca5ca8c73f9768e51f69240f622c9d03f1ae40cd5fe058f59a2cf465affe53f20843d95ec4d7f0f5d56ca2da746d1b3c81fd84f23a4e138e9fc4095803bae2f3e9a6ff05c65fc18c2db9c76ee6ee0ecfd5add39fdc33b908bf203d7adb50bc43c7d818bdc3412c6126c3d17b968c459be" localRef="base" location="br.ufc.mdcc.hpc.storm.binding.channel.Binding/Binding.hpe" name="Binding" package="br.ufc.mdcc.hpc.storm.binding.channel" version="1.0.0.0">
        <visualDescription h="76" w="211" x="435" y="186">
          <color b="255" g="255" r="255"/>
        </visualDescription>
        <unitBounds facet="0" facet_instance="0" facet_instance_enclosing="0" parallel="false" uRef="root">
          <visualDescription h="20" w="20" x="5" y="2"/>
        </unitBounds>
        <unitBounds facet="0" facet_instance="0" facet_instance_enclosing="0" parallel="true" uRef="peer">
          <visualDescription h="20" w="20" x="28" y="2"/>
        </unitBounds>
      </component>
    </baseType>
    <versions field1="1" field2="0" field3="0" field4="0"/>
    <visualAttributes>
      <color b="255" g="255" r="255"/>
    </visualAttributes>
    <facet_configuration facet="0" multiple="false"/>
  </header>
  <componentInfo>
    <interface iRef="IChannelRootImpl" nArgs="0">
      <sources sourceType="C# Language" versionId="1.0.0.0">
        <file contents="/* Automatically Generated Code */&#xA;&#xA;using System;&#xA;using br.ufc.pargo.hpe.backend.DGAC;&#xA;using br.ufc.pargo.hpe.basic;&#xA;using br.ufc.pargo.hpe.kinds;&#xA;using br.ufc.mdcc.hpc.storm.binding.channel.Binding;&#xA;&#xA;namespace br.ufc.mdcc.hpc.storm.binding.channel.impl.SAFeBindingImpl &#xA;{&#xA;}" name="BaseIChannelRootImpl.cs" srcType="base" uri="br.ufc.mdcc.hpc.storm.binding.channel.impl.SAFeBindingImpl/bin/1.0.0.0/BaseIChannelRootImpl.dll" versionId="1.0.0.0">
          <dependency>br.ufc.mdcc.hpc.storm.binding.channel.Binding/bin/1.0.0.0/BaseIChannelRoot.dll</dependency>
          <externalDependency>MPI</externalDependency>
        </file>
        <file contents="using System;&#xA;using br.ufc.pargo.hpe.backend.DGAC;&#xA;using br.ufc.pargo.hpe.basic;&#xA;using br.ufc.pargo.hpe.kinds;&#xA;using br.ufc.mdcc.hpc.storm.binding.channel.Binding;&#xA;&#xA;using System.Threading;&#xA;using System.Collections.Concurrent;&#xA;using System.Net;&#xA;using System.Net.Sockets;&#xA;using System.Collections.Generic;&#xA;using System.Runtime.Serialization.Formatters.Binary;&#xA;using System.IO;&#xA;&#xA;using EnvelopType = System.Tuple&lt;int,int,int,int,int,int>;&#xA;using System.Diagnostics;&#xA;&#xA;namespace br.ufc.mdcc.hpc.storm.binding.channel.impl.SAFeBindingImpl&#xA;{&#xA;&#xA;}&#xA;" name="IChannelRootImpl.cs" srcType="user" uri="br.ufc.mdcc.hpc.storm.binding.channel.impl.SAFeBindingImpl/bin/1.0.0.0/IChannelRootImpl.dll" versionId="1.0.0.0">
          <dependency>%WORKSPACE/br.ufc.mdcc.hpc.storm.binding.channel.impl.SAFeBindingImpl/bin/1.0.0.0/BaseIChannelRootImpl.dll</dependency>
          <dependency>br.ufc.mdcc.hpc.storm.binding.channel.Binding/bin/1.0.0.0/IChannelRoot.dll</dependency>
          <externalDependency>MPI</externalDependency>
        </file>
      </sources>
      <visualDescription h="40" w="172" x="175" y="61">
        <color b="0" g="165" r="255"/>
      </visualDescription>
      <externalReferences>MPI</externalReferences>
    </interface>
    <interface iRef="IChannelImpl" nArgs="0">
      <sources sourceType="C# Language" versionId="1.0.0.0">
        <file contents="/* Automatically Generated Code */&#xA;&#xA;using System;&#xA;using br.ufc.pargo.hpe.backend.DGAC;&#xA;using br.ufc.pargo.hpe.basic;&#xA;using br.ufc.pargo.hpe.kinds;&#xA;using br.ufc.mdcc.hpc.storm.binding.channel.Binding;&#xA;&#xA;namespace br.ufc.mdcc.hpc.storm.binding.channel.impl.SAFeBindingImpl &#xA;{&#xA;&#x9;public abstract class BaseIChannelImpl: br.ufc.pargo.hpe.kinds.Binding, BaseIChannel&#xA;&#x9;{&#xA;&#xA;&#x9;}&#xA;}" name="BaseIChannelImpl.cs" srcType="base" uri="br.ufc.mdcc.hpc.storm.binding.channel.impl.SAFeBindingImpl/bin/1.0.0.0/BaseIChannelImpl.dll" versionId="1.0.0.0">
          <dependency>br.ufc.mdcc.hpc.storm.binding.channel.Binding/bin/1.0.0.0/BaseIChannel.dll</dependency>
          <externalDependency>MPI</externalDependency>
        </file>
        <file contents="&#xA;using System;&#xA;using br.ufc.pargo.hpe.backend.DGAC;&#xA;using br.ufc.pargo.hpe.basic;&#xA;using br.ufc.pargo.hpe.kinds;&#xA;using br.ufc.mdcc.hpc.storm.binding.channel.Binding;&#xA;using System.Runtime.Serialization.Formatters.Binary;&#xA;using System.IO;&#xA;using System.Diagnostics;&#xA;&#xA;using EnvelopType = System.Tuple&lt;int,int,int,int,int,int>;&#xA;using System.Collections.Generic;&#xA;using System.Threading;&#xA;using System.Collections.Concurrent;&#xA;using System.Net.Sockets;&#xA;using System.Net;&#xA;&#xA;namespace br.ufc.mdcc.hpc.storm.binding.channel.impl.SAFeBindingImpl&#xA;{&#xA;&#x9;public class IChannelImpl : BaseIChannelImpl, IChannel&#xA;&#x9;{&#xA;&#x9;&#x9;private IDictionary&lt;int,Thread> thread_receive_requests = null;&#xA;&#xA;&#x9;&#x9;private static byte[] ObjectToByteArray(Object obj)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;if(obj == null)&#xA;&#x9;&#x9;&#x9;&#x9;return null;&#xA;&#x9;&#x9;&#x9;BinaryFormatter bf = new BinaryFormatter();&#xA;&#x9;&#x9;&#x9;MemoryStream ms = new MemoryStream();&#xA;&#x9;&#x9;&#x9;bf.Serialize(ms, obj);&#xA;&#x9;&#x9;&#x9;return ms.ToArray();&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;private static Object ByteArrayToObject(byte[] arrBytes)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;MemoryStream memStream = new MemoryStream();&#xA;&#x9;&#x9;&#x9;BinaryFormatter binForm = new BinaryFormatter();&#xA;&#x9;&#x9;&#x9;memStream.Write(arrBytes, 0, arrBytes.Length);&#xA;&#x9;&#x9;&#x9;memStream.Seek(0, SeekOrigin.Begin);&#xA;&#x9;&#x9;&#x9;Object obj = (Object) binForm.Deserialize(memStream);&#xA;&#x9;&#x9;&#x9;return obj;&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;#region implemented abstract members of BindingRoot&#xA;&#x9;&#x9;public override void server ()&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;this.TraceFlag = true;&#xA;&#xA;&#x9;&#x9;&#x9;Console.WriteLine(&quot;: BEFORE CREATE SOCKETS !!! &quot; + this.ThisFacet + &quot; / &quot; + this.ThisFacetInstance + &quot; : &quot; + this.CID.getInstanceName());&#xA;&#xA;&#x9;&#x9;&#x9;createSockets ();&#xA;&#xA;&#x9;&#x9;&#x9;Console.WriteLine(&quot;: AFTER CREATED SOCKETS !!! &quot; + this.ThisFacet + &quot; / &quot; + this.ThisFacetInstance + &quot; : &quot; + this.CID.getInstanceName());&#xA;&#xA;&#x9;&#x9;&#x9;synchronizer_monitor = new SynchronizerMonitor (this, client_socket_facet, this.ThisFacetInstance, this.CID.getInstanceName());&#xA;&#xA;&#x9;&#x9;&#x9;sockets_initialized_flag.Set ();&#xA;&#xA;&#x9;&#x9;&#x9;// Create the threads that will listen the sockets for each other facet.&#xA;&#x9;&#x9;&#x9;thread_receive_requests = new Dictionary&lt;int, Thread>();&#xA;&#xA;&#x9;&#x9;&#x9;foreach (int facet in this.Facet.Keys) &#xA;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;if (facet != this.ThisFacetInstance)&#xA;&#x9;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;Console.WriteLine(&quot;loop create thread_receive_requests: &quot; + facet + &quot; / &quot; + this.ThisFacetInstance);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;Socket server_socket = server_socket_facet [facet];&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;thread_receive_requests[facet] = new Thread (new ThreadStart (() => synchronizer_monitor.serverReceiveRequests(facet, server_socket)));&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;thread_receive_requests[facet].Start ();&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;&#x9;while (true) &#xA;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;Thread.Sleep (100);&#xA;&#x9;&#x9;&#x9;&#x9;synchronizer_monitor.serverReadRequest ();&#xA;&#x9;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;private AutoResetEvent sockets_initialized_flag = new AutoResetEvent(false);&#xA;&#xA;&#x9;&#x9;public override void client ()&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;this.TraceFlag = true;&#xA;&#xA;&#x9;&#x9;&#x9;//while (!sockets_initialized_flag)&#x9;Thread.Sleep (100);&#xA;&#x9;&#x9;&#x9;sockets_initialized_flag.WaitOne ();&#xA;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;#endregion&#xA;&#xA;&#x9;&#x9;private SynchronizerMonitor synchronizer_monitor;&#xA;&#xA;&#x9;&#x9;private IDictionary&lt;int, Socket> client_socket_facet = new Dictionary&lt;int, Socket>();&#xA;&#x9;&#x9;private IDictionary&lt;int, Socket> server_socket_facet = new Dictionary&lt;int, Socket>();&#xA;&#xA;&#x9;&#x9;private void connectSockets()&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;foreach (KeyValuePair&lt;int, FacetAccess> facet_access in this.Facet) &#xA;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;int facet = facet_access.Key;&#xA;&#x9;&#x9;&#x9;&#x9;if (facet != this.ThisFacetInstance)&#xA;&#x9;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;Socket socket = client_socket_facet [facet];&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;IPEndPoint endPoint = end_point_client [facet];&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;bool isConnected = false;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;int tries = 0;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;while (!isConnected &amp;&amp; tries &lt;=30) &#xA;&#x9;&#x9;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;try {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;//Console.WriteLine(&quot;CONNECTING &quot; + &quot;facet=&quot; + facet + &quot; / &quot; + endPoint+ &quot; / &quot; + this.CID.getInstanceName());&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;socket.Connect (endPoint);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;isConnected = true;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;//Console.WriteLine(&quot;CONNECTED &quot; + &quot;facet=&quot; + facet + &quot; / &quot; + endPoint+ &quot; / &quot; + this.CID.getInstanceName());&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;catch (Exception e) &#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;//tries ++;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;//isConnected = false;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;//Console.WriteLine(&quot;CONNECTION FAILED N --- ATTEMPT #&quot; + tries + &quot; *** &quot; + e.Message + &quot; --- &quot; + endPoint);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;Thread.Sleep(1000);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if (!isConnected) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;Console.WriteLine(&quot;createSockets --- It was not possible to talk to the server&quot;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;throw new Exception (&quot;createSockets --- It was not possible to talk to the server&quot;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;private void acceptSockets ()&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;foreach (KeyValuePair&lt;int, FacetAccess> facet_access in this.Facet) &#xA;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;int facet = facet_access.Key;&#xA;&#x9;&#x9;&#x9;&#x9;if (facet != this.ThisFacetInstance) &#xA;&#x9;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;Socket socket = server_socket_facet [facet];&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;IPEndPoint endPoint = end_point_server [facet];&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;Console.WriteLine(&quot;BINDING &quot; + endPoint + &quot; -- &quot; + facet + &quot; / &quot; + this.CID.getInstanceName());&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;socket.Bind (endPoint) ;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;socket.Listen (10);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;server_socket_facet[facet] = socket.Accept ();&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;Console.WriteLine(&quot;BINDED &quot; + endPoint + &quot; -- &quot; + facet + &quot; / &quot; + this.CID.getInstanceName());&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;private IDictionary&lt;int,IPEndPoint> end_point_client = new Dictionary&lt;int,IPEndPoint>();&#xA;&#x9;&#x9;private IDictionary&lt;int,IPEndPoint> end_point_server = new Dictionary&lt;int,IPEndPoint>();&#xA;&#xA;&#xA;&#x9;&#x9;private void createSockets ()&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;FacetAccess facet_acess_server = this.Facet [ThisFacetInstance];&#xA;&#xA;&#x9;&#x9;&#x9;foreach (KeyValuePair&lt;int, FacetAccess> facet_access_client in this.Facet)&#xA;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;int facet_instance = facet_access_client.Key;&#xA;&#x9;&#x9;&#x9;&#x9;if (facet_instance != this.ThisFacetInstance) &#xA;&#x9;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;string ip_address_client = facet_access_client.Value.ip_address;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;int port_client = facet_access_client.Value.port + this.ThisFacetInstance;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;IPHostEntry ipHostInfo_client = Dns.GetHostEntry (ip_address_client);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;IPAddress ipAddress_client = ipHostInfo_client.AddressList [0];&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;IPEndPoint endPoint_client = new IPEndPoint (ipAddress_client, port_client);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;end_point_client [facet_instance] = endPoint_client;&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;Console.WriteLine(&quot;CREATE SOCKETS - end_point_client[&quot; + facet_instance + &quot;]=&quot; + endPoint_client);&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;string ip_address_server = facet_acess_server.ip_address;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;int port_server = facet_acess_server.port + facet_instance;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;IPHostEntry ipHostInfo_server = Dns.GetHostEntry (ip_address_server);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;IPAddress ipAddress_server = ipHostInfo_server.AddressList [0];&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;IPEndPoint endPoint_server = new IPEndPoint (ipAddress_server, port_server);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;end_point_server [facet_instance] = endPoint_server;&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;Console.WriteLine(&quot;CREATE SOCKETS - end_point_server[&quot; + facet_instance + &quot;]=&quot; + endPoint_server);&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;// Create a TCP/IP client socket.&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;Socket client_socket = new Socket (AddressFamily.InterNetwork, &#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;SocketType.Stream, System.Net.Sockets.ProtocolType.Tcp);&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;// Create a TCP/IP server socket.&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;Socket server_socket = new Socket (AddressFamily.InterNetwork, &#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;SocketType.Stream, System.Net.Sockets.ProtocolType.Tcp);&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;server_socket.SendTimeout = server_socket.ReceiveTimeout = client_socket.SendTimeout = client_socket.ReceiveTimeout = -1;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;client_socket_facet [facet_instance] = client_socket;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;server_socket_facet [facet_instance] = server_socket;&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;&#x9;Thread thread_connect_sockets = new Thread (new ThreadStart (connectSockets));&#xA;&#x9;&#x9;&#x9;Thread thread_accept_sockets = new Thread (new ThreadStart (acceptSockets));&#xA;&#xA;&#x9;&#x9;&#x9;thread_connect_sockets.Start();&#xA;&#x9;&#x9;&#x9;thread_accept_sockets.Start ();&#xA;&#xA;&#x9;&#x9;&#x9;Console.WriteLine(&quot;CREATE_SOCKETS - connectSockets and acceptSockets launched !!!&quot;);&#xA;&#xA;&#x9;&#x9;&#x9;thread_connect_sockets.Join ();&#xA;&#x9;&#x9;&#x9;thread_accept_sockets.Join ();&#xA;&#xA;&#x9;&#x9;&#x9;Console.WriteLine(&quot;CREATE_SOCKETS - connectSockets and acceptSockets finished !!!&quot;);&#xA;&#x9;&#x9;}&#x9;&#x9;&#x9;&#xA;&#xA;&#xA;&#xA;&#xA;&#x9;&#x9;public void Send&lt;T> (T value, Tuple&lt;int,int> dest, int tag)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;byte[] value_packet = ObjectToByteArray (value);&#xA;&#x9;&#x9;&#x9;handle_SEND (AliencommunicatorOperation.SEND, new Tuple&lt;int,int,int,byte[]>(dest.Item1, dest.Item2, tag, value_packet));&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;public IRequest ImmediateSend&lt;T> (T value, Tuple&lt;int,int> dest, int tag)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;ManualResetEvent waiting_request = new ManualResetEvent (false);&#xA;&#x9;&#x9;&#x9;IRequest request =  Request.createRequest(waiting_request, dest, tag);&#xA;&#x9;&#x9;&#x9;byte[] value_packet = ObjectToByteArray (value);&#xA;&#xA;&#x9;&#x9;&#x9;Thread t = new Thread (new ThreadStart(delegate() {&#xA;&#x9;&#x9;&#x9;&#x9;handle_SEND (AliencommunicatorOperation.SEND, new Tuple&lt;int,int,int,byte[]>(dest.Item1, dest.Item2, tag, value_packet));&#xA;&#x9;&#x9;&#x9;&#x9;waiting_request.Set();&#xA;&#x9;&#x9;&#x9;}));&#xA;            t.Start();&#xA;&#xA;&#x9;&#x9;&#x9;return request;&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;public void Send&lt;T> (T[] values, Tuple&lt;int,int> dest, int tag)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;byte[] value_packet = ObjectToByteArray (values);&#xA;&#x9;&#x9;&#x9;handle_SEND (AliencommunicatorOperation.SEND_ARRAY, new Tuple&lt;int,int,int,byte[]>(dest.Item1, dest.Item2, tag, value_packet));&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;public IRequest ImmediateSend&lt;T> (T[] values, Tuple&lt;int,int> dest, int tag)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;ManualResetEvent waiting_request = new ManualResetEvent (false);&#xA;&#x9;&#x9;&#x9;IRequest request =  Request.createRequest(waiting_request, dest, tag);&#xA;&#x9;&#x9;&#x9;byte[] value_packet = ObjectToByteArray (values);&#xA;&#xA;&#x9;&#x9;&#x9;Thread t = new Thread (new ThreadStart(delegate() {&#xA;&#x9;&#x9;&#x9;&#x9;handle_SEND (AliencommunicatorOperation.SEND_ARRAY, new Tuple&lt;int,int,int,byte[]>(dest.Item1, dest.Item2, tag, value_packet));&#xA;&#x9;&#x9;&#x9;&#x9;waiting_request.Set();&#xA;&#x9;&#x9;&#x9;}));&#xA;            t.Start();&#xA;&#xA;&#x9;&#x9;&#x9;return request;&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;public IRequest ImmediateSyncSend&lt;T> (T value, Tuple&lt;int,int> dest, int tag)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;// In SAFe, it has the same semantics of ImmediateSend, since the call returns after handle_SEND has been completed.&#xA;&#x9;&#x9;&#x9;return ImmediateSend&lt;T> (value, dest, tag);&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;void handle_SEND (int operation_type, Tuple&lt;int,int,int,byte[]> operation_info)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;int facet_src = this.ThisFacetInstance;&#xA;&#x9;&#x9;&#x9;int facet_dst = operation_info.Item1;&#xA;&#x9;&#x9;&#x9;int src = 0;&#xA;&#x9;&#x9;&#x9;int dst = operation_info.Item2;&#xA;&#x9;&#x9;&#x9;int tag = operation_info.Item3;&#xA;&#xA;&#xA;&#x9;&#x9;&#x9;EnvelopType envelop = new EnvelopType (operation_type, facet_src, facet_dst, src, dst, tag);&#xA;&#x9;&#x9;&#x9;byte[] message1 = operation_info.Item4;&#xA;&#xA;&#x9;&#x9;&#x9;if (tag >=0 /* tag */)&#xA;&#x9;&#x9;&#x9;&#x9;synchronizer_monitor.clientSendRequest (envelop, message1);&#xA;&#x9;&#x9;&#x9;else&#xA;&#x9;&#x9;&#x9;&#x9;synchronizer_monitor.clientSendRequestAnyTag (envelop, message1, ref tag);&#xA;&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;//private object lock_recv = new object();&#xA;&#xA;&#x9;&#x9;public T Receive&lt;T> (Tuple&lt;int,int> source, int tag)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;T result;&#xA;&#x9;&#x9;&#x9;Receive&lt;T>(source, tag, out result);&#xA;&#x9;&#x9;&#x9;return result;&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;public void Receive&lt;T> (Tuple&lt;int,int> source, int tag, out T value)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;br.ufc.mdcc.hpc.storm.binding.channel.Binding.CompletedStatus status;&#xA;&#x9;&#x9;&#x9;Receive&lt;T>(source, tag, out value, out status);&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;public void Receive&lt;T> (Tuple&lt;int,int> source, int tag, out T value, out br.ufc.mdcc.hpc.storm.binding.channel.Binding.CompletedStatus status)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;byte[] v = handle_RECEIVE(AliencommunicatorOperation.RECEIVE, new Tuple&lt;int,int,int>(source.Item1, source.Item2, tag));&#xA;&#x9;&#x9;&#x9;value = (T) ByteArrayToObject(v);&#xA;&#x9;&#x9;&#x9;status = SAFeCompletedStatus.createStatus(source, tag);&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;public br.ufc.mdcc.hpc.storm.binding.channel.Binding.IReceiveRequest ImmediateReceive&lt;T> (Tuple&lt;int,int> source, int tag)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;ManualResetEvent waiting_request = new ManualResetEvent (false);&#xA;&#x9;&#x9;&#x9;IReceiveRequest request =  ValueReceiveRequest&lt;T>.createRequest(waiting_request, source, tag);&#xA;&#xA;&#x9;&#x9;&#x9;Thread t = new Thread (new ThreadStart(delegate() {&#xA;&#x9;&#x9;&#x9;&#x9;byte[] v = handle_RECEIVE(AliencommunicatorOperation.RECEIVE, new Tuple&lt;int,int,int>(source.Item1, source.Item2, tag));&#xA;&#x9;&#x9;&#x9;&#x9;waiting_request.Set();&#xA;&#x9;&#x9;&#x9;&#x9;((ValueReceiveRequest&lt;T>)request).SetValue(v);&#xA;&#x9;&#x9;&#x9;}));&#xA;            t.Start();&#xA;&#xA;&#x9;&#x9;&#x9;return request;&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;public void Receive&lt;T> (Tuple&lt;int,int> source, int tag, ref T[] values)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;br.ufc.mdcc.hpc.storm.binding.channel.Binding.CompletedStatus status;&#xA;&#x9;&#x9;&#x9;Receive&lt;T>(source, tag, ref values, out status);&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;public void Receive&lt;T> (Tuple&lt;int,int> source, int tag, ref T[] values, out br.ufc.mdcc.hpc.storm.binding.channel.Binding.CompletedStatus status)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;byte[] v = handle_RECEIVE(AliencommunicatorOperation.RECEIVE_ARRAY, new Tuple&lt;int,int,int>(source.Item1, source.Item2, tag));&#xA;&#x9;&#x9;&#x9;values = (T[])ByteArrayToObject (v);&#xA;&#x9;&#x9;&#x9;status = SAFeCompletedStatus.createStatus(source, tag); &#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;public br.ufc.mdcc.hpc.storm.binding.channel.Binding.IReceiveRequest ImmediateReceive&lt;T> (Tuple&lt;int,int> source, int tag, T[] values)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;ManualResetEvent waiting_request = new ManualResetEvent (false);&#xA;&#x9;&#x9;&#x9;IReceiveRequest request =  ValueReceiveRequest&lt;T>.createRequest(waiting_request, source, tag);&#xA;&#xA;&#x9;&#x9;&#x9;Thread t = new Thread (new ThreadStart(delegate() {&#xA;&#x9;&#x9;&#x9;&#x9;byte[] v = handle_RECEIVE(AliencommunicatorOperation.RECEIVE_ARRAY, new Tuple&lt;int,int,int>(source.Item1, source.Item2, tag));&#xA;&#x9;&#x9;&#x9;&#x9;waiting_request.Set();&#xA;&#x9;&#x9;&#x9;&#x9;((ValueReceiveRequest&lt;T>)request).SetValue(v);&#xA;&#x9;&#x9;&#x9;}));&#xA;            t.Start();&#xA;&#xA;&#x9;&#x9;&#x9;return request;&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;byte[] handle_RECEIVE (int operation_type, Tuple&lt;int,int,int> operation_info)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;int facet_src = this.ThisFacetInstance;&#xA;&#x9;&#x9;&#x9;int facet_dst = operation_info.Item1;&#xA;&#x9;&#x9;&#x9;int src = 0;&#xA;&#x9;&#x9;&#x9;int dst = operation_info.Item2;&#xA;&#x9;&#x9;&#x9;int tag = operation_info.Item3;&#xA;&#xA;&#x9;&#x9;&#x9;EnvelopType envelop = new EnvelopType (operation_type, facet_src, facet_dst, src, dst, tag);&#xA;&#x9;&#x9;&#x9;byte[] message2 = tag &lt; 0 ? synchronizer_monitor.clientSendRequestAnyTag (envelop, new byte[0], ref tag) &#xA;&#x9;&#x9;&#x9;&#x9;                      : synchronizer_monitor.clientSendRequest (envelop, new byte[0]);&#xA;&#xA;&#x9;&#x9;&#x9;return message2;&#xA;&#x9;&#x9;}&#xA;&#xA;&#xA;&#x9;&#x9;#region IDisposable implementation&#xA;&#x9;&#x9;private bool disposed = false;&#xA;&#xA;&#x9;&#x9;protected override void Dispose(bool disposing)&#xA;&#x9;&#x9;{&#xA;&#xA;&#x9;&#x9;&#x9;if (!disposed)&#xA;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;if (disposing)&#xA;&#x9;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;Console.WriteLine(&quot;DISPOSING BINDING ROOT ...&quot;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;foreach (int i in thread_receive_requests.Keys)&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;//for (int i=0; i&lt;thread_receive_requests.Count; i++)&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;if (i != this.ThisFacetInstance)&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;thread_receive_requests[i].Abort ();&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;base.Dispose (disposing);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;//dispose unmanaged resources&#xA;&#x9;&#x9;&#x9;disposed = true;&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;#endregion&#xA;&#xA;&#x9;}&#xA;&#xA;&#x9;class SynchronizerMonitor&#xA;&#x9;{&#xA;&#x9;&#x9;private int server_facet = default(int);&#xA;&#x9;&#x9;private string instance_name = null;&#xA;&#x9;&#x9;private IDictionary&lt;int,Socket> client_socket_facet = new Dictionary&lt;int,Socket>();&#xA;&#x9;&#x9;private IDictionary&lt;EnvelopKey, IDictionary&lt;int,Queue&lt;byte[]>>> reply_pending_list = new Dictionary&lt;EnvelopKey,IDictionary&lt;int,Queue&lt;byte[]>>>();&#xA;&#x9;&#x9;private IDictionary&lt;EnvelopKey, IDictionary&lt;int,Queue&lt;AutoResetEvent>>> request_pending_list = new Dictionary&lt;EnvelopKey,IDictionary&lt;int,Queue&lt;AutoResetEvent>>>();&#xA;&#x9;&#x9;private IChannelImpl unit;&#xA;&#xA;&#x9;&#x9;private object sync = new object();&#xA;&#xA;&#x9;&#x9;public SynchronizerMonitor (IChannelImpl unit, IDictionary&lt;int,Socket> client_socket_facet, int server_facet, string instance_name)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;this.unit = unit;&#xA;&#x9;&#x9;&#x9;this.client_socket_facet = client_socket_facet;&#xA;&#x9;&#x9;&#x9;this.server_facet = server_facet;&#xA;&#x9;&#x9;&#x9;this.instance_name = instance_name;&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;public byte[] clientSendRequest(EnvelopType envelop, byte[] messageSide1)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;EnvelopKey envelop_key = new EnvelopKey (envelop);&#xA;&#x9;&#x9;&#x9;int envelop_tag = envelop.Item6;&#xA;&#x9;&#x9;&#x9;Console.WriteLine(server_facet + &quot;/&quot; + &quot;: clientSendRequest 1&quot; + &quot; / &quot;  + envelop_key +&quot; -- &quot; + instance_name);&#xA;&#xA;&#x9;&#x9;&#x9;byte[] messageSide2 = null;&#xA;&#x9;&#x9;&#x9;Monitor.Enter (sync);&#xA;&#x9;&#x9;&#x9;try&#xA;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;// envia a requisi&#xe7;&#xe3;o para o root parceiro&#xA;&#x9;&#x9;&#x9;&#x9;int facet = envelop.Item3;&#xA;&#x9;&#x9;&#x9;&#x9;Console.WriteLine(server_facet + &quot;/&quot; + &quot;: clientSendRequest send to facet &quot; + facet + &quot; - nofsockets=&quot; + client_socket_facet.Count + &quot; / &quot;  + envelop_key+&quot; -- &quot; + instance_name);&#xA;&#x9;&#x9;&#x9;&#x9;foreach (int f in client_socket_facet.Keys)&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;Console.WriteLine(server_facet + &quot;/&quot; + &quot;: clientSendRequest --- FACET KEY=&quot; + f);&#xA;&#x9;&#x9;&#x9;&#x9;Socket socket = client_socket_facet [facet];&#xA;&#x9;&#x9;&#x9;&#x9;byte[] messageSide1_enveloped_raw = ObjectToByteArray (new Tuple&lt;EnvelopType,byte[]> (envelop, messageSide1));&#xA;&#x9;&#x9;&#x9;&#x9;Int32 length = messageSide1_enveloped_raw.Length;&#xA;&#x9;&#x9;&#x9;&#x9;byte[] messageSide1_enveloped_raw_ = new byte[4 + length];&#xA;&#x9;&#x9;&#x9;&#x9;BitConverter.GetBytes(length).CopyTo(messageSide1_enveloped_raw_,0);&#xA;&#x9;&#x9;&#x9;&#x9;Array.Copy(messageSide1_enveloped_raw, 0, messageSide1_enveloped_raw_, 4, length);&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;socket.Send (messageSide1_enveloped_raw_);&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;Console.WriteLine(server_facet + &quot;/&quot; + &quot;: clientSendRequest 2 nbytes=&quot; + messageSide1_enveloped_raw.Length + &quot; / &quot;  + envelop_key);&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;// Verifica se j&#xe1; h&#xe1; resposta para a requisi&#xe7;&#xe3;o no &quot;conjunto de respostas pendentes de requisi&#xe7;&#xe3;o&quot;&#xA;&#x9;&#x9;&#x9;&#x9;if (!(reply_pending_list.ContainsKey (envelop_key) &amp;&amp; reply_pending_list [envelop_key].ContainsKey(envelop_tag)) || &#xA;&#x9;&#x9;&#x9;&#x9;&#x9;(reply_pending_list.ContainsKey (envelop_key) &amp;&amp; reply_pending_list [envelop_key].ContainsKey(envelop_tag) &amp;&amp; reply_pending_list [envelop_key][envelop_tag].Count == 0)) &#xA;&#x9;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;Console.WriteLine(server_facet + &quot;/&quot; + &quot;: clientSendRequest 3 - BEFORE WAIT &quot; + envelop_key);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;// Se n&#xe3;o houver, coloca um item no &quot;conjunto de requisi&#xe7;&#xf5;es pendentes de resposta&quot; e espera.&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if (!request_pending_list.ContainsKey(envelop_key))&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;request_pending_list [envelop_key] = new Dictionary&lt;int,Queue&lt;AutoResetEvent>>();&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if (!request_pending_list [envelop_key].ContainsKey(envelop_tag))&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;request_pending_list [envelop_key][envelop_tag] = new Queue&lt;AutoResetEvent>();&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;request_pending_list [envelop_key][envelop_tag].Enqueue(new AutoResetEvent(false));&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;AutoResetEvent sync_send = request_pending_list [envelop_key][envelop_tag].Peek();&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;//request_pending_list [envelop_key][envelop_tag] = sync_send;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;Monitor.Exit(sync);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;Console.WriteLine(&quot;clientSendRequest - WAIT / &quot; + unit.CID.getInstanceName() + &quot;/&quot; + sync_send.GetHashCode()  + &quot; BEFORE !!! &quot; );&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;sync_send.WaitOne();&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;Console.WriteLine(&quot;clientSendRequest - WAIT / &quot; + unit.CID.getInstanceName()  + &quot;/&quot; + sync_send.GetHashCode()  + &quot; AFTER !!! &quot; );&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;Monitor.Enter(sync);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;Console.WriteLine(server_facet + &quot;/&quot; + &quot;: clientSendRequest 3 - AFTER WAIT &quot; + envelop_key);&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;Console.WriteLine(server_facet + &quot;/&quot; + &quot;: clientSendRequest 4&quot; + &quot; / &quot;  + envelop_key);&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;Queue&lt;byte[]> pending_replies = reply_pending_list [envelop_key][envelop_tag];&#xA;&#x9;&#x9;&#x9;&#x9;Console.WriteLine(server_facet + &quot;/&quot; + &quot;: clientSendRequest 5 -- pending_replies.Count = &quot; + pending_replies.Count);&#xA;&#x9;&#x9;&#x9;&#x9;if (pending_replies.Count > 0)&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;messageSide2 = reply_pending_list[envelop_key][envelop_tag].Dequeue();&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;if (pending_replies.Count == 0)&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;reply_pending_list[envelop_key].Remove(envelop_tag);&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;if (reply_pending_list[envelop_key].Count == 0)&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;reply_pending_list.Remove(envelop_key);&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;//reply_pending_list.Remove(envelop_key);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;finally &#xA;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;Monitor.Exit (sync);&#xA;&#x9;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;&#x9;Console.WriteLine(server_facet + &quot;/&quot; + &quot;: clientSendRequest 5&quot;);&#xA;&#x9;&#x9;&#x9;// retorna a menagem ...&#xA;&#x9;&#x9;&#x9;return messageSide2;&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;public byte[] clientSendRequestAnyTag(EnvelopType envelop, byte[] messageSide1, ref int envelop_tag)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;EnvelopKey envelop_key = new EnvelopKey (envelop);&#xA;&#x9;&#x9;&#x9;Console.WriteLine(server_facet + &quot;/&quot; + &quot;: clientSendRequestAnyTag 1&quot; + &quot; / &quot;  + envelop_key +&quot; -- &quot; + instance_name);&#xA;&#xA;&#x9;&#x9;&#x9;byte[] messageSide2 = null;&#xA;&#x9;&#x9;&#x9;Monitor.Enter (sync);&#xA;&#x9;&#x9;&#x9;try&#xA;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;// envia a requisi&#xe7;&#xe3;o para o root parceiro&#xA;&#x9;&#x9;&#x9;&#x9;int facet = envelop.Item3;&#xA;&#x9;&#x9;&#x9;&#x9;Console.WriteLine(server_facet + &quot;/&quot; + &quot;: clientSendRequestAnyTag send to facet &quot; + facet + &quot; - nofsockets=&quot; + client_socket_facet.Count + &quot; / &quot;  + envelop_key+&quot; -- &quot; + instance_name);&#xA;&#x9;&#x9;&#x9;&#x9;foreach (int f in client_socket_facet.Keys)&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;Console.WriteLine(server_facet + &quot;/&quot; + &quot;: clientSendRequestAnyTag --- FACET KEY=&quot; + f);&#xA;&#x9;&#x9;&#x9;&#x9;Socket socket = client_socket_facet [facet];&#xA;&#x9;&#x9;&#x9;&#x9;byte[] messageSide1_enveloped_raw = ObjectToByteArray (new Tuple&lt;EnvelopType,byte[]> (envelop, messageSide1));&#xA;&#x9;&#x9;&#x9;&#x9;Int32 length = messageSide1_enveloped_raw.Length;&#xA;&#x9;&#x9;&#x9;&#x9;byte[] messageSide1_enveloped_raw_ = new byte[4 + length];&#xA;&#x9;&#x9;&#x9;&#x9;BitConverter.GetBytes(length).CopyTo(messageSide1_enveloped_raw_,0);&#xA;&#x9;&#x9;&#x9;&#x9;Array.Copy(messageSide1_enveloped_raw, 0, messageSide1_enveloped_raw_, 4, length);&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;socket.Send (messageSide1_enveloped_raw_);&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;Console.WriteLine(server_facet + &quot;/&quot; + &quot;: clientSendRequestAnyTag 2 nbytes=&quot; + messageSide1_enveloped_raw.Length + &quot; / &quot;  + envelop_key);&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;// Verifica se j&#xe1; h&#xe1; resposta para a requisi&#xe7;&#xe3;o no &quot;conjunto de respostas pendentes de requisi&#xe7;&#xe3;o&quot;&#xA;&#x9;&#x9;&#x9;&#x9;if (!reply_pending_list.ContainsKey (envelop_key))&#xA;&#x9;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;Console.WriteLine(server_facet + &quot;/&quot; + &quot;: clientSendRequestAnyTag 3 - BEFORE WAIT &quot; + envelop_key);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;// Se n&#xe3;o houver, coloca um item no &quot;conjunto de requisi&#xe7;&#xf5;es pendentes de resposta&quot; e espera.&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if (!request_pending_list.ContainsKey(envelop_key))&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;request_pending_list [envelop_key] = new Dictionary&lt;int,Queue&lt;AutoResetEvent>>();&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if (!request_pending_list [envelop_key].ContainsKey(-1))&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;request_pending_list [envelop_key][-1] = new Queue&lt;AutoResetEvent>();&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;request_pending_list [envelop_key][-1].Enqueue(new AutoResetEvent(false));&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;AutoResetEvent sync_send = request_pending_list [envelop_key][-1].Peek();&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;//request_pending_list [envelop_key][envelop_tag] = sync_send;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;Monitor.Exit(sync);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;Console.WriteLine(&quot;clientSendRequestAny - WAIT / &quot; + unit.CID.getInstanceName() + &quot;/&quot; + sync_send.GetHashCode()  + &quot; BEFORE !!! &quot; );&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;sync_send.WaitOne()&#x9;;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;Console.WriteLine(&quot;clientSendRequestAny - WAIT / &quot; + unit.CID.getInstanceName()  + &quot;/&quot; + sync_send.GetHashCode()  + &quot; AFTER !!! &quot; );&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;Monitor.Enter(sync);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;Console.WriteLine(server_facet + &quot;/&quot; + &quot;: clientSendRequestAnyTag 3 - AFTER WAIT &quot; + envelop_key);&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;Console.WriteLine(server_facet + &quot;/&quot; + &quot;: clientSendRequestAnyTag 4&quot; + &quot; / &quot;  + envelop_key);&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;int[] keys_vector = new int[reply_pending_list[envelop_key].Keys.Count];&#xA;&#x9;&#x9;&#x9;&#x9;reply_pending_list[envelop_key].Keys.CopyTo(keys_vector,0);&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;envelop_tag = keys_vector[0];&#xA;&#x9;&#x9;&#x9;&#x9;Queue&lt;byte[]> pending_replies = reply_pending_list [envelop_key][envelop_tag];&#xA;&#x9;&#x9;&#x9;&#x9;Console.WriteLine(server_facet + &quot;/&quot; + &quot;: clientSendRequestAnyTag 5 -- pending_replies.Count = &quot; + pending_replies.Count);&#xA;&#x9;&#x9;&#x9;&#x9;if (pending_replies.Count > 0)&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;messageSide2 = reply_pending_list[envelop_key][envelop_tag].Dequeue();&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;if (pending_replies.Count == 0)&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;reply_pending_list[envelop_key].Remove(envelop_tag);&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;if (reply_pending_list[envelop_key].Count == 0)&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;reply_pending_list.Remove(envelop_key);&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;//reply_pending_list.Remove(envelop_key);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;finally &#xA;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;Monitor.Exit (sync);&#xA;&#x9;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;&#x9;Console.WriteLine(server_facet + &quot;/&quot; + &quot;: clientSendRequest 5&quot;);&#xA;&#x9;&#x9;&#x9;// retorna a menagem ...&#xA;&#x9;&#x9;&#x9;return messageSide2;&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;private static int BUFFER_SIZE = 1024*1024;&#xA;&#xA;&#x9;&#x9;public void serverReceiveRequests(int facet, Socket server_socket)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;byte[] buffer = new byte[BUFFER_SIZE];&#xA;&#x9;&#x9;&#x9;byte[] buffer2 = new byte[BUFFER_SIZE];&#xA;&#xA;&#x9;&#x9;&#x9;int nbytes = default(int);&#xA;&#xA;&#x9;&#x9;&#x9;Console.WriteLine(&quot;serverReceiveRequest RECEIVE &quot; + unit.CID.getInstanceName() + &quot; / facet=&quot; + facet + &quot; BEFORE 1&quot;);&#xA;&#x9;&#x9;&#x9;nbytes = server_socket.Receive (buffer);&#x9;&#x9;    &#xA;&#x9;&#x9;&#x9;Console.WriteLine(&quot;serverReceiveRequest RECEIVE &quot; + unit.CID.getInstanceName() + &quot; / facet=&quot; + facet + &quot; AFTER 1&quot;);&#xA;&#xA;&#x9;&#x9;&#x9;Console.WriteLine(server_facet + &quot;/&quot; + &quot;: serverReceiveRequests 1 - RECEIVED &quot; + nbytes + &quot; bytes -- &quot; + instance_name);&#xA;&#xA;&#x9;&#x9;&#x9;if (nbytes == 0) &#xA;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;string error_message = server_facet + &quot;/&quot; + &quot;: serverReceiveRequests  -- the partner &quot; + this.server_facet + &quot; is died &quot; + instance_name;&#xA;&#x9;&#x9;&#x9;&#x9;Console.WriteLine(error_message);&#xA;&#x9;&#x9;&#x9;&#x9;throw new Exception(error_message);&#xA;&#x9;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;&#x9;while (true)&#xA;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;int length = BitConverter.ToInt32 (buffer, 0);&#xA;&#x9;&#x9;&#x9;&#x9;nbytes = nbytes - 4;&#xA;&#x9;&#x9;&#x9;&#x9;byte[] message = new byte[length];&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;Console.WriteLine(server_facet + &quot;/&quot; + &quot;: serverReceiveRequests 2 - length is &quot; + length + &quot; bytes&quot; + &quot; / nbytes = &quot; + nbytes);&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;while (nbytes &lt; length) &#xA;&#x9;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;int nbytes2 = server_socket.Receive (buffer2);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;Console.WriteLine(server_facet + &quot;/&quot; + &quot;: serverReceiveRequests 2 - LOOP - length is &quot; + length + &quot; bytes&quot; + &quot; / nbytes2 = &quot; + nbytes2 + &quot; / nbytes = &quot; + nbytes);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;Array.Copy (buffer2, 0, buffer, nbytes + 4, nbytes2);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;nbytes += nbytes2;&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;Console.WriteLine(server_facet + &quot;/&quot; + &quot;: serverReceiveRequests 2 - AFTER LOOP - length is &quot; + length + &quot; bytes&quot; + &quot; / nbytes = &quot; + nbytes);&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;Array.Copy(buffer, 4, message, 0, length);&#xA;&#x9;&#x9;&#x9;&#x9;requestQueue.Add (message);&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;if (nbytes == length) &#xA;&#x9;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;Console.WriteLine(&quot;serverReceiveRequest RECEIVE &quot; + unit.CID.getInstanceName() + &quot; / facet=&quot; + facet + &quot; BEFORE 2&quot;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;nbytes = server_socket.Receive (buffer);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;Console.WriteLine(&quot;serverReceiveRequest RECEIVE &quot; + unit.CID.getInstanceName() + &quot; / facet=&quot; + facet + &quot; AFTER 2&quot;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;Console.WriteLine(server_facet + &quot;/&quot; + &quot;: serverReceiveRequests 3 - RECEIVED &quot; + nbytes + &quot; bytes --- &quot; + instance_name);&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if (nbytes == 0) &#xA;&#x9;&#x9;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;string error_message = server_facet + &quot;/&quot; + &quot;: serverReceiveRequests  -- the partner &quot; + this.server_facet + &quot; is died &quot; + instance_name;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;Console.WriteLine(error_message);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;throw new Exception(error_message);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;} &#xA;&#x9;&#x9;&#x9;&#x9;else if (nbytes > length) &#xA;&#x9;&#x9;&#x9;&#x9;{ &#xA;&#x9;&#x9;&#x9;&#x9;&#x9;// assume that nbytes - length > 4&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;byte[] aux = buffer;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;nbytes = nbytes - length;&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;Array.Copy(buffer, length + 4, buffer2, 0, nbytes);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;buffer = buffer2;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;buffer2 = aux;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;Console.WriteLine(server_facet + &quot;/&quot; + &quot;: serverReceiveRequests 4 - nbytes=&quot; + nbytes);&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;private ProducerConsumerQueue&lt;byte[]> requestQueue = new ProducerConsumerQueue&lt;byte[]>();&#xA;&#xA;&#x9;&#x9;public void serverReadRequest() &#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;Console.WriteLine(server_facet + &quot;/&quot; + &quot;: serverReadRequest 1 &quot;);&#xA;&#xA;&#x9;&#x9;&#x9;byte[] buffer =&#x9;requestQueue.Take ();&#xA;&#x9;&#x9;&#x9;int nbytes =  buffer.Length;&#xA;&#xA;&#x9;&#x9;&#x9;Console.WriteLine(server_facet + &quot;/&quot; + &quot;: serverReadRequest 2 &quot; + nbytes + &quot; bytes received.&quot;);&#xA;&#xA;&#x9;&#x9;&#x9;Monitor.Enter (sync);&#xA;&#x9;&#x9;&#x9;try&#xA;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;// Aguarda uma resposta proveniente do outro root parceiro.&#xA;&#x9;&#x9;&#x9;&#x9;byte[] messageSide1_enveloped_raw = new byte[nbytes];&#xA;&#x9;&#x9;&#x9;&#x9;Console.WriteLine(server_facet + &quot;/&quot; + &quot;: serverReadRequest 2-1 nbytes=&quot; + nbytes);&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;// TODO: otimizar isso ...&#xA;&#x9;&#x9;&#x9;&#x9;//for (int i=0; i&lt;nbytes; i++)&#xA;&#x9;&#x9;&#x9;&#x9;//&#x9;messageSide1_enveloped_raw[i] = buffer[i];&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;Array.Copy(buffer,0,messageSide1_enveloped_raw,0,nbytes);&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;Tuple&lt;EnvelopType,byte[]> messageSide1_enveloped = (Tuple&lt;EnvelopType,byte[]>) ByteArrayToObject (messageSide1_enveloped_raw);&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;EnvelopType envelop = messageSide1_enveloped.Item1;&#xA;&#x9;&#x9;&#x9;&#x9;EnvelopKey envelop_key = new EnvelopKey (envelop);&#xA;&#x9;&#x9;&#x9;&#x9;int envelop_tag = envelop.Item6;&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;// Coloca a resposta no &quot;conjunto de respostas pendentes de requisi&#xe7;&#xe3;o&quot;&#xA;&#x9;&#x9;&#x9;&#x9;if (!reply_pending_list.ContainsKey(envelop_key))&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;reply_pending_list [envelop_key] = new Dictionary&lt;int,Queue&lt;byte[]>>();&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;if (!reply_pending_list [envelop_key].ContainsKey(envelop_tag))&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;reply_pending_list [envelop_key][envelop_tag] = new Queue&lt;byte[]>();&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;reply_pending_list [envelop_key][envelop_tag].Enqueue(messageSide1_enveloped.Item2);&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;Console.WriteLine(server_facet + &quot;/&quot; + &quot;: serverReadRequest 3 &quot; + envelop.Item1 + &quot;,&quot; +  envelop_key);&#xA;&#x9;&#x9;&#x9;&#x9;foreach (EnvelopKey ek in request_pending_list.Keys) &#xA;&#x9;&#x9;&#x9;&#x9;&#x9;Console.WriteLine(server_facet + &quot;: key: &quot; + ek);&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;// Busca, no &quot;conjunto de requisi&#xe7;&#xf5;es pendentes de resposta&quot;, a requisi&#xe7;&#xe3;o correspondente a resposta.&#xA;&#x9;&#x9;&#x9;&#x9;if (request_pending_list.ContainsKey (envelop_key) &amp;&amp; request_pending_list[envelop_key].ContainsKey(envelop_tag)) &#xA;&#x9;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;Console.WriteLine(server_facet + &quot;/&quot; + &quot;: serverReadRequest 3-1&quot; + &quot; / &quot;  + envelop_key);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;AutoResetEvent sync_send = request_pending_list[envelop_key][envelop_tag].Dequeue();&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;sync_send.Set();&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if (request_pending_list[envelop_key][envelop_tag].Count == 0)&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;request_pending_list[envelop_key].Remove(envelop_tag);&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if (request_pending_list[envelop_key].Count==0)&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;request_pending_list.Remove(envelop_key);&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;Console.WriteLine(server_facet + &quot;/&quot; + &quot;: serverReadRequest 3-2&quot;+ &quot; / &quot;  + envelop_key) ;&#xA;&#x9;&#x9;&#x9;&#x9;} &#xA;&#x9;&#x9;&#x9;&#x9;else if (request_pending_list.ContainsKey (envelop_key) &amp;&amp; request_pending_list[envelop_key].ContainsKey(-1)) &#xA;&#x9;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;Console.WriteLine(server_facet + &quot;/&quot; + &quot;: serverReadRequest 3-1&quot; + &quot; / &quot;  + envelop_key);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;AutoResetEvent sync_send = request_pending_list[envelop_key][-1].Dequeue();&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;//Monitor.Pulse (sync_send);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;sync_send.Set();&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if (request_pending_list[envelop_key][-1].Count == 0)&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;request_pending_list[envelop_key].Remove(-1);&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if (request_pending_list[envelop_key].Count==0)&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;request_pending_list.Remove(envelop_key);&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;Console.WriteLine(server_facet + &quot;/&quot; + &quot;: serverReadRequest 3-2&quot;+ &quot; / &quot;  + envelop_key) ;&#xA;&#x9;&#x9;&#x9;&#x9;}  &#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;finally &#xA;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;Monitor.Exit (sync);&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;Console.WriteLine(server_facet + &quot;/&quot; + &quot;: serverReadRequest 4&quot;);&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;// Convert an object to a byte array&#xA;&#x9;&#x9;private static byte[] ObjectToByteArray(Object obj)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;if(obj == null)&#xA;&#x9;&#x9;&#x9;&#x9;return null;&#xA;&#x9;&#x9;&#x9;BinaryFormatter bf = new BinaryFormatter();&#xA;&#x9;&#x9;&#x9;MemoryStream ms = new MemoryStream();&#xA;&#x9;&#x9;&#x9;bf.Serialize(ms, obj);&#xA;&#x9;&#x9;&#x9;return ms.ToArray();&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;// Convert a byte array to an Object&#xA;&#x9;&#x9;private static Object ByteArrayToObject(byte[] arrBytes)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;MemoryStream memStream = new MemoryStream();&#xA;&#x9;&#x9;&#x9;BinaryFormatter binForm = new BinaryFormatter();&#xA;&#x9;&#x9;&#x9;memStream.Write(arrBytes, 0, arrBytes.Length);&#xA;&#x9;&#x9;&#x9;memStream.Seek(0, SeekOrigin.Begin);&#xA;&#x9;&#x9;&#x9;Object obj = (Object) binForm.Deserialize(memStream);&#xA;&#x9;&#x9;&#x9;return obj;&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#xA;&#x9;class EnvelopKey&#xA;&#x9;{&#xA;&#x9;&#x9;private EnvelopType envelop = null;&#xA;&#x9;&#x9;public EnvelopKey(EnvelopType envelop)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;this.envelop = envelop;&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;public override string ToString ()&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;string key=base.ToString();&#xA;&#x9;&#x9;&#x9;switch (envelop.Item1) {&#xA;&#x9;&#x9;&#x9;case AliencommunicatorOperation.SEND:&#xA;&#x9;&#x9;&#x9;case AliencommunicatorOperation.SYNC_SEND:&#xA;&#x9;&#x9;&#x9;case AliencommunicatorOperation.SEND_ARRAY:&#xA;&#x9;&#x9;&#x9;&#x9;//&#x9;&#x9;&#x9;&#x9;key = string.Format (&quot;SR-{0}-{1}-{2}-{3}-{4}&quot;,envelop.Item2, envelop.Item3, envelop.Item4, envelop.Item5, envelop.Item6);&#xA;&#x9;&#x9;&#x9;&#x9;key = string.Format (&quot;SR-{0}-{1}-{2}-{3}&quot;,envelop.Item2, envelop.Item3, envelop.Item4, envelop.Item5);&#xA;&#x9;&#x9;&#x9;&#x9;break;&#xA;&#x9;&#x9;&#x9;case AliencommunicatorOperation.RECEIVE:&#xA;&#x9;&#x9;&#x9;case AliencommunicatorOperation.RECEIVE_ARRAY:&#xA;&#x9;&#x9;&#x9;&#x9;//&#x9;&#x9;&#x9;&#x9;key = string.Format (&quot;SR-{1}-{0}-{3}-{2}-{4}&quot;,envelop.Item2, envelop.Item3, envelop.Item4, envelop.Item5, envelop.Item6);&#xA;&#x9;&#x9;&#x9;&#x9;key = string.Format (&quot;SR-{1}-{0}-{3}-{2}&quot;,envelop.Item2, envelop.Item3, envelop.Item4, envelop.Item5);&#xA;&#x9;&#x9;&#x9;&#x9;break;&#xA;&#x9;&#x9;&#x9;case AliencommunicatorOperation.PROBE:&#xA;&#x9;&#x9;&#x9;&#x9;break;&#xA;&#x9;&#x9;&#x9;case AliencommunicatorOperation.ALL_GATHER:&#xA;&#x9;&#x9;&#x9;&#x9;break;&#xA;&#x9;&#x9;&#x9;case AliencommunicatorOperation.ALL_GATHER_FLATTENED:&#xA;&#x9;&#x9;&#x9;&#x9;break;&#xA;&#x9;&#x9;&#x9;case AliencommunicatorOperation.ALL_REDUCE:&#xA;&#x9;&#x9;&#x9;&#x9;break;&#xA;&#x9;&#x9;&#x9;case AliencommunicatorOperation.ALL_REDUCE_ARRAY:&#xA;&#x9;&#x9;&#x9;&#x9;break;&#xA;&#x9;&#x9;&#x9;case AliencommunicatorOperation.ALL_TO_ALL:&#xA;&#x9;&#x9;&#x9;&#x9;break;&#xA;&#x9;&#x9;&#x9;case AliencommunicatorOperation.ALL_TO_ALL_FLATTENED:&#xA;&#x9;&#x9;&#x9;&#x9;break;&#xA;&#x9;&#x9;&#x9;case AliencommunicatorOperation.REDUCE_SCATTER:&#xA;&#x9;&#x9;&#x9;&#x9;break;&#xA;&#x9;&#x9;&#x9;case AliencommunicatorOperation.BROADCAST:&#xA;&#x9;&#x9;&#x9;&#x9;break;&#xA;&#x9;&#x9;&#x9;case AliencommunicatorOperation.BROADCAST_ARRAY:&#xA;&#x9;&#x9;&#x9;&#x9;break;&#xA;&#x9;&#x9;&#x9;case AliencommunicatorOperation.SCATTER:&#xA;&#x9;&#x9;&#x9;&#x9;break;&#xA;&#x9;&#x9;&#x9;case AliencommunicatorOperation.SCATTER_FROM_FLATTENED:&#xA;&#x9;&#x9;&#x9;&#x9;break;&#xA;&#x9;&#x9;&#x9;case AliencommunicatorOperation.GATHER:&#xA;&#x9;&#x9;&#x9;&#x9;break;&#xA;&#x9;&#x9;&#x9;case AliencommunicatorOperation.GATHER_FLATTENED:&#xA;&#x9;&#x9;&#x9;&#x9;break;&#xA;&#x9;&#x9;&#x9;case AliencommunicatorOperation.REDUCE:&#xA;&#x9;&#x9;&#x9;&#x9;break;&#xA;&#x9;&#x9;&#x9;case AliencommunicatorOperation.REDUCE_ARRAY:&#xA;&#x9;&#x9;&#x9;&#x9;break;&#xA;&#x9;&#x9;&#x9;default:&#xA;&#x9;&#x9;&#x9;&#x9;throw new ArgumentOutOfRangeException ();&#xA;&#x9;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;&#x9;return key;&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;public override bool Equals(object obj)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;EnvelopKey fooItem = obj as EnvelopKey;&#xA;&#xA;&#x9;&#x9;&#x9;return fooItem.ToString().Equals(this.ToString());&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;public override int GetHashCode ()&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;return this.ToString().GetHashCode();&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;}&#xA;&#xA;&#x9;public class ProducerConsumerQueue&lt;T> : BlockingCollection&lt;T>&#xA;&#x9;{&#xA;&#x9;&#x9;/// &lt;summary>&#xA;&#x9;&#x9;/// Initializes a new instance of the ProducerConsumerQueue, Use Add and TryAdd for Enqueue and TryEnqueue and Take and TryTake for Dequeue and TryDequeue functionality&#xA;&#x9;&#x9;/// &lt;/summary>&#xA;&#x9;&#x9;public ProducerConsumerQueue()  &#xA;&#x9;&#x9;&#x9;: base(new ConcurrentQueue&lt;T>())&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;/// &lt;summary>&#xA;&#x9;&#x9;/// Initializes a new instance of the ProducerConsumerQueue, Use Add and TryAdd for Enqueue and TryEnqueue and Take and TryTake for Dequeue and TryDequeue functionality&#xA;&#x9;&#x9;/// &lt;/summary>&#xA;&#x9;&#x9;/// &lt;param name=&quot;maxSize&quot;>&lt;/param>&#xA;&#x9;&#x9;public ProducerConsumerQueue(int maxSize)&#xA;&#x9;&#x9;&#x9;: base(new ConcurrentQueue&lt;T>(), maxSize)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;}&#xA;&#xA;&#xA;&#xA;&#x9;}&#xA;&#xA;}&#xA;" name="IChannelImpl.cs" srcType="user" uri="br.ufc.mdcc.hpc.storm.binding.channel.impl.SAFeBindingImpl/bin/1.0.0.0/IChannelImpl.dll" versionId="1.0.0.0">
          <dependency>%WORKSPACE/br.ufc.mdcc.hpc.storm.binding.channel.impl.SAFeBindingImpl/bin/1.0.0.0/BaseIChannelImpl.dll</dependency>
          <dependency>br.ufc.mdcc.hpc.storm.binding.channel.Binding/bin/1.0.0.0/IChannel.dll</dependency>
          <externalDependency>MPI</externalDependency>
        </file>
      </sources>
      <visualDescription h="40" w="179" x="227" y="489">
        <color b="144" g="238" r="144"/>
      </visualDescription>
      <externalReferences>MPI</externalReferences>
    </interface>
    <unit facet="0" iRef="IChannelRootImpl" multiple="false" private="true" replica="0" uRef="root" visibleInterface="true">
      <super cRef="base" uRef="root"/>
      <visualDescription h="40" w="146" x="215" y="128"/>
    </unit>
    <unit facet="0" iRef="IChannelImpl" multiple="true" private="false" replica="0" uRef="peer" visibleInterface="true">
      <super cRef="base" uRef="peer"/>
      <visualDescription h="47" w="133" x="229" y="366"/>
    </unit>
  </componentInfo>
</component:component>